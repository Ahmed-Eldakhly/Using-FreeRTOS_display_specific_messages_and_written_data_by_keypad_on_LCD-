
FreeRTOS_SprintsChallenges_Sprint2_UserStory1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005448  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000072  00800060  00005448  000054dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000657  008000d2  008000d2  0000554e  2**0
                  ALLOC
  3 .stab         00008cdc  00000000  00000000  00005550  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004946  00000000  00000000  0000e22c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 40 0e 	jmp	0x1c80	; 0x1c80 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e4       	ldi	r30, 0x48	; 72
      68:	f4 e5       	ldi	r31, 0x54	; 84
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3d       	cpi	r26, 0xD2	; 210
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a2 ed       	ldi	r26, 0xD2	; 210
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 32       	cpi	r26, 0x29	; 41
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 56 0b 	call	0x16ac	; 0x16ac <main>
      8a:	0c 94 22 2a 	jmp	0x5444	; 0x5444 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 1)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	81 30       	cpi	r24, 0x01	; 1
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 1)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	81 30       	cpi	r24, 0x01	; 1
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	00 d0       	rcall	.+0      	; 0x592 <init_Task+0xc>
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	/*Create Queues*/
	MessageQueue_PushButton = xQueueCreate( 3 , sizeof(uint8));
     59a:	83 e0       	ldi	r24, 0x03	; 3
     59c:	61 e0       	ldi	r22, 0x01	; 1
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <xQueueGenericCreate>
     5a4:	90 93 d7 00 	sts	0x00D7, r25
     5a8:	80 93 d6 00 	sts	0x00D6, r24
	MessageQueue_Hello= xQueueCreate( 3 , sizeof(uint8));
     5ac:	83 e0       	ldi	r24, 0x03	; 3
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <xQueueGenericCreate>
     5b6:	90 93 d9 00 	sts	0x00D9, r25
     5ba:	80 93 d8 00 	sts	0x00D8, r24

	/*Create 4 Tasks*/
	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     5be:	86 e2       	ldi	r24, 0x26	; 38
     5c0:	93 e0       	ldi	r25, 0x03	; 3
     5c2:	20 e6       	ldi	r18, 0x60	; 96
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	e2 ed       	ldi	r30, 0xD2	; 210
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	b9 01       	movw	r22, r18
     5cc:	46 e9       	ldi	r20, 0x96	; 150
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	05 e0       	ldi	r16, 0x05	; 5
     5d6:	7f 01       	movw	r14, r30
     5d8:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);
	xTaskCreate(PushButton_Task  , "PushButton_Task" , configMINIMAL_STACK_SIZE ,
     5dc:	88 e3       	ldi	r24, 0x38	; 56
     5de:	93 e0       	ldi	r25, 0x03	; 3
     5e0:	2a e6       	ldi	r18, 0x6A	; 106
     5e2:	30 e0       	ldi	r19, 0x00	; 0
     5e4:	b9 01       	movw	r22, r18
     5e6:	46 e9       	ldi	r20, 0x96	; 150
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	03 e0       	ldi	r16, 0x03	; 3
     5f0:	ee 24       	eor	r14, r14
     5f2:	ff 24       	eor	r15, r15
     5f4:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     5f8:	82 ea       	ldi	r24, 0xA2	; 162
     5fa:	93 e0       	ldi	r25, 0x03	; 3
     5fc:	2a e7       	ldi	r18, 0x7A	; 122
     5fe:	30 e0       	ldi	r19, 0x00	; 0
     600:	b9 01       	movw	r22, r18
     602:	46 e9       	ldi	r20, 0x96	; 150
     604:	50 e0       	ldi	r21, 0x00	; 0
     606:	20 e0       	ldi	r18, 0x00	; 0
     608:	30 e0       	ldi	r19, 0x00	; 0
     60a:	01 e0       	ldi	r16, 0x01	; 1
     60c:	ee 24       	eor	r14, r14
     60e:	ff 24       	eor	r15, r15
     610:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(SendHallo_Task  , "SendHallo_Task" , configMINIMAL_STACK_SIZE ,
     614:	8a eb       	ldi	r24, 0xBA	; 186
     616:	94 e0       	ldi	r25, 0x04	; 4
     618:	23 e8       	ldi	r18, 0x83	; 131
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	b9 01       	movw	r22, r18
     61e:	46 e9       	ldi	r20, 0x96	; 150
     620:	50 e0       	ldi	r21, 0x00	; 0
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	02 e0       	ldi	r16, 0x02	; 2
     628:	ee 24       	eor	r14, r14
     62a:	ff 24       	eor	r15, r15
     62c:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);
	vTaskSuspend( InitTask_Flag);
     630:	80 91 d4 00 	lds	r24, 0x00D4
     634:	90 91 d5 00 	lds	r25, 0x00D5
     638:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <vTaskSuspend>
}
     63c:	0f 90       	pop	r0
     63e:	0f 90       	pop	r0
     640:	cf 91       	pop	r28
     642:	df 91       	pop	r29
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	08 95       	ret

0000064c <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     64c:	df 93       	push	r29
     64e:	cf 93       	push	r28
     650:	00 d0       	rcall	.+0      	; 0x652 <All_Hardware_Init_Task+0x6>
     652:	cd b7       	in	r28, 0x3d	; 61
     654:	de b7       	in	r29, 0x3e	; 62
     656:	9a 83       	std	Y+2, r25	; 0x02
     658:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		PushButton_Init();
     65a:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
		LCD_init();
     65e:	0e 94 97 08 	call	0x112e	; 0x112e <LCD_init>
		vTaskSuspend( AllHardwareInit_Flag);
     662:	80 91 d2 00 	lds	r24, 0x00D2
     666:	90 91 d3 00 	lds	r25, 0x00D3
     66a:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <vTaskSuspend>
     66e:	f5 cf       	rjmp	.-22     	; 0x65a <All_Hardware_Init_Task+0xe>

00000670 <PushButton_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButton_Task(void * a_Task_ptr)
{
     670:	df 93       	push	r29
     672:	cf 93       	push	r28
     674:	00 d0       	rcall	.+0      	; 0x676 <PushButton_Task+0x6>
     676:	00 d0       	rcall	.+0      	; 0x678 <PushButton_Task+0x8>
     678:	0f 92       	push	r0
     67a:	cd b7       	in	r28, 0x3d	; 61
     67c:	de b7       	in	r29, 0x3e	; 62
     67e:	9d 83       	std	Y+5, r25	; 0x05
     680:	8c 83       	std	Y+4, r24	; 0x04
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     686:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     688:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==1)
     68a:	8a 81       	ldd	r24, Y+2	; 0x02
     68c:	88 23       	and	r24, r24
     68e:	79 f4       	brne	.+30     	; 0x6ae <PushButton_Task+0x3e>
     690:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     694:	81 30       	cpi	r24, 0x01	; 1
     696:	59 f4       	brne	.+22     	; 0x6ae <PushButton_Task+0x3e>
		{
			OldPressedValue =  Buttons_getPressedButton();
     698:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     69c:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     69e:	8a 81       	ldd	r24, Y+2	; 0x02
     6a0:	8f 5f       	subi	r24, 0xFF	; 255
     6a2:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     6a4:	8a e0       	ldi	r24, 0x0A	; 10
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
     6ac:	ee cf       	rjmp	.-36     	; 0x68a <PushButton_Task+0x1a>
		}
		else if(Debouncing == 1)
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	81 30       	cpi	r24, 0x01	; 1
     6b2:	e9 f4       	brne	.+58     	; 0x6ee <PushButton_Task+0x7e>
		{
			SendData = 1;
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	8b 83       	std	Y+3, r24	; 0x03
			/*Send push Button was pressed to Lcd by queue*/
			xQueueSend(MessageQueue_PushButton , &SendData , 5);
     6b8:	80 91 d6 00 	lds	r24, 0x00D6
     6bc:	90 91 d7 00 	lds	r25, 0x00D7
     6c0:	9e 01       	movw	r18, r28
     6c2:	2d 5f       	subi	r18, 0xFD	; 253
     6c4:	3f 4f       	sbci	r19, 0xFF	; 255
     6c6:	b9 01       	movw	r22, r18
     6c8:	45 e0       	ldi	r20, 0x05	; 5
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	20 e0       	ldi	r18, 0x00	; 0
     6ce:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
     6d2:	04 c0       	rjmp	.+8      	; 0x6dc <PushButton_Task+0x6c>
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{

				vTaskDelay(100);
     6d4:	84 e6       	ldi	r24, 0x64	; 100
     6d6:	90 e0       	ldi	r25, 0x00	; 0
     6d8:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
		{
			SendData = 1;
			/*Send push Button was pressed to Lcd by queue*/
			xQueueSend(MessageQueue_PushButton , &SendData , 5);
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     6dc:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6e0:	98 2f       	mov	r25, r24
     6e2:	89 81       	ldd	r24, Y+1	; 0x01
     6e4:	98 17       	cp	r25, r24
     6e6:	b1 f3       	breq	.-20     	; 0x6d4 <PushButton_Task+0x64>
			{

				vTaskDelay(100);
			}
			Debouncing = 2;
     6e8:	82 e0       	ldi	r24, 0x02	; 2
     6ea:	8a 83       	std	Y+2, r24	; 0x02
     6ec:	ce cf       	rjmp	.-100    	; 0x68a <PushButton_Task+0x1a>
		}
		else if(Debouncing == 2)
     6ee:	8a 81       	ldd	r24, Y+2	; 0x02
     6f0:	82 30       	cpi	r24, 0x02	; 2
     6f2:	a1 f4       	brne	.+40     	; 0x71c <PushButton_Task+0xac>
		{
			SendData = 0;
     6f4:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(MessageQueue_PushButton , &SendData , 5);
     6f6:	80 91 d6 00 	lds	r24, 0x00D6
     6fa:	90 91 d7 00 	lds	r25, 0x00D7
     6fe:	9e 01       	movw	r18, r28
     700:	2d 5f       	subi	r18, 0xFD	; 253
     702:	3f 4f       	sbci	r19, 0xFF	; 255
     704:	b9 01       	movw	r22, r18
     706:	45 e0       	ldi	r20, 0x05	; 5
     708:	50 e0       	ldi	r21, 0x00	; 0
     70a:	20 e0       	ldi	r18, 0x00	; 0
     70c:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
			Debouncing = 0;
     710:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(100);
     712:	84 e6       	ldi	r24, 0x64	; 100
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
     71a:	b7 cf       	rjmp	.-146    	; 0x68a <PushButton_Task+0x1a>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     71c:	83 e0       	ldi	r24, 0x03	; 3
     71e:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(MessageQueue_PushButton , &SendData , 5);
     720:	80 91 d6 00 	lds	r24, 0x00D6
     724:	90 91 d7 00 	lds	r25, 0x00D7
     728:	9e 01       	movw	r18, r28
     72a:	2d 5f       	subi	r18, 0xFD	; 253
     72c:	3f 4f       	sbci	r19, 0xFF	; 255
     72e:	b9 01       	movw	r22, r18
     730:	45 e0       	ldi	r20, 0x05	; 5
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	20 e0       	ldi	r18, 0x00	; 0
     736:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
			vTaskDelay(100);
     73a:	84 e6       	ldi	r24, 0x64	; 100
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
     742:	a3 cf       	rjmp	.-186    	; 0x68a <PushButton_Task+0x1a>

00000744 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     744:	df 93       	push	r29
     746:	cf 93       	push	r28
     748:	cd b7       	in	r28, 0x3d	; 61
     74a:	de b7       	in	r29, 0x3e	; 62
     74c:	c6 54       	subi	r28, 0x46	; 70
     74e:	d0 40       	sbci	r29, 0x00	; 0
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	de bf       	out	0x3e, r29	; 62
     756:	0f be       	out	0x3f, r0	; 63
     758:	cd bf       	out	0x3d, r28	; 61
     75a:	9f ab       	std	Y+55, r25	; 0x37
     75c:	8e ab       	std	Y+54, r24	; 0x36
	vTaskDelay(100);
     75e:	84 e6       	ldi	r24, 0x64	; 100
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>

	/*received message from Hello Task to display button state on LCD*/
	uint8 HelloTask_Data;

	/*Push Button "Pressed" message*/
	uint8 ButtonPressedString[] = "Over Written!!!!";
     766:	ce 01       	movw	r24, r28
     768:	06 96       	adiw	r24, 0x06	; 6
     76a:	99 af       	std	Y+57, r25	; 0x39
     76c:	88 af       	std	Y+56, r24	; 0x38
     76e:	e2 e9       	ldi	r30, 0x92	; 146
     770:	f0 e0       	ldi	r31, 0x00	; 0
     772:	fb af       	std	Y+59, r31	; 0x3b
     774:	ea af       	std	Y+58, r30	; 0x3a
     776:	f1 e1       	ldi	r31, 0x11	; 17
     778:	fc af       	std	Y+60, r31	; 0x3c
     77a:	ea ad       	ldd	r30, Y+58	; 0x3a
     77c:	fb ad       	ldd	r31, Y+59	; 0x3b
     77e:	00 80       	ld	r0, Z
     780:	8a ad       	ldd	r24, Y+58	; 0x3a
     782:	9b ad       	ldd	r25, Y+59	; 0x3b
     784:	01 96       	adiw	r24, 0x01	; 1
     786:	9b af       	std	Y+59, r25	; 0x3b
     788:	8a af       	std	Y+58, r24	; 0x3a
     78a:	e8 ad       	ldd	r30, Y+56	; 0x38
     78c:	f9 ad       	ldd	r31, Y+57	; 0x39
     78e:	00 82       	st	Z, r0
     790:	88 ad       	ldd	r24, Y+56	; 0x38
     792:	99 ad       	ldd	r25, Y+57	; 0x39
     794:	01 96       	adiw	r24, 0x01	; 1
     796:	99 af       	std	Y+57, r25	; 0x39
     798:	88 af       	std	Y+56, r24	; 0x38
     79a:	9c ad       	ldd	r25, Y+60	; 0x3c
     79c:	91 50       	subi	r25, 0x01	; 1
     79e:	9c af       	std	Y+60, r25	; 0x3c
     7a0:	ec ad       	ldd	r30, Y+60	; 0x3c
     7a2:	ee 23       	and	r30, r30
     7a4:	51 f7       	brne	.-44     	; 0x77a <LCD_Task+0x36>

	/*Hello message*/
	uint8 MessageString[] = "Hello LCD !!";
     7a6:	ce 01       	movw	r24, r28
     7a8:	47 96       	adiw	r24, 0x17	; 23
     7aa:	9e af       	std	Y+62, r25	; 0x3e
     7ac:	8d af       	std	Y+61, r24	; 0x3d
     7ae:	e3 ea       	ldi	r30, 0xA3	; 163
     7b0:	f0 e0       	ldi	r31, 0x00	; 0
     7b2:	21 96       	adiw	r28, 0x01	; 1
     7b4:	ff af       	std	Y+63, r31	; 0x3f
     7b6:	ee af       	std	Y+62, r30	; 0x3e
     7b8:	21 97       	sbiw	r28, 0x01	; 1
     7ba:	fd e0       	ldi	r31, 0x0D	; 13
     7bc:	22 96       	adiw	r28, 0x02	; 2
     7be:	ff af       	std	Y+63, r31	; 0x3f
     7c0:	22 97       	sbiw	r28, 0x02	; 2
     7c2:	21 96       	adiw	r28, 0x01	; 1
     7c4:	ee ad       	ldd	r30, Y+62	; 0x3e
     7c6:	ff ad       	ldd	r31, Y+63	; 0x3f
     7c8:	21 97       	sbiw	r28, 0x01	; 1
     7ca:	00 80       	ld	r0, Z
     7cc:	21 96       	adiw	r28, 0x01	; 1
     7ce:	8e ad       	ldd	r24, Y+62	; 0x3e
     7d0:	9f ad       	ldd	r25, Y+63	; 0x3f
     7d2:	21 97       	sbiw	r28, 0x01	; 1
     7d4:	01 96       	adiw	r24, 0x01	; 1
     7d6:	21 96       	adiw	r28, 0x01	; 1
     7d8:	9f af       	std	Y+63, r25	; 0x3f
     7da:	8e af       	std	Y+62, r24	; 0x3e
     7dc:	21 97       	sbiw	r28, 0x01	; 1
     7de:	ed ad       	ldd	r30, Y+61	; 0x3d
     7e0:	fe ad       	ldd	r31, Y+62	; 0x3e
     7e2:	00 82       	st	Z, r0
     7e4:	8d ad       	ldd	r24, Y+61	; 0x3d
     7e6:	9e ad       	ldd	r25, Y+62	; 0x3e
     7e8:	01 96       	adiw	r24, 0x01	; 1
     7ea:	9e af       	std	Y+62, r25	; 0x3e
     7ec:	8d af       	std	Y+61, r24	; 0x3d
     7ee:	22 96       	adiw	r28, 0x02	; 2
     7f0:	9f ad       	ldd	r25, Y+63	; 0x3f
     7f2:	22 97       	sbiw	r28, 0x02	; 2
     7f4:	91 50       	subi	r25, 0x01	; 1
     7f6:	22 96       	adiw	r28, 0x02	; 2
     7f8:	9f af       	std	Y+63, r25	; 0x3f
     7fa:	22 97       	sbiw	r28, 0x02	; 2
     7fc:	22 96       	adiw	r28, 0x02	; 2
     7fe:	ef ad       	ldd	r30, Y+63	; 0x3f
     800:	22 97       	sbiw	r28, 0x02	; 2
     802:	ee 23       	and	r30, r30
     804:	f1 f6       	brne	.-68     	; 0x7c2 <LCD_Task+0x7e>
	/*Clear one line*/
	uint8 Spaces[] =  "                 ";
     806:	ce 01       	movw	r24, r28
     808:	84 96       	adiw	r24, 0x24	; 36
     80a:	24 96       	adiw	r28, 0x04	; 4
     80c:	9f af       	std	Y+63, r25	; 0x3f
     80e:	8e af       	std	Y+62, r24	; 0x3e
     810:	24 97       	sbiw	r28, 0x04	; 4
     812:	e0 eb       	ldi	r30, 0xB0	; 176
     814:	f0 e0       	ldi	r31, 0x00	; 0
     816:	26 96       	adiw	r28, 0x06	; 6
     818:	ff af       	std	Y+63, r31	; 0x3f
     81a:	ee af       	std	Y+62, r30	; 0x3e
     81c:	26 97       	sbiw	r28, 0x06	; 6
     81e:	f2 e1       	ldi	r31, 0x12	; 18
     820:	27 96       	adiw	r28, 0x07	; 7
     822:	ff af       	std	Y+63, r31	; 0x3f
     824:	27 97       	sbiw	r28, 0x07	; 7
     826:	26 96       	adiw	r28, 0x06	; 6
     828:	ee ad       	ldd	r30, Y+62	; 0x3e
     82a:	ff ad       	ldd	r31, Y+63	; 0x3f
     82c:	26 97       	sbiw	r28, 0x06	; 6
     82e:	00 80       	ld	r0, Z
     830:	26 96       	adiw	r28, 0x06	; 6
     832:	8e ad       	ldd	r24, Y+62	; 0x3e
     834:	9f ad       	ldd	r25, Y+63	; 0x3f
     836:	26 97       	sbiw	r28, 0x06	; 6
     838:	01 96       	adiw	r24, 0x01	; 1
     83a:	26 96       	adiw	r28, 0x06	; 6
     83c:	9f af       	std	Y+63, r25	; 0x3f
     83e:	8e af       	std	Y+62, r24	; 0x3e
     840:	26 97       	sbiw	r28, 0x06	; 6
     842:	24 96       	adiw	r28, 0x04	; 4
     844:	ee ad       	ldd	r30, Y+62	; 0x3e
     846:	ff ad       	ldd	r31, Y+63	; 0x3f
     848:	24 97       	sbiw	r28, 0x04	; 4
     84a:	00 82       	st	Z, r0
     84c:	24 96       	adiw	r28, 0x04	; 4
     84e:	8e ad       	ldd	r24, Y+62	; 0x3e
     850:	9f ad       	ldd	r25, Y+63	; 0x3f
     852:	24 97       	sbiw	r28, 0x04	; 4
     854:	01 96       	adiw	r24, 0x01	; 1
     856:	24 96       	adiw	r28, 0x04	; 4
     858:	9f af       	std	Y+63, r25	; 0x3f
     85a:	8e af       	std	Y+62, r24	; 0x3e
     85c:	24 97       	sbiw	r28, 0x04	; 4
     85e:	27 96       	adiw	r28, 0x07	; 7
     860:	9f ad       	ldd	r25, Y+63	; 0x3f
     862:	27 97       	sbiw	r28, 0x07	; 7
     864:	91 50       	subi	r25, 0x01	; 1
     866:	27 96       	adiw	r28, 0x07	; 7
     868:	9f af       	std	Y+63, r25	; 0x3f
     86a:	27 97       	sbiw	r28, 0x07	; 7
     86c:	27 96       	adiw	r28, 0x07	; 7
     86e:	ef ad       	ldd	r30, Y+63	; 0x3f
     870:	27 97       	sbiw	r28, 0x07	; 7
     872:	ee 23       	and	r30, r30
     874:	c1 f6       	brne	.-80     	; 0x826 <LCD_Task+0xe2>

	/*counter to hundle displaying of hello message*/
	uint8 Counter = 0;
     876:	1b 82       	std	Y+3, r1	; 0x03

	/*Synchronize between displaying of Push Button task and hello task*/
	uint8 Flag = 0;
     878:	1a 82       	std	Y+2, r1	; 0x02
	uint8 Flag2 = 0;
     87a:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*receive messages fro other tasks by queues*/
		xQueueReceive(MessageQueue_PushButton , &PushButtonTask_Data , 100);
     87c:	80 91 d6 00 	lds	r24, 0x00D6
     880:	90 91 d7 00 	lds	r25, 0x00D7
     884:	9e 01       	movw	r18, r28
     886:	2c 5f       	subi	r18, 0xFC	; 252
     888:	3f 4f       	sbci	r19, 0xFF	; 255
     88a:	b9 01       	movw	r22, r18
     88c:	44 e6       	ldi	r20, 0x64	; 100
     88e:	50 e0       	ldi	r21, 0x00	; 0
     890:	0e 94 aa 10 	call	0x2154	; 0x2154 <xQueueReceive>
		xQueueReceive(MessageQueue_Hello , &HelloTask_Data , 100);
     894:	80 91 d8 00 	lds	r24, 0x00D8
     898:	90 91 d9 00 	lds	r25, 0x00D9
     89c:	9e 01       	movw	r18, r28
     89e:	2b 5f       	subi	r18, 0xFB	; 251
     8a0:	3f 4f       	sbci	r19, 0xFF	; 255
     8a2:	b9 01       	movw	r22, r18
     8a4:	44 e6       	ldi	r20, 0x64	; 100
     8a6:	50 e0       	ldi	r21, 0x00	; 0
     8a8:	0e 94 aa 10 	call	0x2154	; 0x2154 <xQueueReceive>

		/*Increment counter to Display Hello message for specific time*/
		if(Counter != 0)
     8ac:	8b 81       	ldd	r24, Y+3	; 0x03
     8ae:	88 23       	and	r24, r24
     8b0:	19 f0       	breq	.+6      	; 0x8b8 <__stack+0x59>
		{
			Counter++;
     8b2:	8b 81       	ldd	r24, Y+3	; 0x03
     8b4:	8f 5f       	subi	r24, 0xFF	; 255
     8b6:	8b 83       	std	Y+3, r24	; 0x03
		{
			/*Do Nothing*/
		}

		/*check on Push Button Message is received*/
		if(PushButtonTask_Data == 1)
     8b8:	8c 81       	ldd	r24, Y+4	; 0x04
     8ba:	81 30       	cpi	r24, 0x01	; 1
     8bc:	69 f4       	brne	.+26     	; 0x8d8 <__stack+0x79>
		{
			LCD_displayStringRowColumn(1 , 0 , ButtonPressedString);
     8be:	9e 01       	movw	r18, r28
     8c0:	2a 5f       	subi	r18, 0xFA	; 250
     8c2:	3f 4f       	sbci	r19, 0xFF	; 255
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	60 e0       	ldi	r22, 0x00	; 0
     8c8:	a9 01       	movw	r20, r18
     8ca:	0e 94 fd 09 	call	0x13fa	; 0x13fa <LCD_displayStringRowColumn>
			PushButtonTask_Data = 5;
     8ce:	85 e0       	ldi	r24, 0x05	; 5
     8d0:	8c 83       	std	Y+4, r24	; 0x04
			Flag = 1;
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	8a 83       	std	Y+2, r24	; 0x02
     8d6:	1a c0       	rjmp	.+52     	; 0x90c <__stack+0xad>
		}
		else if(PushButtonTask_Data == 0)
     8d8:	8c 81       	ldd	r24, Y+4	; 0x04
     8da:	88 23       	and	r24, r24
     8dc:	b9 f4       	brne	.+46     	; 0x90c <__stack+0xad>
		{
			Flag = 0;
     8de:	1a 82       	std	Y+2, r1	; 0x02
			if(Flag2 == 1)
     8e0:	89 81       	ldd	r24, Y+1	; 0x01
     8e2:	81 30       	cpi	r24, 0x01	; 1
     8e4:	89 f4       	brne	.+34     	; 0x908 <__stack+0xa9>
			{
				LCD_displayStringRowColumn(1 , 0 ,Spaces);
     8e6:	9e 01       	movw	r18, r28
     8e8:	2c 5d       	subi	r18, 0xDC	; 220
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	81 e0       	ldi	r24, 0x01	; 1
     8ee:	60 e0       	ldi	r22, 0x00	; 0
     8f0:	a9 01       	movw	r20, r18
     8f2:	0e 94 fd 09 	call	0x13fa	; 0x13fa <LCD_displayStringRowColumn>
				LCD_displayStringRowColumn(0 , 0 , MessageString);
     8f6:	9e 01       	movw	r18, r28
     8f8:	29 5e       	subi	r18, 0xE9	; 233
     8fa:	3f 4f       	sbci	r19, 0xFF	; 255
     8fc:	80 e0       	ldi	r24, 0x00	; 0
     8fe:	60 e0       	ldi	r22, 0x00	; 0
     900:	a9 01       	movw	r20, r18
     902:	0e 94 fd 09 	call	0x13fa	; 0x13fa <LCD_displayStringRowColumn>
     906:	02 c0       	rjmp	.+4      	; 0x90c <__stack+0xad>
			}
			else
			{
				LCD_clearScreen();
     908:	0e 94 16 0a 	call	0x142c	; 0x142c <LCD_clearScreen>
			}
		}

		/*check on Hello Message is received*/
		if(HelloTask_Data == 2)
     90c:	8d 81       	ldd	r24, Y+5	; 0x05
     90e:	82 30       	cpi	r24, 0x02	; 2
     910:	89 f4       	brne	.+34     	; 0x934 <__stack+0xd5>
		{
			LCD_displayStringRowColumn(0 , 0 , MessageString);
     912:	9e 01       	movw	r18, r28
     914:	29 5e       	subi	r18, 0xE9	; 233
     916:	3f 4f       	sbci	r19, 0xFF	; 255
     918:	80 e0       	ldi	r24, 0x00	; 0
     91a:	60 e0       	ldi	r22, 0x00	; 0
     91c:	a9 01       	movw	r20, r18
     91e:	0e 94 fd 09 	call	0x13fa	; 0x13fa <LCD_displayStringRowColumn>
			if(Counter == 0)
     922:	8b 81       	ldd	r24, Y+3	; 0x03
     924:	88 23       	and	r24, r24
     926:	19 f4       	brne	.+6      	; 0x92e <__stack+0xcf>
			{
				Counter++;
     928:	8b 81       	ldd	r24, Y+3	; 0x03
     92a:	8f 5f       	subi	r24, 0xFF	; 255
     92c:	8b 83       	std	Y+3, r24	; 0x03
			}

			Flag2 = 1;
     92e:	81 e0       	ldi	r24, 0x01	; 1
     930:	89 83       	std	Y+1, r24	; 0x01
			HelloTask_Data = 0;
     932:	1d 82       	std	Y+5, r1	; 0x05
		{
			/*Do Nothing*/
		}

		/*Reset counter to Display off Hello message for specific time*/
		if(Counter == 10)
     934:	8b 81       	ldd	r24, Y+3	; 0x03
     936:	8a 30       	cpi	r24, 0x0A	; 10
     938:	c1 f4       	brne	.+48     	; 0x96a <__stack+0x10b>
		{
			Counter = 0;
     93a:	1b 82       	std	Y+3, r1	; 0x03
			Flag2 = 0;
     93c:	19 82       	std	Y+1, r1	; 0x01
			if(Flag == 1)
     93e:	8a 81       	ldd	r24, Y+2	; 0x02
     940:	81 30       	cpi	r24, 0x01	; 1
     942:	89 f4       	brne	.+34     	; 0x966 <__stack+0x107>
			{
				LCD_displayStringRowColumn(0 , 0 ,Spaces);
     944:	9e 01       	movw	r18, r28
     946:	2c 5d       	subi	r18, 0xDC	; 220
     948:	3f 4f       	sbci	r19, 0xFF	; 255
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	60 e0       	ldi	r22, 0x00	; 0
     94e:	a9 01       	movw	r20, r18
     950:	0e 94 fd 09 	call	0x13fa	; 0x13fa <LCD_displayStringRowColumn>
				LCD_displayStringRowColumn(1 , 0 , ButtonPressedString);
     954:	9e 01       	movw	r18, r28
     956:	2a 5f       	subi	r18, 0xFA	; 250
     958:	3f 4f       	sbci	r19, 0xFF	; 255
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	60 e0       	ldi	r22, 0x00	; 0
     95e:	a9 01       	movw	r20, r18
     960:	0e 94 fd 09 	call	0x13fa	; 0x13fa <LCD_displayStringRowColumn>
     964:	02 c0       	rjmp	.+4      	; 0x96a <__stack+0x10b>
			}
			else
			{
				LCD_clearScreen();
     966:	0e 94 16 0a 	call	0x142c	; 0x142c <LCD_clearScreen>
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(20);
     96a:	84 e1       	ldi	r24, 0x14	; 20
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
     972:	84 cf       	rjmp	.-248    	; 0x87c <__stack+0x1d>

00000974 <SendHallo_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void SendHallo_Task(void * a_Task_ptr)
{
     974:	df 93       	push	r29
     976:	cf 93       	push	r28
     978:	00 d0       	rcall	.+0      	; 0x97a <SendHallo_Task+0x6>
     97a:	0f 92       	push	r0
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
     980:	9b 83       	std	Y+3, r25	; 0x03
     982:	8a 83       	std	Y+2, r24	; 0x02
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 2;
     984:	82 e0       	ldi	r24, 0x02	; 2
     986:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		xQueueSend(MessageQueue_Hello , &SendData , 10);
     988:	80 91 d8 00 	lds	r24, 0x00D8
     98c:	90 91 d9 00 	lds	r25, 0x00D9
     990:	9e 01       	movw	r18, r28
     992:	2f 5f       	subi	r18, 0xFF	; 255
     994:	3f 4f       	sbci	r19, 0xFF	; 255
     996:	b9 01       	movw	r22, r18
     998:	4a e0       	ldi	r20, 0x0A	; 10
     99a:	50 e0       	ldi	r21, 0x00	; 0
     99c:	20 e0       	ldi	r18, 0x00	; 0
     99e:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
		vTaskDelay(400);
     9a2:	80 e9       	ldi	r24, 0x90	; 144
     9a4:	91 e0       	ldi	r25, 0x01	; 1
     9a6:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
     9aa:	ee cf       	rjmp	.-36     	; 0x988 <SendHallo_Task+0x14>

000009ac <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     9ac:	df 93       	push	r29
     9ae:	cf 93       	push	r28
     9b0:	00 d0       	rcall	.+0      	; 0x9b2 <xEventGroupCreate+0x6>
     9b2:	cd b7       	in	r28, 0x3d	; 61
     9b4:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     9b6:	8b e0       	ldi	r24, 0x0B	; 11
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	0e 94 1b 08 	call	0x1036	; 0x1036 <pvPortMalloc>
     9be:	9a 83       	std	Y+2, r25	; 0x02
     9c0:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     9c2:	89 81       	ldd	r24, Y+1	; 0x01
     9c4:	9a 81       	ldd	r25, Y+2	; 0x02
     9c6:	00 97       	sbiw	r24, 0x00	; 0
     9c8:	49 f0       	breq	.+18     	; 0x9dc <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     9ca:	e9 81       	ldd	r30, Y+1	; 0x01
     9cc:	fa 81       	ldd	r31, Y+2	; 0x02
     9ce:	11 82       	std	Z+1, r1	; 0x01
     9d0:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     9d2:	89 81       	ldd	r24, Y+1	; 0x01
     9d4:	9a 81       	ldd	r25, Y+2	; 0x02
     9d6:	02 96       	adiw	r24, 0x02	; 2
     9d8:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     9dc:	89 81       	ldd	r24, Y+1	; 0x01
     9de:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     9e0:	0f 90       	pop	r0
     9e2:	0f 90       	pop	r0
     9e4:	cf 91       	pop	r28
     9e6:	df 91       	pop	r29
     9e8:	08 95       	ret

000009ea <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     9ea:	df 93       	push	r29
     9ec:	cf 93       	push	r28
     9ee:	cd b7       	in	r28, 0x3d	; 61
     9f0:	de b7       	in	r29, 0x3e	; 62
     9f2:	60 97       	sbiw	r28, 0x10	; 16
     9f4:	0f b6       	in	r0, 0x3f	; 63
     9f6:	f8 94       	cli
     9f8:	de bf       	out	0x3e, r29	; 62
     9fa:	0f be       	out	0x3f, r0	; 63
     9fc:	cd bf       	out	0x3d, r28	; 61
     9fe:	9a 87       	std	Y+10, r25	; 0x0a
     a00:	89 87       	std	Y+9, r24	; 0x09
     a02:	7c 87       	std	Y+12, r23	; 0x0c
     a04:	6b 87       	std	Y+11, r22	; 0x0b
     a06:	5e 87       	std	Y+14, r21	; 0x0e
     a08:	4d 87       	std	Y+13, r20	; 0x0d
     a0a:	38 8b       	std	Y+16, r19	; 0x10
     a0c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     a0e:	89 85       	ldd	r24, Y+9	; 0x09
     a10:	9a 85       	ldd	r25, Y+10	; 0x0a
     a12:	9c 83       	std	Y+4, r25	; 0x04
     a14:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     a16:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     a18:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     a1c:	eb 81       	ldd	r30, Y+3	; 0x03
     a1e:	fc 81       	ldd	r31, Y+4	; 0x04
     a20:	80 81       	ld	r24, Z
     a22:	91 81       	ldd	r25, Z+1	; 0x01
     a24:	98 87       	std	Y+8, r25	; 0x08
     a26:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     a28:	89 85       	ldd	r24, Y+9	; 0x09
     a2a:	9a 85       	ldd	r25, Y+10	; 0x0a
     a2c:	2b 85       	ldd	r18, Y+11	; 0x0b
     a2e:	3c 85       	ldd	r19, Y+12	; 0x0c
     a30:	b9 01       	movw	r22, r18
     a32:	0e 94 cc 06 	call	0xd98	; 0xd98 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     a36:	2f 81       	ldd	r18, Y+7	; 0x07
     a38:	38 85       	ldd	r19, Y+8	; 0x08
     a3a:	8b 85       	ldd	r24, Y+11	; 0x0b
     a3c:	9c 85       	ldd	r25, Y+12	; 0x0c
     a3e:	28 2b       	or	r18, r24
     a40:	39 2b       	or	r19, r25
     a42:	8d 85       	ldd	r24, Y+13	; 0x0d
     a44:	9e 85       	ldd	r25, Y+14	; 0x0e
     a46:	28 23       	and	r18, r24
     a48:	39 23       	and	r19, r25
     a4a:	8d 85       	ldd	r24, Y+13	; 0x0d
     a4c:	9e 85       	ldd	r25, Y+14	; 0x0e
     a4e:	28 17       	cp	r18, r24
     a50:	39 07       	cpc	r19, r25
     a52:	c9 f4       	brne	.+50     	; 0xa86 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     a54:	2f 81       	ldd	r18, Y+7	; 0x07
     a56:	38 85       	ldd	r19, Y+8	; 0x08
     a58:	8b 85       	ldd	r24, Y+11	; 0x0b
     a5a:	9c 85       	ldd	r25, Y+12	; 0x0c
     a5c:	82 2b       	or	r24, r18
     a5e:	93 2b       	or	r25, r19
     a60:	9e 83       	std	Y+6, r25	; 0x06
     a62:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a64:	eb 81       	ldd	r30, Y+3	; 0x03
     a66:	fc 81       	ldd	r31, Y+4	; 0x04
     a68:	20 81       	ld	r18, Z
     a6a:	31 81       	ldd	r19, Z+1	; 0x01
     a6c:	8d 85       	ldd	r24, Y+13	; 0x0d
     a6e:	9e 85       	ldd	r25, Y+14	; 0x0e
     a70:	80 95       	com	r24
     a72:	90 95       	com	r25
     a74:	82 23       	and	r24, r18
     a76:	93 23       	and	r25, r19
     a78:	eb 81       	ldd	r30, Y+3	; 0x03
     a7a:	fc 81       	ldd	r31, Y+4	; 0x04
     a7c:	91 83       	std	Z+1, r25	; 0x01
     a7e:	80 83       	st	Z, r24

			xTicksToWait = 0;
     a80:	18 8a       	std	Y+16, r1	; 0x10
     a82:	1f 86       	std	Y+15, r1	; 0x0f
     a84:	1e c0       	rjmp	.+60     	; 0xac2 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     a86:	8f 85       	ldd	r24, Y+15	; 0x0f
     a88:	98 89       	ldd	r25, Y+16	; 0x10
     a8a:	00 97       	sbiw	r24, 0x00	; 0
     a8c:	91 f0       	breq	.+36     	; 0xab2 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     a8e:	8b 81       	ldd	r24, Y+3	; 0x03
     a90:	9c 81       	ldd	r25, Y+4	; 0x04
     a92:	bc 01       	movw	r22, r24
     a94:	6e 5f       	subi	r22, 0xFE	; 254
     a96:	7f 4f       	sbci	r23, 0xFF	; 255
     a98:	8d 85       	ldd	r24, Y+13	; 0x0d
     a9a:	9e 85       	ldd	r25, Y+14	; 0x0e
     a9c:	9c 01       	movw	r18, r24
     a9e:	35 60       	ori	r19, 0x05	; 5
     aa0:	4f 85       	ldd	r20, Y+15	; 0x0f
     aa2:	58 89       	ldd	r21, Y+16	; 0x10
     aa4:	cb 01       	movw	r24, r22
     aa6:	b9 01       	movw	r22, r18
     aa8:	0e 94 54 23 	call	0x46a8	; 0x46a8 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     aac:	1e 82       	std	Y+6, r1	; 0x06
     aae:	1d 82       	std	Y+5, r1	; 0x05
     ab0:	08 c0       	rjmp	.+16     	; 0xac2 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     ab2:	eb 81       	ldd	r30, Y+3	; 0x03
     ab4:	fc 81       	ldd	r31, Y+4	; 0x04
     ab6:	80 81       	ld	r24, Z
     ab8:	91 81       	ldd	r25, Z+1	; 0x01
     aba:	9e 83       	std	Y+6, r25	; 0x06
     abc:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     abe:	81 e0       	ldi	r24, 0x01	; 1
     ac0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     ac2:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
     ac6:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     ac8:	8f 85       	ldd	r24, Y+15	; 0x0f
     aca:	98 89       	ldd	r25, Y+16	; 0x10
     acc:	00 97       	sbiw	r24, 0x00	; 0
     ace:	09 f4       	brne	.+2      	; 0xad2 <xEventGroupSync+0xe8>
     ad0:	3a c0       	rjmp	.+116    	; 0xb46 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     ad2:	8a 81       	ldd	r24, Y+2	; 0x02
     ad4:	88 23       	and	r24, r24
     ad6:	11 f4       	brne	.+4      	; 0xadc <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     ad8:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     adc:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <uxTaskResetEventItemValue>
     ae0:	9e 83       	std	Y+6, r25	; 0x06
     ae2:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     ae4:	8d 81       	ldd	r24, Y+5	; 0x05
     ae6:	9e 81       	ldd	r25, Y+6	; 0x06
     ae8:	80 70       	andi	r24, 0x00	; 0
     aea:	92 70       	andi	r25, 0x02	; 2
     aec:	00 97       	sbiw	r24, 0x00	; 0
     aee:	31 f5       	brne	.+76     	; 0xb3c <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     af0:	0f b6       	in	r0, 0x3f	; 63
     af2:	f8 94       	cli
     af4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     af6:	eb 81       	ldd	r30, Y+3	; 0x03
     af8:	fc 81       	ldd	r31, Y+4	; 0x04
     afa:	80 81       	ld	r24, Z
     afc:	91 81       	ldd	r25, Z+1	; 0x01
     afe:	9e 83       	std	Y+6, r25	; 0x06
     b00:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     b02:	2d 81       	ldd	r18, Y+5	; 0x05
     b04:	3e 81       	ldd	r19, Y+6	; 0x06
     b06:	8d 85       	ldd	r24, Y+13	; 0x0d
     b08:	9e 85       	ldd	r25, Y+14	; 0x0e
     b0a:	28 23       	and	r18, r24
     b0c:	39 23       	and	r19, r25
     b0e:	8d 85       	ldd	r24, Y+13	; 0x0d
     b10:	9e 85       	ldd	r25, Y+14	; 0x0e
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	71 f4       	brne	.+28     	; 0xb34 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b18:	eb 81       	ldd	r30, Y+3	; 0x03
     b1a:	fc 81       	ldd	r31, Y+4	; 0x04
     b1c:	20 81       	ld	r18, Z
     b1e:	31 81       	ldd	r19, Z+1	; 0x01
     b20:	8d 85       	ldd	r24, Y+13	; 0x0d
     b22:	9e 85       	ldd	r25, Y+14	; 0x0e
     b24:	80 95       	com	r24
     b26:	90 95       	com	r25
     b28:	82 23       	and	r24, r18
     b2a:	93 23       	and	r25, r19
     b2c:	eb 81       	ldd	r30, Y+3	; 0x03
     b2e:	fc 81       	ldd	r31, Y+4	; 0x04
     b30:	91 83       	std	Z+1, r25	; 0x01
     b32:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     b34:	0f 90       	pop	r0
     b36:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     b38:	81 e0       	ldi	r24, 0x01	; 1
     b3a:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     b3c:	8d 81       	ldd	r24, Y+5	; 0x05
     b3e:	9e 81       	ldd	r25, Y+6	; 0x06
     b40:	90 70       	andi	r25, 0x00	; 0
     b42:	9e 83       	std	Y+6, r25	; 0x06
     b44:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     b46:	8d 81       	ldd	r24, Y+5	; 0x05
     b48:	9e 81       	ldd	r25, Y+6	; 0x06
}
     b4a:	60 96       	adiw	r28, 0x10	; 16
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	f8 94       	cli
     b50:	de bf       	out	0x3e, r29	; 62
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	cd bf       	out	0x3d, r28	; 61
     b56:	cf 91       	pop	r28
     b58:	df 91       	pop	r29
     b5a:	08 95       	ret

00000b5c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	df 93       	push	r29
     b62:	cf 93       	push	r28
     b64:	cd b7       	in	r28, 0x3d	; 61
     b66:	de b7       	in	r29, 0x3e	; 62
     b68:	63 97       	sbiw	r28, 0x13	; 19
     b6a:	0f b6       	in	r0, 0x3f	; 63
     b6c:	f8 94       	cli
     b6e:	de bf       	out	0x3e, r29	; 62
     b70:	0f be       	out	0x3f, r0	; 63
     b72:	cd bf       	out	0x3d, r28	; 61
     b74:	9d 87       	std	Y+13, r25	; 0x0d
     b76:	8c 87       	std	Y+12, r24	; 0x0c
     b78:	7f 87       	std	Y+15, r23	; 0x0f
     b7a:	6e 87       	std	Y+14, r22	; 0x0e
     b7c:	48 8b       	std	Y+16, r20	; 0x10
     b7e:	29 8b       	std	Y+17, r18	; 0x11
     b80:	1b 8b       	std	Y+19, r17	; 0x13
     b82:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     b84:	8c 85       	ldd	r24, Y+12	; 0x0c
     b86:	9d 85       	ldd	r25, Y+13	; 0x0d
     b88:	9b 87       	std	Y+11, r25	; 0x0b
     b8a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     b8c:	1f 82       	std	Y+7, r1	; 0x07
     b8e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     b90:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     b92:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     b96:	ea 85       	ldd	r30, Y+10	; 0x0a
     b98:	fb 85       	ldd	r31, Y+11	; 0x0b
     b9a:	80 81       	ld	r24, Z
     b9c:	91 81       	ldd	r25, Z+1	; 0x01
     b9e:	9a 83       	std	Y+2, r25	; 0x02
     ba0:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     ba2:	89 81       	ldd	r24, Y+1	; 0x01
     ba4:	9a 81       	ldd	r25, Y+2	; 0x02
     ba6:	2e 85       	ldd	r18, Y+14	; 0x0e
     ba8:	3f 85       	ldd	r19, Y+15	; 0x0f
     baa:	b9 01       	movw	r22, r18
     bac:	49 89       	ldd	r20, Y+17	; 0x11
     bae:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <prvTestWaitCondition>
     bb2:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     bb4:	8d 81       	ldd	r24, Y+5	; 0x05
     bb6:	88 23       	and	r24, r24
     bb8:	c1 f0       	breq	.+48     	; 0xbea <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     bba:	89 81       	ldd	r24, Y+1	; 0x01
     bbc:	9a 81       	ldd	r25, Y+2	; 0x02
     bbe:	99 87       	std	Y+9, r25	; 0x09
     bc0:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     bc2:	1b 8a       	std	Y+19, r1	; 0x13
     bc4:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     bc6:	88 89       	ldd	r24, Y+16	; 0x10
     bc8:	88 23       	and	r24, r24
     bca:	e9 f1       	breq	.+122    	; 0xc46 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     bcc:	ea 85       	ldd	r30, Y+10	; 0x0a
     bce:	fb 85       	ldd	r31, Y+11	; 0x0b
     bd0:	20 81       	ld	r18, Z
     bd2:	31 81       	ldd	r19, Z+1	; 0x01
     bd4:	8e 85       	ldd	r24, Y+14	; 0x0e
     bd6:	9f 85       	ldd	r25, Y+15	; 0x0f
     bd8:	80 95       	com	r24
     bda:	90 95       	com	r25
     bdc:	82 23       	and	r24, r18
     bde:	93 23       	and	r25, r19
     be0:	ea 85       	ldd	r30, Y+10	; 0x0a
     be2:	fb 85       	ldd	r31, Y+11	; 0x0b
     be4:	91 83       	std	Z+1, r25	; 0x01
     be6:	80 83       	st	Z, r24
     be8:	2e c0       	rjmp	.+92     	; 0xc46 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     bea:	8a 89       	ldd	r24, Y+18	; 0x12
     bec:	9b 89       	ldd	r25, Y+19	; 0x13
     bee:	00 97       	sbiw	r24, 0x00	; 0
     bf0:	39 f4       	brne	.+14     	; 0xc00 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     bf2:	89 81       	ldd	r24, Y+1	; 0x01
     bf4:	9a 81       	ldd	r25, Y+2	; 0x02
     bf6:	99 87       	std	Y+9, r25	; 0x09
     bf8:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     bfa:	81 e0       	ldi	r24, 0x01	; 1
     bfc:	8b 83       	std	Y+3, r24	; 0x03
     bfe:	23 c0       	rjmp	.+70     	; 0xc46 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     c00:	88 89       	ldd	r24, Y+16	; 0x10
     c02:	88 23       	and	r24, r24
     c04:	29 f0       	breq	.+10     	; 0xc10 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     c06:	8e 81       	ldd	r24, Y+6	; 0x06
     c08:	9f 81       	ldd	r25, Y+7	; 0x07
     c0a:	91 60       	ori	r25, 0x01	; 1
     c0c:	9f 83       	std	Y+7, r25	; 0x07
     c0e:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     c10:	89 89       	ldd	r24, Y+17	; 0x11
     c12:	88 23       	and	r24, r24
     c14:	29 f0       	breq	.+10     	; 0xc20 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     c16:	8e 81       	ldd	r24, Y+6	; 0x06
     c18:	9f 81       	ldd	r25, Y+7	; 0x07
     c1a:	94 60       	ori	r25, 0x04	; 4
     c1c:	9f 83       	std	Y+7, r25	; 0x07
     c1e:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     c20:	8a 85       	ldd	r24, Y+10	; 0x0a
     c22:	9b 85       	ldd	r25, Y+11	; 0x0b
     c24:	bc 01       	movw	r22, r24
     c26:	6e 5f       	subi	r22, 0xFE	; 254
     c28:	7f 4f       	sbci	r23, 0xFF	; 255
     c2a:	2e 85       	ldd	r18, Y+14	; 0x0e
     c2c:	3f 85       	ldd	r19, Y+15	; 0x0f
     c2e:	8e 81       	ldd	r24, Y+6	; 0x06
     c30:	9f 81       	ldd	r25, Y+7	; 0x07
     c32:	28 2b       	or	r18, r24
     c34:	39 2b       	or	r19, r25
     c36:	4a 89       	ldd	r20, Y+18	; 0x12
     c38:	5b 89       	ldd	r21, Y+19	; 0x13
     c3a:	cb 01       	movw	r24, r22
     c3c:	b9 01       	movw	r22, r18
     c3e:	0e 94 54 23 	call	0x46a8	; 0x46a8 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     c42:	19 86       	std	Y+9, r1	; 0x09
     c44:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     c46:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
     c4a:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     c4c:	8a 89       	ldd	r24, Y+18	; 0x12
     c4e:	9b 89       	ldd	r25, Y+19	; 0x13
     c50:	00 97       	sbiw	r24, 0x00	; 0
     c52:	09 f4       	brne	.+2      	; 0xc56 <xEventGroupWaitBits+0xfa>
     c54:	3c c0       	rjmp	.+120    	; 0xcce <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     c56:	8c 81       	ldd	r24, Y+4	; 0x04
     c58:	88 23       	and	r24, r24
     c5a:	11 f4       	brne	.+4      	; 0xc60 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     c5c:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     c60:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <uxTaskResetEventItemValue>
     c64:	99 87       	std	Y+9, r25	; 0x09
     c66:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     c68:	88 85       	ldd	r24, Y+8	; 0x08
     c6a:	99 85       	ldd	r25, Y+9	; 0x09
     c6c:	80 70       	andi	r24, 0x00	; 0
     c6e:	92 70       	andi	r25, 0x02	; 2
     c70:	00 97       	sbiw	r24, 0x00	; 0
     c72:	41 f5       	brne	.+80     	; 0xcc4 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     c74:	0f b6       	in	r0, 0x3f	; 63
     c76:	f8 94       	cli
     c78:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     c7a:	ea 85       	ldd	r30, Y+10	; 0x0a
     c7c:	fb 85       	ldd	r31, Y+11	; 0x0b
     c7e:	80 81       	ld	r24, Z
     c80:	91 81       	ldd	r25, Z+1	; 0x01
     c82:	99 87       	std	Y+9, r25	; 0x09
     c84:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     c86:	88 85       	ldd	r24, Y+8	; 0x08
     c88:	99 85       	ldd	r25, Y+9	; 0x09
     c8a:	2e 85       	ldd	r18, Y+14	; 0x0e
     c8c:	3f 85       	ldd	r19, Y+15	; 0x0f
     c8e:	b9 01       	movw	r22, r18
     c90:	49 89       	ldd	r20, Y+17	; 0x11
     c92:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <prvTestWaitCondition>
     c96:	88 23       	and	r24, r24
     c98:	89 f0       	breq	.+34     	; 0xcbc <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     c9a:	88 89       	ldd	r24, Y+16	; 0x10
     c9c:	88 23       	and	r24, r24
     c9e:	71 f0       	breq	.+28     	; 0xcbc <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ca0:	ea 85       	ldd	r30, Y+10	; 0x0a
     ca2:	fb 85       	ldd	r31, Y+11	; 0x0b
     ca4:	20 81       	ld	r18, Z
     ca6:	31 81       	ldd	r19, Z+1	; 0x01
     ca8:	8e 85       	ldd	r24, Y+14	; 0x0e
     caa:	9f 85       	ldd	r25, Y+15	; 0x0f
     cac:	80 95       	com	r24
     cae:	90 95       	com	r25
     cb0:	82 23       	and	r24, r18
     cb2:	93 23       	and	r25, r19
     cb4:	ea 85       	ldd	r30, Y+10	; 0x0a
     cb6:	fb 85       	ldd	r31, Y+11	; 0x0b
     cb8:	91 83       	std	Z+1, r25	; 0x01
     cba:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     cbc:	81 e0       	ldi	r24, 0x01	; 1
     cbe:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     cc0:	0f 90       	pop	r0
     cc2:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     cc4:	88 85       	ldd	r24, Y+8	; 0x08
     cc6:	99 85       	ldd	r25, Y+9	; 0x09
     cc8:	90 70       	andi	r25, 0x00	; 0
     cca:	99 87       	std	Y+9, r25	; 0x09
     ccc:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     cce:	88 85       	ldd	r24, Y+8	; 0x08
     cd0:	99 85       	ldd	r25, Y+9	; 0x09
}
     cd2:	63 96       	adiw	r28, 0x13	; 19
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	cf 91       	pop	r28
     ce0:	df 91       	pop	r29
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	08 95       	ret

00000ce8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     ce8:	df 93       	push	r29
     cea:	cf 93       	push	r28
     cec:	cd b7       	in	r28, 0x3d	; 61
     cee:	de b7       	in	r29, 0x3e	; 62
     cf0:	28 97       	sbiw	r28, 0x08	; 8
     cf2:	0f b6       	in	r0, 0x3f	; 63
     cf4:	f8 94       	cli
     cf6:	de bf       	out	0x3e, r29	; 62
     cf8:	0f be       	out	0x3f, r0	; 63
     cfa:	cd bf       	out	0x3d, r28	; 61
     cfc:	9e 83       	std	Y+6, r25	; 0x06
     cfe:	8d 83       	std	Y+5, r24	; 0x05
     d00:	78 87       	std	Y+8, r23	; 0x08
     d02:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     d04:	8d 81       	ldd	r24, Y+5	; 0x05
     d06:	9e 81       	ldd	r25, Y+6	; 0x06
     d08:	9c 83       	std	Y+4, r25	; 0x04
     d0a:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     d0c:	0f b6       	in	r0, 0x3f	; 63
     d0e:	f8 94       	cli
     d10:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     d12:	eb 81       	ldd	r30, Y+3	; 0x03
     d14:	fc 81       	ldd	r31, Y+4	; 0x04
     d16:	80 81       	ld	r24, Z
     d18:	91 81       	ldd	r25, Z+1	; 0x01
     d1a:	9a 83       	std	Y+2, r25	; 0x02
     d1c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     d1e:	eb 81       	ldd	r30, Y+3	; 0x03
     d20:	fc 81       	ldd	r31, Y+4	; 0x04
     d22:	20 81       	ld	r18, Z
     d24:	31 81       	ldd	r19, Z+1	; 0x01
     d26:	8f 81       	ldd	r24, Y+7	; 0x07
     d28:	98 85       	ldd	r25, Y+8	; 0x08
     d2a:	80 95       	com	r24
     d2c:	90 95       	com	r25
     d2e:	82 23       	and	r24, r18
     d30:	93 23       	and	r25, r19
     d32:	eb 81       	ldd	r30, Y+3	; 0x03
     d34:	fc 81       	ldd	r31, Y+4	; 0x04
     d36:	91 83       	std	Z+1, r25	; 0x01
     d38:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     d3a:	0f 90       	pop	r0
     d3c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     d3e:	89 81       	ldd	r24, Y+1	; 0x01
     d40:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d42:	28 96       	adiw	r28, 0x08	; 8
     d44:	0f b6       	in	r0, 0x3f	; 63
     d46:	f8 94       	cli
     d48:	de bf       	out	0x3e, r29	; 62
     d4a:	0f be       	out	0x3f, r0	; 63
     d4c:	cd bf       	out	0x3d, r28	; 61
     d4e:	cf 91       	pop	r28
     d50:	df 91       	pop	r29
     d52:	08 95       	ret

00000d54 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     d54:	df 93       	push	r29
     d56:	cf 93       	push	r28
     d58:	cd b7       	in	r28, 0x3d	; 61
     d5a:	de b7       	in	r29, 0x3e	; 62
     d5c:	27 97       	sbiw	r28, 0x07	; 7
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	de bf       	out	0x3e, r29	; 62
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	cd bf       	out	0x3d, r28	; 61
     d68:	9f 83       	std	Y+7, r25	; 0x07
     d6a:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     d6c:	8e 81       	ldd	r24, Y+6	; 0x06
     d6e:	9f 81       	ldd	r25, Y+7	; 0x07
     d70:	9c 83       	std	Y+4, r25	; 0x04
     d72:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     d74:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     d76:	eb 81       	ldd	r30, Y+3	; 0x03
     d78:	fc 81       	ldd	r31, Y+4	; 0x04
     d7a:	80 81       	ld	r24, Z
     d7c:	91 81       	ldd	r25, Z+1	; 0x01
     d7e:	9a 83       	std	Y+2, r25	; 0x02
     d80:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     d86:	27 96       	adiw	r28, 0x07	; 7
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	cf 91       	pop	r28
     d94:	df 91       	pop	r29
     d96:	08 95       	ret

00000d98 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     d98:	df 93       	push	r29
     d9a:	cf 93       	push	r28
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	65 97       	sbiw	r28, 0x15	; 21
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	f8 94       	cli
     da6:	de bf       	out	0x3e, r29	; 62
     da8:	0f be       	out	0x3f, r0	; 63
     daa:	cd bf       	out	0x3d, r28	; 61
     dac:	9b 8b       	std	Y+19, r25	; 0x13
     dae:	8a 8b       	std	Y+18, r24	; 0x12
     db0:	7d 8b       	std	Y+21, r23	; 0x15
     db2:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     db4:	19 86       	std	Y+9, r1	; 0x09
     db6:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     db8:	8a 89       	ldd	r24, Y+18	; 0x12
     dba:	9b 89       	ldd	r25, Y+19	; 0x13
     dbc:	9b 83       	std	Y+3, r25	; 0x03
     dbe:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     dc0:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     dc2:	8a 81       	ldd	r24, Y+2	; 0x02
     dc4:	9b 81       	ldd	r25, Y+3	; 0x03
     dc6:	02 96       	adiw	r24, 0x02	; 2
     dc8:	9b 87       	std	Y+11, r25	; 0x0b
     dca:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dcc:	8a 85       	ldd	r24, Y+10	; 0x0a
     dce:	9b 85       	ldd	r25, Y+11	; 0x0b
     dd0:	03 96       	adiw	r24, 0x03	; 3
     dd2:	9d 87       	std	Y+13, r25	; 0x0d
     dd4:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     dd6:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     dda:	ea 85       	ldd	r30, Y+10	; 0x0a
     ddc:	fb 85       	ldd	r31, Y+11	; 0x0b
     dde:	85 81       	ldd	r24, Z+5	; 0x05
     de0:	96 81       	ldd	r25, Z+6	; 0x06
     de2:	99 8b       	std	Y+17, r25	; 0x11
     de4:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     de6:	ea 81       	ldd	r30, Y+2	; 0x02
     de8:	fb 81       	ldd	r31, Y+3	; 0x03
     dea:	20 81       	ld	r18, Z
     dec:	31 81       	ldd	r19, Z+1	; 0x01
     dee:	8c 89       	ldd	r24, Y+20	; 0x14
     df0:	9d 89       	ldd	r25, Y+21	; 0x15
     df2:	82 2b       	or	r24, r18
     df4:	93 2b       	or	r25, r19
     df6:	ea 81       	ldd	r30, Y+2	; 0x02
     df8:	fb 81       	ldd	r31, Y+3	; 0x03
     dfa:	91 83       	std	Z+1, r25	; 0x01
     dfc:	80 83       	st	Z, r24
     dfe:	59 c0       	rjmp	.+178    	; 0xeb2 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     e00:	e8 89       	ldd	r30, Y+16	; 0x10
     e02:	f9 89       	ldd	r31, Y+17	; 0x11
     e04:	82 81       	ldd	r24, Z+2	; 0x02
     e06:	93 81       	ldd	r25, Z+3	; 0x03
     e08:	9f 87       	std	Y+15, r25	; 0x0f
     e0a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     e0c:	e8 89       	ldd	r30, Y+16	; 0x10
     e0e:	f9 89       	ldd	r31, Y+17	; 0x11
     e10:	80 81       	ld	r24, Z
     e12:	91 81       	ldd	r25, Z+1	; 0x01
     e14:	9f 83       	std	Y+7, r25	; 0x07
     e16:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     e18:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     e1a:	8e 81       	ldd	r24, Y+6	; 0x06
     e1c:	9f 81       	ldd	r25, Y+7	; 0x07
     e1e:	80 70       	andi	r24, 0x00	; 0
     e20:	9d 83       	std	Y+5, r25	; 0x05
     e22:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     e24:	8e 81       	ldd	r24, Y+6	; 0x06
     e26:	9f 81       	ldd	r25, Y+7	; 0x07
     e28:	90 70       	andi	r25, 0x00	; 0
     e2a:	9f 83       	std	Y+7, r25	; 0x07
     e2c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     e2e:	8c 81       	ldd	r24, Y+4	; 0x04
     e30:	9d 81       	ldd	r25, Y+5	; 0x05
     e32:	80 70       	andi	r24, 0x00	; 0
     e34:	94 70       	andi	r25, 0x04	; 4
     e36:	00 97       	sbiw	r24, 0x00	; 0
     e38:	69 f4       	brne	.+26     	; 0xe54 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     e3a:	ea 81       	ldd	r30, Y+2	; 0x02
     e3c:	fb 81       	ldd	r31, Y+3	; 0x03
     e3e:	20 81       	ld	r18, Z
     e40:	31 81       	ldd	r19, Z+1	; 0x01
     e42:	8e 81       	ldd	r24, Y+6	; 0x06
     e44:	9f 81       	ldd	r25, Y+7	; 0x07
     e46:	82 23       	and	r24, r18
     e48:	93 23       	and	r25, r19
     e4a:	00 97       	sbiw	r24, 0x00	; 0
     e4c:	91 f0       	breq	.+36     	; 0xe72 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     e4e:	81 e0       	ldi	r24, 0x01	; 1
     e50:	89 83       	std	Y+1, r24	; 0x01
     e52:	0f c0       	rjmp	.+30     	; 0xe72 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     e54:	ea 81       	ldd	r30, Y+2	; 0x02
     e56:	fb 81       	ldd	r31, Y+3	; 0x03
     e58:	20 81       	ld	r18, Z
     e5a:	31 81       	ldd	r19, Z+1	; 0x01
     e5c:	8e 81       	ldd	r24, Y+6	; 0x06
     e5e:	9f 81       	ldd	r25, Y+7	; 0x07
     e60:	28 23       	and	r18, r24
     e62:	39 23       	and	r19, r25
     e64:	8e 81       	ldd	r24, Y+6	; 0x06
     e66:	9f 81       	ldd	r25, Y+7	; 0x07
     e68:	28 17       	cp	r18, r24
     e6a:	39 07       	cpc	r19, r25
     e6c:	11 f4       	brne	.+4      	; 0xe72 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     e6e:	81 e0       	ldi	r24, 0x01	; 1
     e70:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     e72:	89 81       	ldd	r24, Y+1	; 0x01
     e74:	88 23       	and	r24, r24
     e76:	c9 f0       	breq	.+50     	; 0xeaa <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     e78:	8c 81       	ldd	r24, Y+4	; 0x04
     e7a:	9d 81       	ldd	r25, Y+5	; 0x05
     e7c:	80 70       	andi	r24, 0x00	; 0
     e7e:	91 70       	andi	r25, 0x01	; 1
     e80:	00 97       	sbiw	r24, 0x00	; 0
     e82:	41 f0       	breq	.+16     	; 0xe94 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     e84:	88 85       	ldd	r24, Y+8	; 0x08
     e86:	99 85       	ldd	r25, Y+9	; 0x09
     e88:	2e 81       	ldd	r18, Y+6	; 0x06
     e8a:	3f 81       	ldd	r19, Y+7	; 0x07
     e8c:	82 2b       	or	r24, r18
     e8e:	93 2b       	or	r25, r19
     e90:	99 87       	std	Y+9, r25	; 0x09
     e92:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     e94:	ea 81       	ldd	r30, Y+2	; 0x02
     e96:	fb 81       	ldd	r31, Y+3	; 0x03
     e98:	80 81       	ld	r24, Z
     e9a:	91 81       	ldd	r25, Z+1	; 0x01
     e9c:	9c 01       	movw	r18, r24
     e9e:	32 60       	ori	r19, 0x02	; 2
     ea0:	88 89       	ldd	r24, Y+16	; 0x10
     ea2:	99 89       	ldd	r25, Y+17	; 0x11
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 ef 23 	call	0x47de	; 0x47de <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     eaa:	8e 85       	ldd	r24, Y+14	; 0x0e
     eac:	9f 85       	ldd	r25, Y+15	; 0x0f
     eae:	99 8b       	std	Y+17, r25	; 0x11
     eb0:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     eb2:	28 89       	ldd	r18, Y+16	; 0x10
     eb4:	39 89       	ldd	r19, Y+17	; 0x11
     eb6:	8c 85       	ldd	r24, Y+12	; 0x0c
     eb8:	9d 85       	ldd	r25, Y+13	; 0x0d
     eba:	28 17       	cp	r18, r24
     ebc:	39 07       	cpc	r19, r25
     ebe:	09 f0       	breq	.+2      	; 0xec2 <xEventGroupSetBits+0x12a>
     ec0:	9f cf       	rjmp	.-194    	; 0xe00 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     ec2:	ea 81       	ldd	r30, Y+2	; 0x02
     ec4:	fb 81       	ldd	r31, Y+3	; 0x03
     ec6:	20 81       	ld	r18, Z
     ec8:	31 81       	ldd	r19, Z+1	; 0x01
     eca:	88 85       	ldd	r24, Y+8	; 0x08
     ecc:	99 85       	ldd	r25, Y+9	; 0x09
     ece:	80 95       	com	r24
     ed0:	90 95       	com	r25
     ed2:	82 23       	and	r24, r18
     ed4:	93 23       	and	r25, r19
     ed6:	ea 81       	ldd	r30, Y+2	; 0x02
     ed8:	fb 81       	ldd	r31, Y+3	; 0x03
     eda:	91 83       	std	Z+1, r25	; 0x01
     edc:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     ede:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     ee2:	ea 81       	ldd	r30, Y+2	; 0x02
     ee4:	fb 81       	ldd	r31, Y+3	; 0x03
     ee6:	80 81       	ld	r24, Z
     ee8:	91 81       	ldd	r25, Z+1	; 0x01
}
     eea:	65 96       	adiw	r28, 0x15	; 21
     eec:	0f b6       	in	r0, 0x3f	; 63
     eee:	f8 94       	cli
     ef0:	de bf       	out	0x3e, r29	; 62
     ef2:	0f be       	out	0x3f, r0	; 63
     ef4:	cd bf       	out	0x3d, r28	; 61
     ef6:	cf 91       	pop	r28
     ef8:	df 91       	pop	r29
     efa:	08 95       	ret

00000efc <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     efc:	df 93       	push	r29
     efe:	cf 93       	push	r28
     f00:	00 d0       	rcall	.+0      	; 0xf02 <vEventGroupDelete+0x6>
     f02:	00 d0       	rcall	.+0      	; 0xf04 <vEventGroupDelete+0x8>
     f04:	00 d0       	rcall	.+0      	; 0xf06 <vEventGroupDelete+0xa>
     f06:	cd b7       	in	r28, 0x3d	; 61
     f08:	de b7       	in	r29, 0x3e	; 62
     f0a:	9e 83       	std	Y+6, r25	; 0x06
     f0c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     f0e:	8d 81       	ldd	r24, Y+5	; 0x05
     f10:	9e 81       	ldd	r25, Y+6	; 0x06
     f12:	9c 83       	std	Y+4, r25	; 0x04
     f14:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     f16:	8b 81       	ldd	r24, Y+3	; 0x03
     f18:	9c 81       	ldd	r25, Y+4	; 0x04
     f1a:	02 96       	adiw	r24, 0x02	; 2
     f1c:	9a 83       	std	Y+2, r25	; 0x02
     f1e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     f20:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
     f24:	08 c0       	rjmp	.+16     	; 0xf36 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     f26:	e9 81       	ldd	r30, Y+1	; 0x01
     f28:	fa 81       	ldd	r31, Y+2	; 0x02
     f2a:	85 81       	ldd	r24, Z+5	; 0x05
     f2c:	96 81       	ldd	r25, Z+6	; 0x06
     f2e:	60 e0       	ldi	r22, 0x00	; 0
     f30:	72 e0       	ldi	r23, 0x02	; 2
     f32:	0e 94 ef 23 	call	0x47de	; 0x47de <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     f36:	e9 81       	ldd	r30, Y+1	; 0x01
     f38:	fa 81       	ldd	r31, Y+2	; 0x02
     f3a:	80 81       	ld	r24, Z
     f3c:	88 23       	and	r24, r24
     f3e:	99 f7       	brne	.-26     	; 0xf26 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     f40:	8b 81       	ldd	r24, Y+3	; 0x03
     f42:	9c 81       	ldd	r25, Y+4	; 0x04
     f44:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     f48:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
}
     f4c:	26 96       	adiw	r28, 0x06	; 6
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	f8 94       	cli
     f52:	de bf       	out	0x3e, r29	; 62
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	cd bf       	out	0x3d, r28	; 61
     f58:	cf 91       	pop	r28
     f5a:	df 91       	pop	r29
     f5c:	08 95       	ret

00000f5e <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     f5e:	df 93       	push	r29
     f60:	cf 93       	push	r28
     f62:	00 d0       	rcall	.+0      	; 0xf64 <vEventGroupSetBitsCallback+0x6>
     f64:	00 d0       	rcall	.+0      	; 0xf66 <vEventGroupSetBitsCallback+0x8>
     f66:	00 d0       	rcall	.+0      	; 0xf68 <vEventGroupSetBitsCallback+0xa>
     f68:	cd b7       	in	r28, 0x3d	; 61
     f6a:	de b7       	in	r29, 0x3e	; 62
     f6c:	9a 83       	std	Y+2, r25	; 0x02
     f6e:	89 83       	std	Y+1, r24	; 0x01
     f70:	4b 83       	std	Y+3, r20	; 0x03
     f72:	5c 83       	std	Y+4, r21	; 0x04
     f74:	6d 83       	std	Y+5, r22	; 0x05
     f76:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     f78:	89 81       	ldd	r24, Y+1	; 0x01
     f7a:	9a 81       	ldd	r25, Y+2	; 0x02
     f7c:	2b 81       	ldd	r18, Y+3	; 0x03
     f7e:	3c 81       	ldd	r19, Y+4	; 0x04
     f80:	b9 01       	movw	r22, r18
     f82:	0e 94 cc 06 	call	0xd98	; 0xd98 <xEventGroupSetBits>
}
     f86:	26 96       	adiw	r28, 0x06	; 6
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	de bf       	out	0x3e, r29	; 62
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	cd bf       	out	0x3d, r28	; 61
     f92:	cf 91       	pop	r28
     f94:	df 91       	pop	r29
     f96:	08 95       	ret

00000f98 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <vEventGroupClearBitsCallback+0x6>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <vEventGroupClearBitsCallback+0x8>
     fa0:	00 d0       	rcall	.+0      	; 0xfa2 <vEventGroupClearBitsCallback+0xa>
     fa2:	cd b7       	in	r28, 0x3d	; 61
     fa4:	de b7       	in	r29, 0x3e	; 62
     fa6:	9a 83       	std	Y+2, r25	; 0x02
     fa8:	89 83       	std	Y+1, r24	; 0x01
     faa:	4b 83       	std	Y+3, r20	; 0x03
     fac:	5c 83       	std	Y+4, r21	; 0x04
     fae:	6d 83       	std	Y+5, r22	; 0x05
     fb0:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     fb2:	89 81       	ldd	r24, Y+1	; 0x01
     fb4:	9a 81       	ldd	r25, Y+2	; 0x02
     fb6:	2b 81       	ldd	r18, Y+3	; 0x03
     fb8:	3c 81       	ldd	r19, Y+4	; 0x04
     fba:	b9 01       	movw	r22, r18
     fbc:	0e 94 74 06 	call	0xce8	; 0xce8 <xEventGroupClearBits>
}
     fc0:	26 96       	adiw	r28, 0x06	; 6
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	cf 91       	pop	r28
     fce:	df 91       	pop	r29
     fd0:	08 95       	ret

00000fd2 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     fd2:	df 93       	push	r29
     fd4:	cf 93       	push	r28
     fd6:	00 d0       	rcall	.+0      	; 0xfd8 <prvTestWaitCondition+0x6>
     fd8:	00 d0       	rcall	.+0      	; 0xfda <prvTestWaitCondition+0x8>
     fda:	00 d0       	rcall	.+0      	; 0xfdc <prvTestWaitCondition+0xa>
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
     fe0:	9b 83       	std	Y+3, r25	; 0x03
     fe2:	8a 83       	std	Y+2, r24	; 0x02
     fe4:	7d 83       	std	Y+5, r23	; 0x05
     fe6:	6c 83       	std	Y+4, r22	; 0x04
     fe8:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     fea:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     fec:	8e 81       	ldd	r24, Y+6	; 0x06
     fee:	88 23       	and	r24, r24
     ff0:	59 f4       	brne	.+22     	; 0x1008 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     ff2:	8a 81       	ldd	r24, Y+2	; 0x02
     ff4:	9b 81       	ldd	r25, Y+3	; 0x03
     ff6:	2c 81       	ldd	r18, Y+4	; 0x04
     ff8:	3d 81       	ldd	r19, Y+5	; 0x05
     ffa:	82 23       	and	r24, r18
     ffc:	93 23       	and	r25, r19
     ffe:	00 97       	sbiw	r24, 0x00	; 0
    1000:	81 f0       	breq	.+32     	; 0x1022 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	89 83       	std	Y+1, r24	; 0x01
    1006:	0d c0       	rjmp	.+26     	; 0x1022 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1008:	2a 81       	ldd	r18, Y+2	; 0x02
    100a:	3b 81       	ldd	r19, Y+3	; 0x03
    100c:	8c 81       	ldd	r24, Y+4	; 0x04
    100e:	9d 81       	ldd	r25, Y+5	; 0x05
    1010:	28 23       	and	r18, r24
    1012:	39 23       	and	r19, r25
    1014:	8c 81       	ldd	r24, Y+4	; 0x04
    1016:	9d 81       	ldd	r25, Y+5	; 0x05
    1018:	28 17       	cp	r18, r24
    101a:	39 07       	cpc	r19, r25
    101c:	11 f4       	brne	.+4      	; 0x1022 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1022:	89 81       	ldd	r24, Y+1	; 0x01
}
    1024:	26 96       	adiw	r28, 0x06	; 6
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	f8 94       	cli
    102a:	de bf       	out	0x3e, r29	; 62
    102c:	0f be       	out	0x3f, r0	; 63
    102e:	cd bf       	out	0x3d, r28	; 61
    1030:	cf 91       	pop	r28
    1032:	df 91       	pop	r29
    1034:	08 95       	ret

00001036 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1036:	df 93       	push	r29
    1038:	cf 93       	push	r28
    103a:	00 d0       	rcall	.+0      	; 0x103c <pvPortMalloc+0x6>
    103c:	00 d0       	rcall	.+0      	; 0x103e <pvPortMalloc+0x8>
    103e:	cd b7       	in	r28, 0x3d	; 61
    1040:	de b7       	in	r29, 0x3e	; 62
    1042:	9c 83       	std	Y+4, r25	; 0x04
    1044:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1046:	1a 82       	std	Y+2, r1	; 0x02
    1048:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    104a:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    104e:	80 91 dc 00 	lds	r24, 0x00DC
    1052:	90 91 dd 00 	lds	r25, 0x00DD
    1056:	00 97       	sbiw	r24, 0x00	; 0
    1058:	31 f4       	brne	.+12     	; 0x1066 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    105a:	8f ed       	ldi	r24, 0xDF	; 223
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	90 93 dd 00 	sts	0x00DD, r25
    1062:	80 93 dc 00 	sts	0x00DC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1066:	80 91 da 00 	lds	r24, 0x00DA
    106a:	90 91 db 00 	lds	r25, 0x00DB
    106e:	2b 81       	ldd	r18, Y+3	; 0x03
    1070:	3c 81       	ldd	r19, Y+4	; 0x04
    1072:	82 0f       	add	r24, r18
    1074:	93 1f       	adc	r25, r19
    1076:	25 e0       	ldi	r18, 0x05	; 5
    1078:	8b 3d       	cpi	r24, 0xDB	; 219
    107a:	92 07       	cpc	r25, r18
    107c:	38 f5       	brcc	.+78     	; 0x10cc <pvPortMalloc+0x96>
    107e:	20 91 da 00 	lds	r18, 0x00DA
    1082:	30 91 db 00 	lds	r19, 0x00DB
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	9c 81       	ldd	r25, Y+4	; 0x04
    108a:	28 0f       	add	r18, r24
    108c:	39 1f       	adc	r19, r25
    108e:	80 91 da 00 	lds	r24, 0x00DA
    1092:	90 91 db 00 	lds	r25, 0x00DB
    1096:	82 17       	cp	r24, r18
    1098:	93 07       	cpc	r25, r19
    109a:	c0 f4       	brcc	.+48     	; 0x10cc <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    109c:	20 91 dc 00 	lds	r18, 0x00DC
    10a0:	30 91 dd 00 	lds	r19, 0x00DD
    10a4:	80 91 da 00 	lds	r24, 0x00DA
    10a8:	90 91 db 00 	lds	r25, 0x00DB
    10ac:	82 0f       	add	r24, r18
    10ae:	93 1f       	adc	r25, r19
    10b0:	9a 83       	std	Y+2, r25	; 0x02
    10b2:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    10b4:	20 91 da 00 	lds	r18, 0x00DA
    10b8:	30 91 db 00 	lds	r19, 0x00DB
    10bc:	8b 81       	ldd	r24, Y+3	; 0x03
    10be:	9c 81       	ldd	r25, Y+4	; 0x04
    10c0:	82 0f       	add	r24, r18
    10c2:	93 1f       	adc	r25, r19
    10c4:	90 93 db 00 	sts	0x00DB, r25
    10c8:	80 93 da 00 	sts	0x00DA, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    10cc:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    10d0:	89 81       	ldd	r24, Y+1	; 0x01
    10d2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    10d4:	0f 90       	pop	r0
    10d6:	0f 90       	pop	r0
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	cf 91       	pop	r28
    10de:	df 91       	pop	r29
    10e0:	08 95       	ret

000010e2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <vPortFree+0x6>
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	9a 83       	std	Y+2, r25	; 0x02
    10ee:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    10f0:	0f 90       	pop	r0
    10f2:	0f 90       	pop	r0
    10f4:	cf 91       	pop	r28
    10f6:	df 91       	pop	r29
    10f8:	08 95       	ret

000010fa <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    10fa:	df 93       	push	r29
    10fc:	cf 93       	push	r28
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1102:	10 92 db 00 	sts	0x00DB, r1
    1106:	10 92 da 00 	sts	0x00DA, r1
}
    110a:	cf 91       	pop	r28
    110c:	df 91       	pop	r29
    110e:	08 95       	ret

00001110 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1110:	df 93       	push	r29
    1112:	cf 93       	push	r28
    1114:	cd b7       	in	r28, 0x3d	; 61
    1116:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1118:	20 91 da 00 	lds	r18, 0x00DA
    111c:	30 91 db 00 	lds	r19, 0x00DB
    1120:	8b ed       	ldi	r24, 0xDB	; 219
    1122:	95 e0       	ldi	r25, 0x05	; 5
    1124:	82 1b       	sub	r24, r18
    1126:	93 0b       	sbc	r25, r19
}
    1128:	cf 91       	pop	r28
    112a:	df 91       	pop	r29
    112c:	08 95       	ret

0000112e <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    112e:	df 93       	push	r29
    1130:	cf 93       	push	r28
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1136:	aa e3       	ldi	r26, 0x3A	; 58
    1138:	b0 e0       	ldi	r27, 0x00	; 0
    113a:	ea e3       	ldi	r30, 0x3A	; 58
    113c:	f0 e0       	ldi	r31, 0x00	; 0
    113e:	80 81       	ld	r24, Z
    1140:	8e 60       	ori	r24, 0x0E	; 14
    1142:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    1144:	aa e3       	ldi	r26, 0x3A	; 58
    1146:	b0 e0       	ldi	r27, 0x00	; 0
    1148:	ea e3       	ldi	r30, 0x3A	; 58
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	80 81       	ld	r24, Z
    114e:	80 6f       	ori	r24, 0xF0	; 240
    1150:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    1152:	82 e0       	ldi	r24, 0x02	; 2
    1154:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    1158:	88 e2       	ldi	r24, 0x28	; 40
    115a:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    115e:	8c e0       	ldi	r24, 0x0C	; 12
    1160:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_sendCommand>

}
    116a:	cf 91       	pop	r28
    116c:	df 91       	pop	r29
    116e:	08 95       	ret

00001170 <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    1170:	df 93       	push	r29
    1172:	cf 93       	push	r28
    1174:	0f 92       	push	r0
    1176:	cd b7       	in	r28, 0x3d	; 61
    1178:	de b7       	in	r29, 0x3e	; 62
    117a:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    117c:	ab e3       	ldi	r26, 0x3B	; 59
    117e:	b0 e0       	ldi	r27, 0x00	; 0
    1180:	eb e3       	ldi	r30, 0x3B	; 59
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	80 81       	ld	r24, Z
    1186:	8d 7f       	andi	r24, 0xFD	; 253
    1188:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    118a:	ab e3       	ldi	r26, 0x3B	; 59
    118c:	b0 e0       	ldi	r27, 0x00	; 0
    118e:	eb e3       	ldi	r30, 0x3B	; 59
    1190:	f0 e0       	ldi	r31, 0x00	; 0
    1192:	80 81       	ld	r24, Z
    1194:	8b 7f       	andi	r24, 0xFB	; 251
    1196:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    11a0:	ab e3       	ldi	r26, 0x3B	; 59
    11a2:	b0 e0       	ldi	r27, 0x00	; 0
    11a4:	eb e3       	ldi	r30, 0x3B	; 59
    11a6:	f0 e0       	ldi	r31, 0x00	; 0
    11a8:	80 81       	ld	r24, Z
    11aa:	88 60       	ori	r24, 0x08	; 8
    11ac:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    11b6:	ab e3       	ldi	r26, 0x3B	; 59
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	eb e3       	ldi	r30, 0x3B	; 59
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	98 2f       	mov	r25, r24
    11c2:	9f 70       	andi	r25, 0x0F	; 15
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	80 7f       	andi	r24, 0xF0	; 240
    11c8:	89 2b       	or	r24, r25
    11ca:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    11d4:	ab e3       	ldi	r26, 0x3B	; 59
    11d6:	b0 e0       	ldi	r27, 0x00	; 0
    11d8:	eb e3       	ldi	r30, 0x3B	; 59
    11da:	f0 e0       	ldi	r31, 0x00	; 0
    11dc:	80 81       	ld	r24, Z
    11de:	87 7f       	andi	r24, 0xF7	; 247
    11e0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    11e2:	81 e0       	ldi	r24, 0x01	; 1
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    11ea:	ab e3       	ldi	r26, 0x3B	; 59
    11ec:	b0 e0       	ldi	r27, 0x00	; 0
    11ee:	eb e3       	ldi	r30, 0x3B	; 59
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	80 81       	ld	r24, Z
    11f4:	88 60       	ori	r24, 0x08	; 8
    11f6:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    1200:	ab e3       	ldi	r26, 0x3B	; 59
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	eb e3       	ldi	r30, 0x3B	; 59
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	28 2f       	mov	r18, r24
    120c:	2f 70       	andi	r18, 0x0F	; 15
    120e:	89 81       	ldd	r24, Y+1	; 0x01
    1210:	88 2f       	mov	r24, r24
    1212:	90 e0       	ldi	r25, 0x00	; 0
    1214:	82 95       	swap	r24
    1216:	92 95       	swap	r25
    1218:	90 7f       	andi	r25, 0xF0	; 240
    121a:	98 27       	eor	r25, r24
    121c:	80 7f       	andi	r24, 0xF0	; 240
    121e:	98 27       	eor	r25, r24
    1220:	82 2b       	or	r24, r18
    1222:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    122c:	ab e3       	ldi	r26, 0x3B	; 59
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	eb e3       	ldi	r30, 0x3B	; 59
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	87 7f       	andi	r24, 0xF7	; 247
    1238:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	90 e0       	ldi	r25, 0x00	; 0
    123e:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1242:	0f 90       	pop	r0
    1244:	cf 91       	pop	r28
    1246:	df 91       	pop	r29
    1248:	08 95       	ret

0000124a <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    124a:	df 93       	push	r29
    124c:	cf 93       	push	r28
    124e:	0f 92       	push	r0
    1250:	cd b7       	in	r28, 0x3d	; 61
    1252:	de b7       	in	r29, 0x3e	; 62
    1254:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1256:	ab e3       	ldi	r26, 0x3B	; 59
    1258:	b0 e0       	ldi	r27, 0x00	; 0
    125a:	eb e3       	ldi	r30, 0x3B	; 59
    125c:	f0 e0       	ldi	r31, 0x00	; 0
    125e:	80 81       	ld	r24, Z
    1260:	82 60       	ori	r24, 0x02	; 2
    1262:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1264:	ab e3       	ldi	r26, 0x3B	; 59
    1266:	b0 e0       	ldi	r27, 0x00	; 0
    1268:	eb e3       	ldi	r30, 0x3B	; 59
    126a:	f0 e0       	ldi	r31, 0x00	; 0
    126c:	80 81       	ld	r24, Z
    126e:	8b 7f       	andi	r24, 0xFB	; 251
    1270:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    127a:	ab e3       	ldi	r26, 0x3B	; 59
    127c:	b0 e0       	ldi	r27, 0x00	; 0
    127e:	eb e3       	ldi	r30, 0x3B	; 59
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	88 60       	ori	r24, 0x08	; 8
    1286:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1288:	81 e0       	ldi	r24, 0x01	; 1
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    1290:	ab e3       	ldi	r26, 0x3B	; 59
    1292:	b0 e0       	ldi	r27, 0x00	; 0
    1294:	eb e3       	ldi	r30, 0x3B	; 59
    1296:	f0 e0       	ldi	r31, 0x00	; 0
    1298:	80 81       	ld	r24, Z
    129a:	98 2f       	mov	r25, r24
    129c:	9f 70       	andi	r25, 0x0F	; 15
    129e:	89 81       	ldd	r24, Y+1	; 0x01
    12a0:	80 7f       	andi	r24, 0xF0	; 240
    12a2:	89 2b       	or	r24, r25
    12a4:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	90 e0       	ldi	r25, 0x00	; 0
    12aa:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    12ae:	ab e3       	ldi	r26, 0x3B	; 59
    12b0:	b0 e0       	ldi	r27, 0x00	; 0
    12b2:	eb e3       	ldi	r30, 0x3B	; 59
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	80 81       	ld	r24, Z
    12b8:	87 7f       	andi	r24, 0xF7	; 247
    12ba:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	90 e0       	ldi	r25, 0x00	; 0
    12c0:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    12c4:	ab e3       	ldi	r26, 0x3B	; 59
    12c6:	b0 e0       	ldi	r27, 0x00	; 0
    12c8:	eb e3       	ldi	r30, 0x3B	; 59
    12ca:	f0 e0       	ldi	r31, 0x00	; 0
    12cc:	80 81       	ld	r24, Z
    12ce:	88 60       	ori	r24, 0x08	; 8
    12d0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    12da:	ab e3       	ldi	r26, 0x3B	; 59
    12dc:	b0 e0       	ldi	r27, 0x00	; 0
    12de:	eb e3       	ldi	r30, 0x3B	; 59
    12e0:	f0 e0       	ldi	r31, 0x00	; 0
    12e2:	80 81       	ld	r24, Z
    12e4:	28 2f       	mov	r18, r24
    12e6:	2f 70       	andi	r18, 0x0F	; 15
    12e8:	89 81       	ldd	r24, Y+1	; 0x01
    12ea:	88 2f       	mov	r24, r24
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	82 95       	swap	r24
    12f0:	92 95       	swap	r25
    12f2:	90 7f       	andi	r25, 0xF0	; 240
    12f4:	98 27       	eor	r25, r24
    12f6:	80 7f       	andi	r24, 0xF0	; 240
    12f8:	98 27       	eor	r25, r24
    12fa:	82 2b       	or	r24, r18
    12fc:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1306:	ab e3       	ldi	r26, 0x3B	; 59
    1308:	b0 e0       	ldi	r27, 0x00	; 0
    130a:	eb e3       	ldi	r30, 0x3B	; 59
    130c:	f0 e0       	ldi	r31, 0x00	; 0
    130e:	80 81       	ld	r24, Z
    1310:	87 7f       	andi	r24, 0xF7	; 247
    1312:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    131c:	0f 90       	pop	r0
    131e:	cf 91       	pop	r28
    1320:	df 91       	pop	r29
    1322:	08 95       	ret

00001324 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1324:	df 93       	push	r29
    1326:	cf 93       	push	r28
    1328:	00 d0       	rcall	.+0      	; 0x132a <LCD_displayString+0x6>
    132a:	0f 92       	push	r0
    132c:	cd b7       	in	r28, 0x3d	; 61
    132e:	de b7       	in	r29, 0x3e	; 62
    1330:	9b 83       	std	Y+3, r25	; 0x03
    1332:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1334:	19 82       	std	Y+1, r1	; 0x01
    1336:	0e c0       	rjmp	.+28     	; 0x1354 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1338:	89 81       	ldd	r24, Y+1	; 0x01
    133a:	28 2f       	mov	r18, r24
    133c:	30 e0       	ldi	r19, 0x00	; 0
    133e:	8a 81       	ldd	r24, Y+2	; 0x02
    1340:	9b 81       	ldd	r25, Y+3	; 0x03
    1342:	fc 01       	movw	r30, r24
    1344:	e2 0f       	add	r30, r18
    1346:	f3 1f       	adc	r31, r19
    1348:	80 81       	ld	r24, Z
    134a:	0e 94 25 09 	call	0x124a	; 0x124a <LCD_displayCharacter>
		i++;
    134e:	89 81       	ldd	r24, Y+1	; 0x01
    1350:	8f 5f       	subi	r24, 0xFF	; 255
    1352:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    1354:	89 81       	ldd	r24, Y+1	; 0x01
    1356:	28 2f       	mov	r18, r24
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	8a 81       	ldd	r24, Y+2	; 0x02
    135c:	9b 81       	ldd	r25, Y+3	; 0x03
    135e:	fc 01       	movw	r30, r24
    1360:	e2 0f       	add	r30, r18
    1362:	f3 1f       	adc	r31, r19
    1364:	80 81       	ld	r24, Z
    1366:	88 23       	and	r24, r24
    1368:	39 f7       	brne	.-50     	; 0x1338 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    136a:	0f 90       	pop	r0
    136c:	0f 90       	pop	r0
    136e:	0f 90       	pop	r0
    1370:	cf 91       	pop	r28
    1372:	df 91       	pop	r29
    1374:	08 95       	ret

00001376 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    1376:	df 93       	push	r29
    1378:	cf 93       	push	r28
    137a:	00 d0       	rcall	.+0      	; 0x137c <LCD_goToRowColumn+0x6>
    137c:	00 d0       	rcall	.+0      	; 0x137e <LCD_goToRowColumn+0x8>
    137e:	0f 92       	push	r0
    1380:	cd b7       	in	r28, 0x3d	; 61
    1382:	de b7       	in	r29, 0x3e	; 62
    1384:	8a 83       	std	Y+2, r24	; 0x02
    1386:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    1388:	8a 81       	ldd	r24, Y+2	; 0x02
    138a:	28 2f       	mov	r18, r24
    138c:	30 e0       	ldi	r19, 0x00	; 0
    138e:	3d 83       	std	Y+5, r19	; 0x05
    1390:	2c 83       	std	Y+4, r18	; 0x04
    1392:	8c 81       	ldd	r24, Y+4	; 0x04
    1394:	9d 81       	ldd	r25, Y+5	; 0x05
    1396:	81 30       	cpi	r24, 0x01	; 1
    1398:	91 05       	cpc	r25, r1
    139a:	c1 f0       	breq	.+48     	; 0x13cc <LCD_goToRowColumn+0x56>
    139c:	2c 81       	ldd	r18, Y+4	; 0x04
    139e:	3d 81       	ldd	r19, Y+5	; 0x05
    13a0:	22 30       	cpi	r18, 0x02	; 2
    13a2:	31 05       	cpc	r19, r1
    13a4:	2c f4       	brge	.+10     	; 0x13b0 <LCD_goToRowColumn+0x3a>
    13a6:	8c 81       	ldd	r24, Y+4	; 0x04
    13a8:	9d 81       	ldd	r25, Y+5	; 0x05
    13aa:	00 97       	sbiw	r24, 0x00	; 0
    13ac:	61 f0       	breq	.+24     	; 0x13c6 <LCD_goToRowColumn+0x50>
    13ae:	19 c0       	rjmp	.+50     	; 0x13e2 <LCD_goToRowColumn+0x6c>
    13b0:	2c 81       	ldd	r18, Y+4	; 0x04
    13b2:	3d 81       	ldd	r19, Y+5	; 0x05
    13b4:	22 30       	cpi	r18, 0x02	; 2
    13b6:	31 05       	cpc	r19, r1
    13b8:	69 f0       	breq	.+26     	; 0x13d4 <LCD_goToRowColumn+0x5e>
    13ba:	8c 81       	ldd	r24, Y+4	; 0x04
    13bc:	9d 81       	ldd	r25, Y+5	; 0x05
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	91 05       	cpc	r25, r1
    13c2:	61 f0       	breq	.+24     	; 0x13dc <LCD_goToRowColumn+0x66>
    13c4:	0e c0       	rjmp	.+28     	; 0x13e2 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    13c6:	8b 81       	ldd	r24, Y+3	; 0x03
    13c8:	89 83       	std	Y+1, r24	; 0x01
    13ca:	0b c0       	rjmp	.+22     	; 0x13e2 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    13cc:	8b 81       	ldd	r24, Y+3	; 0x03
    13ce:	80 5c       	subi	r24, 0xC0	; 192
    13d0:	89 83       	std	Y+1, r24	; 0x01
    13d2:	07 c0       	rjmp	.+14     	; 0x13e2 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    13d4:	8b 81       	ldd	r24, Y+3	; 0x03
    13d6:	80 5f       	subi	r24, 0xF0	; 240
    13d8:	89 83       	std	Y+1, r24	; 0x01
    13da:	03 c0       	rjmp	.+6      	; 0x13e2 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    13dc:	8b 81       	ldd	r24, Y+3	; 0x03
    13de:	80 5b       	subi	r24, 0xB0	; 176
    13e0:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    13e2:	89 81       	ldd	r24, Y+1	; 0x01
    13e4:	80 68       	ori	r24, 0x80	; 128
    13e6:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_sendCommand>
}
    13ea:	0f 90       	pop	r0
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	0f 90       	pop	r0
    13f2:	0f 90       	pop	r0
    13f4:	cf 91       	pop	r28
    13f6:	df 91       	pop	r29
    13f8:	08 95       	ret

000013fa <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    13fa:	df 93       	push	r29
    13fc:	cf 93       	push	r28
    13fe:	00 d0       	rcall	.+0      	; 0x1400 <LCD_displayStringRowColumn+0x6>
    1400:	00 d0       	rcall	.+0      	; 0x1402 <LCD_displayStringRowColumn+0x8>
    1402:	cd b7       	in	r28, 0x3d	; 61
    1404:	de b7       	in	r29, 0x3e	; 62
    1406:	89 83       	std	Y+1, r24	; 0x01
    1408:	6a 83       	std	Y+2, r22	; 0x02
    140a:	5c 83       	std	Y+4, r21	; 0x04
    140c:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    140e:	89 81       	ldd	r24, Y+1	; 0x01
    1410:	6a 81       	ldd	r22, Y+2	; 0x02
    1412:	0e 94 bb 09 	call	0x1376	; 0x1376 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1416:	8b 81       	ldd	r24, Y+3	; 0x03
    1418:	9c 81       	ldd	r25, Y+4	; 0x04
    141a:	0e 94 92 09 	call	0x1324	; 0x1324 <LCD_displayString>
}
    141e:	0f 90       	pop	r0
    1420:	0f 90       	pop	r0
    1422:	0f 90       	pop	r0
    1424:	0f 90       	pop	r0
    1426:	cf 91       	pop	r28
    1428:	df 91       	pop	r29
    142a:	08 95       	ret

0000142c <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    142c:	df 93       	push	r29
    142e:	cf 93       	push	r28
    1430:	cd b7       	in	r28, 0x3d	; 61
    1432:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	0e 94 b8 08 	call	0x1170	; 0x1170 <LCD_sendCommand>
}
    143a:	cf 91       	pop	r28
    143c:	df 91       	pop	r29
    143e:	08 95       	ret

00001440 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1440:	df 93       	push	r29
    1442:	cf 93       	push	r28
    1444:	00 d0       	rcall	.+0      	; 0x1446 <vListInitialise+0x6>
    1446:	cd b7       	in	r28, 0x3d	; 61
    1448:	de b7       	in	r29, 0x3e	; 62
    144a:	9a 83       	std	Y+2, r25	; 0x02
    144c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	9a 81       	ldd	r25, Y+2	; 0x02
    1452:	03 96       	adiw	r24, 0x03	; 3
    1454:	e9 81       	ldd	r30, Y+1	; 0x01
    1456:	fa 81       	ldd	r31, Y+2	; 0x02
    1458:	92 83       	std	Z+2, r25	; 0x02
    145a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    145c:	e9 81       	ldd	r30, Y+1	; 0x01
    145e:	fa 81       	ldd	r31, Y+2	; 0x02
    1460:	8f ef       	ldi	r24, 0xFF	; 255
    1462:	9f ef       	ldi	r25, 0xFF	; 255
    1464:	94 83       	std	Z+4, r25	; 0x04
    1466:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1468:	89 81       	ldd	r24, Y+1	; 0x01
    146a:	9a 81       	ldd	r25, Y+2	; 0x02
    146c:	03 96       	adiw	r24, 0x03	; 3
    146e:	e9 81       	ldd	r30, Y+1	; 0x01
    1470:	fa 81       	ldd	r31, Y+2	; 0x02
    1472:	96 83       	std	Z+6, r25	; 0x06
    1474:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1476:	89 81       	ldd	r24, Y+1	; 0x01
    1478:	9a 81       	ldd	r25, Y+2	; 0x02
    147a:	03 96       	adiw	r24, 0x03	; 3
    147c:	e9 81       	ldd	r30, Y+1	; 0x01
    147e:	fa 81       	ldd	r31, Y+2	; 0x02
    1480:	90 87       	std	Z+8, r25	; 0x08
    1482:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1484:	e9 81       	ldd	r30, Y+1	; 0x01
    1486:	fa 81       	ldd	r31, Y+2	; 0x02
    1488:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    148a:	0f 90       	pop	r0
    148c:	0f 90       	pop	r0
    148e:	cf 91       	pop	r28
    1490:	df 91       	pop	r29
    1492:	08 95       	ret

00001494 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1494:	df 93       	push	r29
    1496:	cf 93       	push	r28
    1498:	00 d0       	rcall	.+0      	; 0x149a <vListInitialiseItem+0x6>
    149a:	cd b7       	in	r28, 0x3d	; 61
    149c:	de b7       	in	r29, 0x3e	; 62
    149e:	9a 83       	std	Y+2, r25	; 0x02
    14a0:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    14a2:	e9 81       	ldd	r30, Y+1	; 0x01
    14a4:	fa 81       	ldd	r31, Y+2	; 0x02
    14a6:	11 86       	std	Z+9, r1	; 0x09
    14a8:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    14aa:	0f 90       	pop	r0
    14ac:	0f 90       	pop	r0
    14ae:	cf 91       	pop	r28
    14b0:	df 91       	pop	r29
    14b2:	08 95       	ret

000014b4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    14b4:	df 93       	push	r29
    14b6:	cf 93       	push	r28
    14b8:	00 d0       	rcall	.+0      	; 0x14ba <vListInsertEnd+0x6>
    14ba:	00 d0       	rcall	.+0      	; 0x14bc <vListInsertEnd+0x8>
    14bc:	00 d0       	rcall	.+0      	; 0x14be <vListInsertEnd+0xa>
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	9c 83       	std	Y+4, r25	; 0x04
    14c4:	8b 83       	std	Y+3, r24	; 0x03
    14c6:	7e 83       	std	Y+6, r23	; 0x06
    14c8:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    14ca:	eb 81       	ldd	r30, Y+3	; 0x03
    14cc:	fc 81       	ldd	r31, Y+4	; 0x04
    14ce:	81 81       	ldd	r24, Z+1	; 0x01
    14d0:	92 81       	ldd	r25, Z+2	; 0x02
    14d2:	9a 83       	std	Y+2, r25	; 0x02
    14d4:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    14d6:	ed 81       	ldd	r30, Y+5	; 0x05
    14d8:	fe 81       	ldd	r31, Y+6	; 0x06
    14da:	89 81       	ldd	r24, Y+1	; 0x01
    14dc:	9a 81       	ldd	r25, Y+2	; 0x02
    14de:	93 83       	std	Z+3, r25	; 0x03
    14e0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    14e2:	e9 81       	ldd	r30, Y+1	; 0x01
    14e4:	fa 81       	ldd	r31, Y+2	; 0x02
    14e6:	84 81       	ldd	r24, Z+4	; 0x04
    14e8:	95 81       	ldd	r25, Z+5	; 0x05
    14ea:	ed 81       	ldd	r30, Y+5	; 0x05
    14ec:	fe 81       	ldd	r31, Y+6	; 0x06
    14ee:	95 83       	std	Z+5, r25	; 0x05
    14f0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    14f2:	e9 81       	ldd	r30, Y+1	; 0x01
    14f4:	fa 81       	ldd	r31, Y+2	; 0x02
    14f6:	04 80       	ldd	r0, Z+4	; 0x04
    14f8:	f5 81       	ldd	r31, Z+5	; 0x05
    14fa:	e0 2d       	mov	r30, r0
    14fc:	8d 81       	ldd	r24, Y+5	; 0x05
    14fe:	9e 81       	ldd	r25, Y+6	; 0x06
    1500:	93 83       	std	Z+3, r25	; 0x03
    1502:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1504:	e9 81       	ldd	r30, Y+1	; 0x01
    1506:	fa 81       	ldd	r31, Y+2	; 0x02
    1508:	8d 81       	ldd	r24, Y+5	; 0x05
    150a:	9e 81       	ldd	r25, Y+6	; 0x06
    150c:	95 83       	std	Z+5, r25	; 0x05
    150e:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1510:	ed 81       	ldd	r30, Y+5	; 0x05
    1512:	fe 81       	ldd	r31, Y+6	; 0x06
    1514:	8b 81       	ldd	r24, Y+3	; 0x03
    1516:	9c 81       	ldd	r25, Y+4	; 0x04
    1518:	91 87       	std	Z+9, r25	; 0x09
    151a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    151c:	eb 81       	ldd	r30, Y+3	; 0x03
    151e:	fc 81       	ldd	r31, Y+4	; 0x04
    1520:	80 81       	ld	r24, Z
    1522:	8f 5f       	subi	r24, 0xFF	; 255
    1524:	eb 81       	ldd	r30, Y+3	; 0x03
    1526:	fc 81       	ldd	r31, Y+4	; 0x04
    1528:	80 83       	st	Z, r24
}
    152a:	26 96       	adiw	r28, 0x06	; 6
    152c:	0f b6       	in	r0, 0x3f	; 63
    152e:	f8 94       	cli
    1530:	de bf       	out	0x3e, r29	; 62
    1532:	0f be       	out	0x3f, r0	; 63
    1534:	cd bf       	out	0x3d, r28	; 61
    1536:	cf 91       	pop	r28
    1538:	df 91       	pop	r29
    153a:	08 95       	ret

0000153c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    153c:	df 93       	push	r29
    153e:	cf 93       	push	r28
    1540:	cd b7       	in	r28, 0x3d	; 61
    1542:	de b7       	in	r29, 0x3e	; 62
    1544:	28 97       	sbiw	r28, 0x08	; 8
    1546:	0f b6       	in	r0, 0x3f	; 63
    1548:	f8 94       	cli
    154a:	de bf       	out	0x3e, r29	; 62
    154c:	0f be       	out	0x3f, r0	; 63
    154e:	cd bf       	out	0x3d, r28	; 61
    1550:	9e 83       	std	Y+6, r25	; 0x06
    1552:	8d 83       	std	Y+5, r24	; 0x05
    1554:	78 87       	std	Y+8, r23	; 0x08
    1556:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1558:	ef 81       	ldd	r30, Y+7	; 0x07
    155a:	f8 85       	ldd	r31, Y+8	; 0x08
    155c:	80 81       	ld	r24, Z
    155e:	91 81       	ldd	r25, Z+1	; 0x01
    1560:	9a 83       	std	Y+2, r25	; 0x02
    1562:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1564:	89 81       	ldd	r24, Y+1	; 0x01
    1566:	9a 81       	ldd	r25, Y+2	; 0x02
    1568:	2f ef       	ldi	r18, 0xFF	; 255
    156a:	8f 3f       	cpi	r24, 0xFF	; 255
    156c:	92 07       	cpc	r25, r18
    156e:	39 f4       	brne	.+14     	; 0x157e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1570:	ed 81       	ldd	r30, Y+5	; 0x05
    1572:	fe 81       	ldd	r31, Y+6	; 0x06
    1574:	87 81       	ldd	r24, Z+7	; 0x07
    1576:	90 85       	ldd	r25, Z+8	; 0x08
    1578:	9c 83       	std	Y+4, r25	; 0x04
    157a:	8b 83       	std	Y+3, r24	; 0x03
    157c:	18 c0       	rjmp	.+48     	; 0x15ae <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    157e:	8d 81       	ldd	r24, Y+5	; 0x05
    1580:	9e 81       	ldd	r25, Y+6	; 0x06
    1582:	03 96       	adiw	r24, 0x03	; 3
    1584:	9c 83       	std	Y+4, r25	; 0x04
    1586:	8b 83       	std	Y+3, r24	; 0x03
    1588:	06 c0       	rjmp	.+12     	; 0x1596 <vListInsert+0x5a>
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	82 81       	ldd	r24, Z+2	; 0x02
    1590:	93 81       	ldd	r25, Z+3	; 0x03
    1592:	9c 83       	std	Y+4, r25	; 0x04
    1594:	8b 83       	std	Y+3, r24	; 0x03
    1596:	eb 81       	ldd	r30, Y+3	; 0x03
    1598:	fc 81       	ldd	r31, Y+4	; 0x04
    159a:	02 80       	ldd	r0, Z+2	; 0x02
    159c:	f3 81       	ldd	r31, Z+3	; 0x03
    159e:	e0 2d       	mov	r30, r0
    15a0:	20 81       	ld	r18, Z
    15a2:	31 81       	ldd	r19, Z+1	; 0x01
    15a4:	89 81       	ldd	r24, Y+1	; 0x01
    15a6:	9a 81       	ldd	r25, Y+2	; 0x02
    15a8:	82 17       	cp	r24, r18
    15aa:	93 07       	cpc	r25, r19
    15ac:	70 f7       	brcc	.-36     	; 0x158a <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15ae:	eb 81       	ldd	r30, Y+3	; 0x03
    15b0:	fc 81       	ldd	r31, Y+4	; 0x04
    15b2:	82 81       	ldd	r24, Z+2	; 0x02
    15b4:	93 81       	ldd	r25, Z+3	; 0x03
    15b6:	ef 81       	ldd	r30, Y+7	; 0x07
    15b8:	f8 85       	ldd	r31, Y+8	; 0x08
    15ba:	93 83       	std	Z+3, r25	; 0x03
    15bc:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    15be:	ef 81       	ldd	r30, Y+7	; 0x07
    15c0:	f8 85       	ldd	r31, Y+8	; 0x08
    15c2:	02 80       	ldd	r0, Z+2	; 0x02
    15c4:	f3 81       	ldd	r31, Z+3	; 0x03
    15c6:	e0 2d       	mov	r30, r0
    15c8:	8f 81       	ldd	r24, Y+7	; 0x07
    15ca:	98 85       	ldd	r25, Y+8	; 0x08
    15cc:	95 83       	std	Z+5, r25	; 0x05
    15ce:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    15d0:	ef 81       	ldd	r30, Y+7	; 0x07
    15d2:	f8 85       	ldd	r31, Y+8	; 0x08
    15d4:	8b 81       	ldd	r24, Y+3	; 0x03
    15d6:	9c 81       	ldd	r25, Y+4	; 0x04
    15d8:	95 83       	std	Z+5, r25	; 0x05
    15da:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    15dc:	eb 81       	ldd	r30, Y+3	; 0x03
    15de:	fc 81       	ldd	r31, Y+4	; 0x04
    15e0:	8f 81       	ldd	r24, Y+7	; 0x07
    15e2:	98 85       	ldd	r25, Y+8	; 0x08
    15e4:	93 83       	std	Z+3, r25	; 0x03
    15e6:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    15e8:	ef 81       	ldd	r30, Y+7	; 0x07
    15ea:	f8 85       	ldd	r31, Y+8	; 0x08
    15ec:	8d 81       	ldd	r24, Y+5	; 0x05
    15ee:	9e 81       	ldd	r25, Y+6	; 0x06
    15f0:	91 87       	std	Z+9, r25	; 0x09
    15f2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    15f4:	ed 81       	ldd	r30, Y+5	; 0x05
    15f6:	fe 81       	ldd	r31, Y+6	; 0x06
    15f8:	80 81       	ld	r24, Z
    15fa:	8f 5f       	subi	r24, 0xFF	; 255
    15fc:	ed 81       	ldd	r30, Y+5	; 0x05
    15fe:	fe 81       	ldd	r31, Y+6	; 0x06
    1600:	80 83       	st	Z, r24
}
    1602:	28 96       	adiw	r28, 0x08	; 8
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	f8 94       	cli
    1608:	de bf       	out	0x3e, r29	; 62
    160a:	0f be       	out	0x3f, r0	; 63
    160c:	cd bf       	out	0x3d, r28	; 61
    160e:	cf 91       	pop	r28
    1610:	df 91       	pop	r29
    1612:	08 95       	ret

00001614 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1614:	df 93       	push	r29
    1616:	cf 93       	push	r28
    1618:	00 d0       	rcall	.+0      	; 0x161a <uxListRemove+0x6>
    161a:	00 d0       	rcall	.+0      	; 0x161c <uxListRemove+0x8>
    161c:	cd b7       	in	r28, 0x3d	; 61
    161e:	de b7       	in	r29, 0x3e	; 62
    1620:	9c 83       	std	Y+4, r25	; 0x04
    1622:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1624:	eb 81       	ldd	r30, Y+3	; 0x03
    1626:	fc 81       	ldd	r31, Y+4	; 0x04
    1628:	80 85       	ldd	r24, Z+8	; 0x08
    162a:	91 85       	ldd	r25, Z+9	; 0x09
    162c:	9a 83       	std	Y+2, r25	; 0x02
    162e:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1630:	eb 81       	ldd	r30, Y+3	; 0x03
    1632:	fc 81       	ldd	r31, Y+4	; 0x04
    1634:	a2 81       	ldd	r26, Z+2	; 0x02
    1636:	b3 81       	ldd	r27, Z+3	; 0x03
    1638:	eb 81       	ldd	r30, Y+3	; 0x03
    163a:	fc 81       	ldd	r31, Y+4	; 0x04
    163c:	84 81       	ldd	r24, Z+4	; 0x04
    163e:	95 81       	ldd	r25, Z+5	; 0x05
    1640:	15 96       	adiw	r26, 0x05	; 5
    1642:	9c 93       	st	X, r25
    1644:	8e 93       	st	-X, r24
    1646:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1648:	eb 81       	ldd	r30, Y+3	; 0x03
    164a:	fc 81       	ldd	r31, Y+4	; 0x04
    164c:	a4 81       	ldd	r26, Z+4	; 0x04
    164e:	b5 81       	ldd	r27, Z+5	; 0x05
    1650:	eb 81       	ldd	r30, Y+3	; 0x03
    1652:	fc 81       	ldd	r31, Y+4	; 0x04
    1654:	82 81       	ldd	r24, Z+2	; 0x02
    1656:	93 81       	ldd	r25, Z+3	; 0x03
    1658:	13 96       	adiw	r26, 0x03	; 3
    165a:	9c 93       	st	X, r25
    165c:	8e 93       	st	-X, r24
    165e:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1660:	e9 81       	ldd	r30, Y+1	; 0x01
    1662:	fa 81       	ldd	r31, Y+2	; 0x02
    1664:	21 81       	ldd	r18, Z+1	; 0x01
    1666:	32 81       	ldd	r19, Z+2	; 0x02
    1668:	8b 81       	ldd	r24, Y+3	; 0x03
    166a:	9c 81       	ldd	r25, Y+4	; 0x04
    166c:	28 17       	cp	r18, r24
    166e:	39 07       	cpc	r19, r25
    1670:	41 f4       	brne	.+16     	; 0x1682 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1672:	eb 81       	ldd	r30, Y+3	; 0x03
    1674:	fc 81       	ldd	r31, Y+4	; 0x04
    1676:	84 81       	ldd	r24, Z+4	; 0x04
    1678:	95 81       	ldd	r25, Z+5	; 0x05
    167a:	e9 81       	ldd	r30, Y+1	; 0x01
    167c:	fa 81       	ldd	r31, Y+2	; 0x02
    167e:	92 83       	std	Z+2, r25	; 0x02
    1680:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1682:	eb 81       	ldd	r30, Y+3	; 0x03
    1684:	fc 81       	ldd	r31, Y+4	; 0x04
    1686:	11 86       	std	Z+9, r1	; 0x09
    1688:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    168a:	e9 81       	ldd	r30, Y+1	; 0x01
    168c:	fa 81       	ldd	r31, Y+2	; 0x02
    168e:	80 81       	ld	r24, Z
    1690:	81 50       	subi	r24, 0x01	; 1
    1692:	e9 81       	ldd	r30, Y+1	; 0x01
    1694:	fa 81       	ldd	r31, Y+2	; 0x02
    1696:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1698:	e9 81       	ldd	r30, Y+1	; 0x01
    169a:	fa 81       	ldd	r31, Y+2	; 0x02
    169c:	80 81       	ld	r24, Z
}
    169e:	0f 90       	pop	r0
    16a0:	0f 90       	pop	r0
    16a2:	0f 90       	pop	r0
    16a4:	0f 90       	pop	r0
    16a6:	cf 91       	pop	r28
    16a8:	df 91       	pop	r29
    16aa:	08 95       	ret

000016ac <main>:

#include "UserTasks.h"


void main(void)
{
    16ac:	ef 92       	push	r14
    16ae:	ff 92       	push	r15
    16b0:	0f 93       	push	r16
    16b2:	df 93       	push	r29
    16b4:	cf 93       	push	r28
    16b6:	cd b7       	in	r28, 0x3d	; 61
    16b8:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    16ba:	83 ec       	ldi	r24, 0xC3	; 195
    16bc:	92 e0       	ldi	r25, 0x02	; 2
    16be:	22 ec       	ldi	r18, 0xC2	; 194
    16c0:	30 e0       	ldi	r19, 0x00	; 0
    16c2:	e4 ed       	ldi	r30, 0xD4	; 212
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	b9 01       	movw	r22, r18
    16c8:	46 e9       	ldi	r20, 0x96	; 150
    16ca:	50 e0       	ldi	r21, 0x00	; 0
    16cc:	20 e0       	ldi	r18, 0x00	; 0
    16ce:	30 e0       	ldi	r19, 0x00	; 0
    16d0:	04 e0       	ldi	r16, 0x04	; 4
    16d2:	7f 01       	movw	r14, r30
    16d4:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , &InitTask_Flag);

	/* Start Scheduler */
	vTaskStartScheduler();
    16d8:	0e 94 a6 20 	call	0x414c	; 0x414c <vTaskStartScheduler>
    16dc:	ff cf       	rjmp	.-2      	; 0x16dc <main+0x30>

000016de <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    16de:	df 93       	push	r29
    16e0:	cf 93       	push	r28
    16e2:	cd b7       	in	r28, 0x3d	; 61
    16e4:	de b7       	in	r29, 0x3e	; 62
    16e6:	28 97       	sbiw	r28, 0x08	; 8
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	cd bf       	out	0x3d, r28	; 61
    16f2:	9c 83       	std	Y+4, r25	; 0x04
    16f4:	8b 83       	std	Y+3, r24	; 0x03
    16f6:	7e 83       	std	Y+6, r23	; 0x06
    16f8:	6d 83       	std	Y+5, r22	; 0x05
    16fa:	58 87       	std	Y+8, r21	; 0x08
    16fc:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    16fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1700:	fc 81       	ldd	r31, Y+4	; 0x04
    1702:	81 e1       	ldi	r24, 0x11	; 17
    1704:	80 83       	st	Z, r24
	pxTopOfStack--;
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	9c 81       	ldd	r25, Y+4	; 0x04
    170a:	01 97       	sbiw	r24, 0x01	; 1
    170c:	9c 83       	std	Y+4, r25	; 0x04
    170e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1710:	eb 81       	ldd	r30, Y+3	; 0x03
    1712:	fc 81       	ldd	r31, Y+4	; 0x04
    1714:	82 e2       	ldi	r24, 0x22	; 34
    1716:	80 83       	st	Z, r24
	pxTopOfStack--;
    1718:	8b 81       	ldd	r24, Y+3	; 0x03
    171a:	9c 81       	ldd	r25, Y+4	; 0x04
    171c:	01 97       	sbiw	r24, 0x01	; 1
    171e:	9c 83       	std	Y+4, r25	; 0x04
    1720:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1722:	eb 81       	ldd	r30, Y+3	; 0x03
    1724:	fc 81       	ldd	r31, Y+4	; 0x04
    1726:	83 e3       	ldi	r24, 0x33	; 51
    1728:	80 83       	st	Z, r24
	pxTopOfStack--;
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	9c 81       	ldd	r25, Y+4	; 0x04
    172e:	01 97       	sbiw	r24, 0x01	; 1
    1730:	9c 83       	std	Y+4, r25	; 0x04
    1732:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1734:	8d 81       	ldd	r24, Y+5	; 0x05
    1736:	9e 81       	ldd	r25, Y+6	; 0x06
    1738:	9a 83       	std	Y+2, r25	; 0x02
    173a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    173c:	89 81       	ldd	r24, Y+1	; 0x01
    173e:	eb 81       	ldd	r30, Y+3	; 0x03
    1740:	fc 81       	ldd	r31, Y+4	; 0x04
    1742:	80 83       	st	Z, r24
	pxTopOfStack--;
    1744:	8b 81       	ldd	r24, Y+3	; 0x03
    1746:	9c 81       	ldd	r25, Y+4	; 0x04
    1748:	01 97       	sbiw	r24, 0x01	; 1
    174a:	9c 83       	std	Y+4, r25	; 0x04
    174c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    174e:	89 81       	ldd	r24, Y+1	; 0x01
    1750:	9a 81       	ldd	r25, Y+2	; 0x02
    1752:	89 2f       	mov	r24, r25
    1754:	99 27       	eor	r25, r25
    1756:	9a 83       	std	Y+2, r25	; 0x02
    1758:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    175a:	89 81       	ldd	r24, Y+1	; 0x01
    175c:	eb 81       	ldd	r30, Y+3	; 0x03
    175e:	fc 81       	ldd	r31, Y+4	; 0x04
    1760:	80 83       	st	Z, r24
	pxTopOfStack--;
    1762:	8b 81       	ldd	r24, Y+3	; 0x03
    1764:	9c 81       	ldd	r25, Y+4	; 0x04
    1766:	01 97       	sbiw	r24, 0x01	; 1
    1768:	9c 83       	std	Y+4, r25	; 0x04
    176a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    176c:	eb 81       	ldd	r30, Y+3	; 0x03
    176e:	fc 81       	ldd	r31, Y+4	; 0x04
    1770:	10 82       	st	Z, r1
	pxTopOfStack--;
    1772:	8b 81       	ldd	r24, Y+3	; 0x03
    1774:	9c 81       	ldd	r25, Y+4	; 0x04
    1776:	01 97       	sbiw	r24, 0x01	; 1
    1778:	9c 83       	std	Y+4, r25	; 0x04
    177a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    177c:	eb 81       	ldd	r30, Y+3	; 0x03
    177e:	fc 81       	ldd	r31, Y+4	; 0x04
    1780:	80 e8       	ldi	r24, 0x80	; 128
    1782:	80 83       	st	Z, r24
	pxTopOfStack--;
    1784:	8b 81       	ldd	r24, Y+3	; 0x03
    1786:	9c 81       	ldd	r25, Y+4	; 0x04
    1788:	01 97       	sbiw	r24, 0x01	; 1
    178a:	9c 83       	std	Y+4, r25	; 0x04
    178c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    178e:	eb 81       	ldd	r30, Y+3	; 0x03
    1790:	fc 81       	ldd	r31, Y+4	; 0x04
    1792:	10 82       	st	Z, r1
	pxTopOfStack--;
    1794:	8b 81       	ldd	r24, Y+3	; 0x03
    1796:	9c 81       	ldd	r25, Y+4	; 0x04
    1798:	01 97       	sbiw	r24, 0x01	; 1
    179a:	9c 83       	std	Y+4, r25	; 0x04
    179c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    179e:	eb 81       	ldd	r30, Y+3	; 0x03
    17a0:	fc 81       	ldd	r31, Y+4	; 0x04
    17a2:	82 e0       	ldi	r24, 0x02	; 2
    17a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    17a6:	8b 81       	ldd	r24, Y+3	; 0x03
    17a8:	9c 81       	ldd	r25, Y+4	; 0x04
    17aa:	01 97       	sbiw	r24, 0x01	; 1
    17ac:	9c 83       	std	Y+4, r25	; 0x04
    17ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    17b0:	eb 81       	ldd	r30, Y+3	; 0x03
    17b2:	fc 81       	ldd	r31, Y+4	; 0x04
    17b4:	83 e0       	ldi	r24, 0x03	; 3
    17b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    17b8:	8b 81       	ldd	r24, Y+3	; 0x03
    17ba:	9c 81       	ldd	r25, Y+4	; 0x04
    17bc:	01 97       	sbiw	r24, 0x01	; 1
    17be:	9c 83       	std	Y+4, r25	; 0x04
    17c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    17c2:	eb 81       	ldd	r30, Y+3	; 0x03
    17c4:	fc 81       	ldd	r31, Y+4	; 0x04
    17c6:	84 e0       	ldi	r24, 0x04	; 4
    17c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ca:	8b 81       	ldd	r24, Y+3	; 0x03
    17cc:	9c 81       	ldd	r25, Y+4	; 0x04
    17ce:	01 97       	sbiw	r24, 0x01	; 1
    17d0:	9c 83       	std	Y+4, r25	; 0x04
    17d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    17d4:	eb 81       	ldd	r30, Y+3	; 0x03
    17d6:	fc 81       	ldd	r31, Y+4	; 0x04
    17d8:	85 e0       	ldi	r24, 0x05	; 5
    17da:	80 83       	st	Z, r24
	pxTopOfStack--;
    17dc:	8b 81       	ldd	r24, Y+3	; 0x03
    17de:	9c 81       	ldd	r25, Y+4	; 0x04
    17e0:	01 97       	sbiw	r24, 0x01	; 1
    17e2:	9c 83       	std	Y+4, r25	; 0x04
    17e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    17e6:	eb 81       	ldd	r30, Y+3	; 0x03
    17e8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ea:	86 e0       	ldi	r24, 0x06	; 6
    17ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ee:	8b 81       	ldd	r24, Y+3	; 0x03
    17f0:	9c 81       	ldd	r25, Y+4	; 0x04
    17f2:	01 97       	sbiw	r24, 0x01	; 1
    17f4:	9c 83       	std	Y+4, r25	; 0x04
    17f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    17f8:	eb 81       	ldd	r30, Y+3	; 0x03
    17fa:	fc 81       	ldd	r31, Y+4	; 0x04
    17fc:	87 e0       	ldi	r24, 0x07	; 7
    17fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1800:	8b 81       	ldd	r24, Y+3	; 0x03
    1802:	9c 81       	ldd	r25, Y+4	; 0x04
    1804:	01 97       	sbiw	r24, 0x01	; 1
    1806:	9c 83       	std	Y+4, r25	; 0x04
    1808:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    180a:	eb 81       	ldd	r30, Y+3	; 0x03
    180c:	fc 81       	ldd	r31, Y+4	; 0x04
    180e:	88 e0       	ldi	r24, 0x08	; 8
    1810:	80 83       	st	Z, r24
	pxTopOfStack--;
    1812:	8b 81       	ldd	r24, Y+3	; 0x03
    1814:	9c 81       	ldd	r25, Y+4	; 0x04
    1816:	01 97       	sbiw	r24, 0x01	; 1
    1818:	9c 83       	std	Y+4, r25	; 0x04
    181a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    181c:	eb 81       	ldd	r30, Y+3	; 0x03
    181e:	fc 81       	ldd	r31, Y+4	; 0x04
    1820:	89 e0       	ldi	r24, 0x09	; 9
    1822:	80 83       	st	Z, r24
	pxTopOfStack--;
    1824:	8b 81       	ldd	r24, Y+3	; 0x03
    1826:	9c 81       	ldd	r25, Y+4	; 0x04
    1828:	01 97       	sbiw	r24, 0x01	; 1
    182a:	9c 83       	std	Y+4, r25	; 0x04
    182c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    182e:	eb 81       	ldd	r30, Y+3	; 0x03
    1830:	fc 81       	ldd	r31, Y+4	; 0x04
    1832:	80 e1       	ldi	r24, 0x10	; 16
    1834:	80 83       	st	Z, r24
	pxTopOfStack--;
    1836:	8b 81       	ldd	r24, Y+3	; 0x03
    1838:	9c 81       	ldd	r25, Y+4	; 0x04
    183a:	01 97       	sbiw	r24, 0x01	; 1
    183c:	9c 83       	std	Y+4, r25	; 0x04
    183e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1840:	eb 81       	ldd	r30, Y+3	; 0x03
    1842:	fc 81       	ldd	r31, Y+4	; 0x04
    1844:	81 e1       	ldi	r24, 0x11	; 17
    1846:	80 83       	st	Z, r24
	pxTopOfStack--;
    1848:	8b 81       	ldd	r24, Y+3	; 0x03
    184a:	9c 81       	ldd	r25, Y+4	; 0x04
    184c:	01 97       	sbiw	r24, 0x01	; 1
    184e:	9c 83       	std	Y+4, r25	; 0x04
    1850:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1852:	eb 81       	ldd	r30, Y+3	; 0x03
    1854:	fc 81       	ldd	r31, Y+4	; 0x04
    1856:	82 e1       	ldi	r24, 0x12	; 18
    1858:	80 83       	st	Z, r24
	pxTopOfStack--;
    185a:	8b 81       	ldd	r24, Y+3	; 0x03
    185c:	9c 81       	ldd	r25, Y+4	; 0x04
    185e:	01 97       	sbiw	r24, 0x01	; 1
    1860:	9c 83       	std	Y+4, r25	; 0x04
    1862:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1864:	eb 81       	ldd	r30, Y+3	; 0x03
    1866:	fc 81       	ldd	r31, Y+4	; 0x04
    1868:	83 e1       	ldi	r24, 0x13	; 19
    186a:	80 83       	st	Z, r24
	pxTopOfStack--;
    186c:	8b 81       	ldd	r24, Y+3	; 0x03
    186e:	9c 81       	ldd	r25, Y+4	; 0x04
    1870:	01 97       	sbiw	r24, 0x01	; 1
    1872:	9c 83       	std	Y+4, r25	; 0x04
    1874:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1876:	eb 81       	ldd	r30, Y+3	; 0x03
    1878:	fc 81       	ldd	r31, Y+4	; 0x04
    187a:	84 e1       	ldi	r24, 0x14	; 20
    187c:	80 83       	st	Z, r24
	pxTopOfStack--;
    187e:	8b 81       	ldd	r24, Y+3	; 0x03
    1880:	9c 81       	ldd	r25, Y+4	; 0x04
    1882:	01 97       	sbiw	r24, 0x01	; 1
    1884:	9c 83       	std	Y+4, r25	; 0x04
    1886:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1888:	eb 81       	ldd	r30, Y+3	; 0x03
    188a:	fc 81       	ldd	r31, Y+4	; 0x04
    188c:	85 e1       	ldi	r24, 0x15	; 21
    188e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1890:	8b 81       	ldd	r24, Y+3	; 0x03
    1892:	9c 81       	ldd	r25, Y+4	; 0x04
    1894:	01 97       	sbiw	r24, 0x01	; 1
    1896:	9c 83       	std	Y+4, r25	; 0x04
    1898:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    189a:	eb 81       	ldd	r30, Y+3	; 0x03
    189c:	fc 81       	ldd	r31, Y+4	; 0x04
    189e:	86 e1       	ldi	r24, 0x16	; 22
    18a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a2:	8b 81       	ldd	r24, Y+3	; 0x03
    18a4:	9c 81       	ldd	r25, Y+4	; 0x04
    18a6:	01 97       	sbiw	r24, 0x01	; 1
    18a8:	9c 83       	std	Y+4, r25	; 0x04
    18aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    18ac:	eb 81       	ldd	r30, Y+3	; 0x03
    18ae:	fc 81       	ldd	r31, Y+4	; 0x04
    18b0:	87 e1       	ldi	r24, 0x17	; 23
    18b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    18b4:	8b 81       	ldd	r24, Y+3	; 0x03
    18b6:	9c 81       	ldd	r25, Y+4	; 0x04
    18b8:	01 97       	sbiw	r24, 0x01	; 1
    18ba:	9c 83       	std	Y+4, r25	; 0x04
    18bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    18be:	eb 81       	ldd	r30, Y+3	; 0x03
    18c0:	fc 81       	ldd	r31, Y+4	; 0x04
    18c2:	88 e1       	ldi	r24, 0x18	; 24
    18c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ca:	01 97       	sbiw	r24, 0x01	; 1
    18cc:	9c 83       	std	Y+4, r25	; 0x04
    18ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    18d0:	eb 81       	ldd	r30, Y+3	; 0x03
    18d2:	fc 81       	ldd	r31, Y+4	; 0x04
    18d4:	89 e1       	ldi	r24, 0x19	; 25
    18d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18d8:	8b 81       	ldd	r24, Y+3	; 0x03
    18da:	9c 81       	ldd	r25, Y+4	; 0x04
    18dc:	01 97       	sbiw	r24, 0x01	; 1
    18de:	9c 83       	std	Y+4, r25	; 0x04
    18e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    18e2:	eb 81       	ldd	r30, Y+3	; 0x03
    18e4:	fc 81       	ldd	r31, Y+4	; 0x04
    18e6:	80 e2       	ldi	r24, 0x20	; 32
    18e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ea:	8b 81       	ldd	r24, Y+3	; 0x03
    18ec:	9c 81       	ldd	r25, Y+4	; 0x04
    18ee:	01 97       	sbiw	r24, 0x01	; 1
    18f0:	9c 83       	std	Y+4, r25	; 0x04
    18f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    18f4:	eb 81       	ldd	r30, Y+3	; 0x03
    18f6:	fc 81       	ldd	r31, Y+4	; 0x04
    18f8:	81 e2       	ldi	r24, 0x21	; 33
    18fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    18fc:	8b 81       	ldd	r24, Y+3	; 0x03
    18fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1900:	01 97       	sbiw	r24, 0x01	; 1
    1902:	9c 83       	std	Y+4, r25	; 0x04
    1904:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1906:	eb 81       	ldd	r30, Y+3	; 0x03
    1908:	fc 81       	ldd	r31, Y+4	; 0x04
    190a:	82 e2       	ldi	r24, 0x22	; 34
    190c:	80 83       	st	Z, r24
	pxTopOfStack--;
    190e:	8b 81       	ldd	r24, Y+3	; 0x03
    1910:	9c 81       	ldd	r25, Y+4	; 0x04
    1912:	01 97       	sbiw	r24, 0x01	; 1
    1914:	9c 83       	std	Y+4, r25	; 0x04
    1916:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1918:	eb 81       	ldd	r30, Y+3	; 0x03
    191a:	fc 81       	ldd	r31, Y+4	; 0x04
    191c:	83 e2       	ldi	r24, 0x23	; 35
    191e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1920:	8b 81       	ldd	r24, Y+3	; 0x03
    1922:	9c 81       	ldd	r25, Y+4	; 0x04
    1924:	01 97       	sbiw	r24, 0x01	; 1
    1926:	9c 83       	std	Y+4, r25	; 0x04
    1928:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    192a:	8f 81       	ldd	r24, Y+7	; 0x07
    192c:	98 85       	ldd	r25, Y+8	; 0x08
    192e:	9a 83       	std	Y+2, r25	; 0x02
    1930:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1932:	89 81       	ldd	r24, Y+1	; 0x01
    1934:	eb 81       	ldd	r30, Y+3	; 0x03
    1936:	fc 81       	ldd	r31, Y+4	; 0x04
    1938:	80 83       	st	Z, r24
	pxTopOfStack--;
    193a:	8b 81       	ldd	r24, Y+3	; 0x03
    193c:	9c 81       	ldd	r25, Y+4	; 0x04
    193e:	01 97       	sbiw	r24, 0x01	; 1
    1940:	9c 83       	std	Y+4, r25	; 0x04
    1942:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1944:	89 81       	ldd	r24, Y+1	; 0x01
    1946:	9a 81       	ldd	r25, Y+2	; 0x02
    1948:	89 2f       	mov	r24, r25
    194a:	99 27       	eor	r25, r25
    194c:	9a 83       	std	Y+2, r25	; 0x02
    194e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1950:	89 81       	ldd	r24, Y+1	; 0x01
    1952:	eb 81       	ldd	r30, Y+3	; 0x03
    1954:	fc 81       	ldd	r31, Y+4	; 0x04
    1956:	80 83       	st	Z, r24
	pxTopOfStack--;
    1958:	8b 81       	ldd	r24, Y+3	; 0x03
    195a:	9c 81       	ldd	r25, Y+4	; 0x04
    195c:	01 97       	sbiw	r24, 0x01	; 1
    195e:	9c 83       	std	Y+4, r25	; 0x04
    1960:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1962:	eb 81       	ldd	r30, Y+3	; 0x03
    1964:	fc 81       	ldd	r31, Y+4	; 0x04
    1966:	86 e2       	ldi	r24, 0x26	; 38
    1968:	80 83       	st	Z, r24
	pxTopOfStack--;
    196a:	8b 81       	ldd	r24, Y+3	; 0x03
    196c:	9c 81       	ldd	r25, Y+4	; 0x04
    196e:	01 97       	sbiw	r24, 0x01	; 1
    1970:	9c 83       	std	Y+4, r25	; 0x04
    1972:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1974:	eb 81       	ldd	r30, Y+3	; 0x03
    1976:	fc 81       	ldd	r31, Y+4	; 0x04
    1978:	87 e2       	ldi	r24, 0x27	; 39
    197a:	80 83       	st	Z, r24
	pxTopOfStack--;
    197c:	8b 81       	ldd	r24, Y+3	; 0x03
    197e:	9c 81       	ldd	r25, Y+4	; 0x04
    1980:	01 97       	sbiw	r24, 0x01	; 1
    1982:	9c 83       	std	Y+4, r25	; 0x04
    1984:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1986:	eb 81       	ldd	r30, Y+3	; 0x03
    1988:	fc 81       	ldd	r31, Y+4	; 0x04
    198a:	88 e2       	ldi	r24, 0x28	; 40
    198c:	80 83       	st	Z, r24
	pxTopOfStack--;
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	9c 81       	ldd	r25, Y+4	; 0x04
    1992:	01 97       	sbiw	r24, 0x01	; 1
    1994:	9c 83       	std	Y+4, r25	; 0x04
    1996:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1998:	eb 81       	ldd	r30, Y+3	; 0x03
    199a:	fc 81       	ldd	r31, Y+4	; 0x04
    199c:	89 e2       	ldi	r24, 0x29	; 41
    199e:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a0:	8b 81       	ldd	r24, Y+3	; 0x03
    19a2:	9c 81       	ldd	r25, Y+4	; 0x04
    19a4:	01 97       	sbiw	r24, 0x01	; 1
    19a6:	9c 83       	std	Y+4, r25	; 0x04
    19a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    19aa:	eb 81       	ldd	r30, Y+3	; 0x03
    19ac:	fc 81       	ldd	r31, Y+4	; 0x04
    19ae:	80 e3       	ldi	r24, 0x30	; 48
    19b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	9c 81       	ldd	r25, Y+4	; 0x04
    19b6:	01 97       	sbiw	r24, 0x01	; 1
    19b8:	9c 83       	std	Y+4, r25	; 0x04
    19ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    19bc:	eb 81       	ldd	r30, Y+3	; 0x03
    19be:	fc 81       	ldd	r31, Y+4	; 0x04
    19c0:	81 e3       	ldi	r24, 0x31	; 49
    19c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    19c4:	8b 81       	ldd	r24, Y+3	; 0x03
    19c6:	9c 81       	ldd	r25, Y+4	; 0x04
    19c8:	01 97       	sbiw	r24, 0x01	; 1
    19ca:	9c 83       	std	Y+4, r25	; 0x04
    19cc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    19ce:	8b 81       	ldd	r24, Y+3	; 0x03
    19d0:	9c 81       	ldd	r25, Y+4	; 0x04
}
    19d2:	28 96       	adiw	r28, 0x08	; 8
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	de bf       	out	0x3e, r29	; 62
    19da:	0f be       	out	0x3f, r0	; 63
    19dc:	cd bf       	out	0x3d, r28	; 61
    19de:	cf 91       	pop	r28
    19e0:	df 91       	pop	r29
    19e2:	08 95       	ret

000019e4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    19e4:	df 93       	push	r29
    19e6:	cf 93       	push	r28
    19e8:	cd b7       	in	r28, 0x3d	; 61
    19ea:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    19ec:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    19f0:	a0 91 ba 06 	lds	r26, 0x06BA
    19f4:	b0 91 bb 06 	lds	r27, 0x06BB
    19f8:	cd 91       	ld	r28, X+
    19fa:	cd bf       	out	0x3d, r28	; 61
    19fc:	dd 91       	ld	r29, X+
    19fe:	de bf       	out	0x3e, r29	; 62
    1a00:	ff 91       	pop	r31
    1a02:	ef 91       	pop	r30
    1a04:	df 91       	pop	r29
    1a06:	cf 91       	pop	r28
    1a08:	bf 91       	pop	r27
    1a0a:	af 91       	pop	r26
    1a0c:	9f 91       	pop	r25
    1a0e:	8f 91       	pop	r24
    1a10:	7f 91       	pop	r23
    1a12:	6f 91       	pop	r22
    1a14:	5f 91       	pop	r21
    1a16:	4f 91       	pop	r20
    1a18:	3f 91       	pop	r19
    1a1a:	2f 91       	pop	r18
    1a1c:	1f 91       	pop	r17
    1a1e:	0f 91       	pop	r16
    1a20:	ff 90       	pop	r15
    1a22:	ef 90       	pop	r14
    1a24:	df 90       	pop	r13
    1a26:	cf 90       	pop	r12
    1a28:	bf 90       	pop	r11
    1a2a:	af 90       	pop	r10
    1a2c:	9f 90       	pop	r9
    1a2e:	8f 90       	pop	r8
    1a30:	7f 90       	pop	r7
    1a32:	6f 90       	pop	r6
    1a34:	5f 90       	pop	r5
    1a36:	4f 90       	pop	r4
    1a38:	3f 90       	pop	r3
    1a3a:	2f 90       	pop	r2
    1a3c:	1f 90       	pop	r1
    1a3e:	0f 90       	pop	r0
    1a40:	0f be       	out	0x3f, r0	; 63
    1a42:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a44:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1a46:	81 e0       	ldi	r24, 0x01	; 1
}
    1a48:	cf 91       	pop	r28
    1a4a:	df 91       	pop	r29
    1a4c:	08 95       	ret

00001a4e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a4e:	df 93       	push	r29
    1a50:	cf 93       	push	r28
    1a52:	cd b7       	in	r28, 0x3d	; 61
    1a54:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1a56:	cf 91       	pop	r28
    1a58:	df 91       	pop	r29
    1a5a:	08 95       	ret

00001a5c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1a5c:	0f 92       	push	r0
    1a5e:	0f b6       	in	r0, 0x3f	; 63
    1a60:	f8 94       	cli
    1a62:	0f 92       	push	r0
    1a64:	1f 92       	push	r1
    1a66:	11 24       	eor	r1, r1
    1a68:	2f 92       	push	r2
    1a6a:	3f 92       	push	r3
    1a6c:	4f 92       	push	r4
    1a6e:	5f 92       	push	r5
    1a70:	6f 92       	push	r6
    1a72:	7f 92       	push	r7
    1a74:	8f 92       	push	r8
    1a76:	9f 92       	push	r9
    1a78:	af 92       	push	r10
    1a7a:	bf 92       	push	r11
    1a7c:	cf 92       	push	r12
    1a7e:	df 92       	push	r13
    1a80:	ef 92       	push	r14
    1a82:	ff 92       	push	r15
    1a84:	0f 93       	push	r16
    1a86:	1f 93       	push	r17
    1a88:	2f 93       	push	r18
    1a8a:	3f 93       	push	r19
    1a8c:	4f 93       	push	r20
    1a8e:	5f 93       	push	r21
    1a90:	6f 93       	push	r22
    1a92:	7f 93       	push	r23
    1a94:	8f 93       	push	r24
    1a96:	9f 93       	push	r25
    1a98:	af 93       	push	r26
    1a9a:	bf 93       	push	r27
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
    1aa0:	ef 93       	push	r30
    1aa2:	ff 93       	push	r31
    1aa4:	a0 91 ba 06 	lds	r26, 0x06BA
    1aa8:	b0 91 bb 06 	lds	r27, 0x06BB
    1aac:	0d b6       	in	r0, 0x3d	; 61
    1aae:	0d 92       	st	X+, r0
    1ab0:	0e b6       	in	r0, 0x3e	; 62
    1ab2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1ab4:	0e 94 c5 22 	call	0x458a	; 0x458a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1ab8:	a0 91 ba 06 	lds	r26, 0x06BA
    1abc:	b0 91 bb 06 	lds	r27, 0x06BB
    1ac0:	cd 91       	ld	r28, X+
    1ac2:	cd bf       	out	0x3d, r28	; 61
    1ac4:	dd 91       	ld	r29, X+
    1ac6:	de bf       	out	0x3e, r29	; 62
    1ac8:	ff 91       	pop	r31
    1aca:	ef 91       	pop	r30
    1acc:	df 91       	pop	r29
    1ace:	cf 91       	pop	r28
    1ad0:	bf 91       	pop	r27
    1ad2:	af 91       	pop	r26
    1ad4:	9f 91       	pop	r25
    1ad6:	8f 91       	pop	r24
    1ad8:	7f 91       	pop	r23
    1ada:	6f 91       	pop	r22
    1adc:	5f 91       	pop	r21
    1ade:	4f 91       	pop	r20
    1ae0:	3f 91       	pop	r19
    1ae2:	2f 91       	pop	r18
    1ae4:	1f 91       	pop	r17
    1ae6:	0f 91       	pop	r16
    1ae8:	ff 90       	pop	r15
    1aea:	ef 90       	pop	r14
    1aec:	df 90       	pop	r13
    1aee:	cf 90       	pop	r12
    1af0:	bf 90       	pop	r11
    1af2:	af 90       	pop	r10
    1af4:	9f 90       	pop	r9
    1af6:	8f 90       	pop	r8
    1af8:	7f 90       	pop	r7
    1afa:	6f 90       	pop	r6
    1afc:	5f 90       	pop	r5
    1afe:	4f 90       	pop	r4
    1b00:	3f 90       	pop	r3
    1b02:	2f 90       	pop	r2
    1b04:	1f 90       	pop	r1
    1b06:	0f 90       	pop	r0
    1b08:	0f be       	out	0x3f, r0	; 63
    1b0a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b0c:	08 95       	ret

00001b0e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b0e:	0f 92       	push	r0
    1b10:	0f b6       	in	r0, 0x3f	; 63
    1b12:	f8 94       	cli
    1b14:	0f 92       	push	r0
    1b16:	1f 92       	push	r1
    1b18:	11 24       	eor	r1, r1
    1b1a:	2f 92       	push	r2
    1b1c:	3f 92       	push	r3
    1b1e:	4f 92       	push	r4
    1b20:	5f 92       	push	r5
    1b22:	6f 92       	push	r6
    1b24:	7f 92       	push	r7
    1b26:	8f 92       	push	r8
    1b28:	9f 92       	push	r9
    1b2a:	af 92       	push	r10
    1b2c:	bf 92       	push	r11
    1b2e:	cf 92       	push	r12
    1b30:	df 92       	push	r13
    1b32:	ef 92       	push	r14
    1b34:	ff 92       	push	r15
    1b36:	0f 93       	push	r16
    1b38:	1f 93       	push	r17
    1b3a:	2f 93       	push	r18
    1b3c:	3f 93       	push	r19
    1b3e:	4f 93       	push	r20
    1b40:	5f 93       	push	r21
    1b42:	6f 93       	push	r22
    1b44:	7f 93       	push	r23
    1b46:	8f 93       	push	r24
    1b48:	9f 93       	push	r25
    1b4a:	af 93       	push	r26
    1b4c:	bf 93       	push	r27
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	ef 93       	push	r30
    1b54:	ff 93       	push	r31
    1b56:	a0 91 ba 06 	lds	r26, 0x06BA
    1b5a:	b0 91 bb 06 	lds	r27, 0x06BB
    1b5e:	0d b6       	in	r0, 0x3d	; 61
    1b60:	0d 92       	st	X+, r0
    1b62:	0e b6       	in	r0, 0x3e	; 62
    1b64:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1b66:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <xTaskIncrementTick>
    1b6a:	88 23       	and	r24, r24
    1b6c:	11 f0       	breq	.+4      	; 0x1b72 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1b6e:	0e 94 c5 22 	call	0x458a	; 0x458a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1b72:	a0 91 ba 06 	lds	r26, 0x06BA
    1b76:	b0 91 bb 06 	lds	r27, 0x06BB
    1b7a:	cd 91       	ld	r28, X+
    1b7c:	cd bf       	out	0x3d, r28	; 61
    1b7e:	dd 91       	ld	r29, X+
    1b80:	de bf       	out	0x3e, r29	; 62
    1b82:	ff 91       	pop	r31
    1b84:	ef 91       	pop	r30
    1b86:	df 91       	pop	r29
    1b88:	cf 91       	pop	r28
    1b8a:	bf 91       	pop	r27
    1b8c:	af 91       	pop	r26
    1b8e:	9f 91       	pop	r25
    1b90:	8f 91       	pop	r24
    1b92:	7f 91       	pop	r23
    1b94:	6f 91       	pop	r22
    1b96:	5f 91       	pop	r21
    1b98:	4f 91       	pop	r20
    1b9a:	3f 91       	pop	r19
    1b9c:	2f 91       	pop	r18
    1b9e:	1f 91       	pop	r17
    1ba0:	0f 91       	pop	r16
    1ba2:	ff 90       	pop	r15
    1ba4:	ef 90       	pop	r14
    1ba6:	df 90       	pop	r13
    1ba8:	cf 90       	pop	r12
    1baa:	bf 90       	pop	r11
    1bac:	af 90       	pop	r10
    1bae:	9f 90       	pop	r9
    1bb0:	8f 90       	pop	r8
    1bb2:	7f 90       	pop	r7
    1bb4:	6f 90       	pop	r6
    1bb6:	5f 90       	pop	r5
    1bb8:	4f 90       	pop	r4
    1bba:	3f 90       	pop	r3
    1bbc:	2f 90       	pop	r2
    1bbe:	1f 90       	pop	r1
    1bc0:	0f 90       	pop	r0
    1bc2:	0f be       	out	0x3f, r0	; 63
    1bc4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1bc6:	08 95       	ret

00001bc8 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1bc8:	df 93       	push	r29
    1bca:	cf 93       	push	r28
    1bcc:	00 d0       	rcall	.+0      	; 0x1bce <prvSetupTimerInterrupt+0x6>
    1bce:	00 d0       	rcall	.+0      	; 0x1bd0 <prvSetupTimerInterrupt+0x8>
    1bd0:	00 d0       	rcall	.+0      	; 0x1bd2 <prvSetupTimerInterrupt+0xa>
    1bd2:	cd b7       	in	r28, 0x3d	; 61
    1bd4:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1bd6:	80 e4       	ldi	r24, 0x40	; 64
    1bd8:	9f e1       	ldi	r25, 0x1F	; 31
    1bda:	a0 e0       	ldi	r26, 0x00	; 0
    1bdc:	b0 e0       	ldi	r27, 0x00	; 0
    1bde:	8b 83       	std	Y+3, r24	; 0x03
    1be0:	9c 83       	std	Y+4, r25	; 0x04
    1be2:	ad 83       	std	Y+5, r26	; 0x05
    1be4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1be6:	8b 81       	ldd	r24, Y+3	; 0x03
    1be8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bea:	ad 81       	ldd	r26, Y+5	; 0x05
    1bec:	be 81       	ldd	r27, Y+6	; 0x06
    1bee:	68 94       	set
    1bf0:	15 f8       	bld	r1, 5
    1bf2:	b6 95       	lsr	r27
    1bf4:	a7 95       	ror	r26
    1bf6:	97 95       	ror	r25
    1bf8:	87 95       	ror	r24
    1bfa:	16 94       	lsr	r1
    1bfc:	d1 f7       	brne	.-12     	; 0x1bf2 <prvSetupTimerInterrupt+0x2a>
    1bfe:	8b 83       	std	Y+3, r24	; 0x03
    1c00:	9c 83       	std	Y+4, r25	; 0x04
    1c02:	ad 83       	std	Y+5, r26	; 0x05
    1c04:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1c06:	8b 81       	ldd	r24, Y+3	; 0x03
    1c08:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0a:	ad 81       	ldd	r26, Y+5	; 0x05
    1c0c:	be 81       	ldd	r27, Y+6	; 0x06
    1c0e:	01 97       	sbiw	r24, 0x01	; 1
    1c10:	a1 09       	sbc	r26, r1
    1c12:	b1 09       	sbc	r27, r1
    1c14:	8b 83       	std	Y+3, r24	; 0x03
    1c16:	9c 83       	std	Y+4, r25	; 0x04
    1c18:	ad 83       	std	Y+5, r26	; 0x05
    1c1a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1c20:	8b 81       	ldd	r24, Y+3	; 0x03
    1c22:	9c 81       	ldd	r25, Y+4	; 0x04
    1c24:	ad 81       	ldd	r26, Y+5	; 0x05
    1c26:	be 81       	ldd	r27, Y+6	; 0x06
    1c28:	89 2f       	mov	r24, r25
    1c2a:	9a 2f       	mov	r25, r26
    1c2c:	ab 2f       	mov	r26, r27
    1c2e:	bb 27       	eor	r27, r27
    1c30:	8b 83       	std	Y+3, r24	; 0x03
    1c32:	9c 83       	std	Y+4, r25	; 0x04
    1c34:	ad 83       	std	Y+5, r26	; 0x05
    1c36:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c38:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1c3c:	eb e4       	ldi	r30, 0x4B	; 75
    1c3e:	f0 e0       	ldi	r31, 0x00	; 0
    1c40:	8a 81       	ldd	r24, Y+2	; 0x02
    1c42:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1c44:	ea e4       	ldi	r30, 0x4A	; 74
    1c46:	f0 e0       	ldi	r31, 0x00	; 0
    1c48:	89 81       	ldd	r24, Y+1	; 0x01
    1c4a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1c4c:	8b e0       	ldi	r24, 0x0B	; 11
    1c4e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1c50:	ee e4       	ldi	r30, 0x4E	; 78
    1c52:	f0 e0       	ldi	r31, 0x00	; 0
    1c54:	89 81       	ldd	r24, Y+1	; 0x01
    1c56:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1c58:	e9 e5       	ldi	r30, 0x59	; 89
    1c5a:	f0 e0       	ldi	r31, 0x00	; 0
    1c5c:	80 81       	ld	r24, Z
    1c5e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1c60:	89 81       	ldd	r24, Y+1	; 0x01
    1c62:	80 61       	ori	r24, 0x10	; 16
    1c64:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1c66:	e9 e5       	ldi	r30, 0x59	; 89
    1c68:	f0 e0       	ldi	r31, 0x00	; 0
    1c6a:	89 81       	ldd	r24, Y+1	; 0x01
    1c6c:	80 83       	st	Z, r24
}
    1c6e:	26 96       	adiw	r28, 0x06	; 6
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	de bf       	out	0x3e, r29	; 62
    1c76:	0f be       	out	0x3f, r0	; 63
    1c78:	cd bf       	out	0x3d, r28	; 61
    1c7a:	cf 91       	pop	r28
    1c7c:	df 91       	pop	r29
    1c7e:	08 95       	ret

00001c80 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1c80:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vPortYieldFromTick>
		asm volatile ( "reti" );
    1c84:	18 95       	reti

00001c86 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1c86:	df 93       	push	r29
    1c88:	cf 93       	push	r28
    1c8a:	00 d0       	rcall	.+0      	; 0x1c8c <xQueueGenericReset+0x6>
    1c8c:	00 d0       	rcall	.+0      	; 0x1c8e <xQueueGenericReset+0x8>
    1c8e:	0f 92       	push	r0
    1c90:	cd b7       	in	r28, 0x3d	; 61
    1c92:	de b7       	in	r29, 0x3e	; 62
    1c94:	9c 83       	std	Y+4, r25	; 0x04
    1c96:	8b 83       	std	Y+3, r24	; 0x03
    1c98:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c9e:	9a 83       	std	Y+2, r25	; 0x02
    1ca0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1ca8:	e9 81       	ldd	r30, Y+1	; 0x01
    1caa:	fa 81       	ldd	r31, Y+2	; 0x02
    1cac:	40 81       	ld	r20, Z
    1cae:	51 81       	ldd	r21, Z+1	; 0x01
    1cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb4:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cb6:	28 2f       	mov	r18, r24
    1cb8:	30 e0       	ldi	r19, 0x00	; 0
    1cba:	e9 81       	ldd	r30, Y+1	; 0x01
    1cbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cbe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cc0:	88 2f       	mov	r24, r24
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	bc 01       	movw	r22, r24
    1cc6:	26 9f       	mul	r18, r22
    1cc8:	c0 01       	movw	r24, r0
    1cca:	27 9f       	mul	r18, r23
    1ccc:	90 0d       	add	r25, r0
    1cce:	36 9f       	mul	r19, r22
    1cd0:	90 0d       	add	r25, r0
    1cd2:	11 24       	eor	r1, r1
    1cd4:	84 0f       	add	r24, r20
    1cd6:	95 1f       	adc	r25, r21
    1cd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1cda:	fa 81       	ldd	r31, Y+2	; 0x02
    1cdc:	95 83       	std	Z+5, r25	; 0x05
    1cde:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce4:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cea:	80 81       	ld	r24, Z
    1cec:	91 81       	ldd	r25, Z+1	; 0x01
    1cee:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf2:	93 83       	std	Z+3, r25	; 0x03
    1cf4:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1cf6:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfa:	40 81       	ld	r20, Z
    1cfc:	51 81       	ldd	r21, Z+1	; 0x01
    1cfe:	e9 81       	ldd	r30, Y+1	; 0x01
    1d00:	fa 81       	ldd	r31, Y+2	; 0x02
    1d02:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d04:	88 2f       	mov	r24, r24
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	9c 01       	movw	r18, r24
    1d0a:	21 50       	subi	r18, 0x01	; 1
    1d0c:	30 40       	sbci	r19, 0x00	; 0
    1d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d10:	fa 81       	ldd	r31, Y+2	; 0x02
    1d12:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d14:	88 2f       	mov	r24, r24
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	bc 01       	movw	r22, r24
    1d1a:	26 9f       	mul	r18, r22
    1d1c:	c0 01       	movw	r24, r0
    1d1e:	27 9f       	mul	r18, r23
    1d20:	90 0d       	add	r25, r0
    1d22:	36 9f       	mul	r19, r22
    1d24:	90 0d       	add	r25, r0
    1d26:	11 24       	eor	r1, r1
    1d28:	84 0f       	add	r24, r20
    1d2a:	95 1f       	adc	r25, r21
    1d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d30:	97 83       	std	Z+7, r25	; 0x07
    1d32:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1d34:	e9 81       	ldd	r30, Y+1	; 0x01
    1d36:	fa 81       	ldd	r31, Y+2	; 0x02
    1d38:	8f ef       	ldi	r24, 0xFF	; 255
    1d3a:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d40:	8f ef       	ldi	r24, 0xFF	; 255
    1d42:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1d44:	8d 81       	ldd	r24, Y+5	; 0x05
    1d46:	88 23       	and	r24, r24
    1d48:	79 f4       	brne	.+30     	; 0x1d68 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4e:	80 85       	ldd	r24, Z+8	; 0x08
    1d50:	88 23       	and	r24, r24
    1d52:	a1 f0       	breq	.+40     	; 0x1d7c <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	9a 81       	ldd	r25, Y+2	; 0x02
    1d58:	08 96       	adiw	r24, 0x08	; 8
    1d5a:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    1d5e:	88 23       	and	r24, r24
    1d60:	69 f0       	breq	.+26     	; 0x1d7c <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1d62:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    1d66:	0a c0       	rjmp	.+20     	; 0x1d7c <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1d68:	89 81       	ldd	r24, Y+1	; 0x01
    1d6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d6c:	08 96       	adiw	r24, 0x08	; 8
    1d6e:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1d72:	89 81       	ldd	r24, Y+1	; 0x01
    1d74:	9a 81       	ldd	r25, Y+2	; 0x02
    1d76:	41 96       	adiw	r24, 0x11	; 17
    1d78:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1d7c:	0f 90       	pop	r0
    1d7e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1d80:	81 e0       	ldi	r24, 0x01	; 1
}
    1d82:	0f 90       	pop	r0
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	cf 91       	pop	r28
    1d8e:	df 91       	pop	r29
    1d90:	08 95       	ret

00001d92 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1d92:	0f 93       	push	r16
    1d94:	1f 93       	push	r17
    1d96:	df 93       	push	r29
    1d98:	cf 93       	push	r28
    1d9a:	cd b7       	in	r28, 0x3d	; 61
    1d9c:	de b7       	in	r29, 0x3e	; 62
    1d9e:	29 97       	sbiw	r28, 0x09	; 9
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	de bf       	out	0x3e, r29	; 62
    1da6:	0f be       	out	0x3f, r0	; 63
    1da8:	cd bf       	out	0x3d, r28	; 61
    1daa:	8f 83       	std	Y+7, r24	; 0x07
    1dac:	68 87       	std	Y+8, r22	; 0x08
    1dae:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1db0:	88 85       	ldd	r24, Y+8	; 0x08
    1db2:	88 23       	and	r24, r24
    1db4:	19 f4       	brne	.+6      	; 0x1dbc <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1db6:	1c 82       	std	Y+4, r1	; 0x04
    1db8:	1b 82       	std	Y+3, r1	; 0x03
    1dba:	10 c0       	rjmp	.+32     	; 0x1ddc <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dbc:	8f 81       	ldd	r24, Y+7	; 0x07
    1dbe:	28 2f       	mov	r18, r24
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	88 85       	ldd	r24, Y+8	; 0x08
    1dc4:	88 2f       	mov	r24, r24
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	ac 01       	movw	r20, r24
    1dca:	24 9f       	mul	r18, r20
    1dcc:	c0 01       	movw	r24, r0
    1dce:	25 9f       	mul	r18, r21
    1dd0:	90 0d       	add	r25, r0
    1dd2:	34 9f       	mul	r19, r20
    1dd4:	90 0d       	add	r25, r0
    1dd6:	11 24       	eor	r1, r1
    1dd8:	9c 83       	std	Y+4, r25	; 0x04
    1dda:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dde:	9c 81       	ldd	r25, Y+4	; 0x04
    1de0:	4f 96       	adiw	r24, 0x1f	; 31
    1de2:	0e 94 1b 08 	call	0x1036	; 0x1036 <pvPortMalloc>
    1de6:	9e 83       	std	Y+6, r25	; 0x06
    1de8:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1dea:	8d 81       	ldd	r24, Y+5	; 0x05
    1dec:	9e 81       	ldd	r25, Y+6	; 0x06
    1dee:	00 97       	sbiw	r24, 0x00	; 0
    1df0:	a1 f0       	breq	.+40     	; 0x1e1a <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1df2:	8d 81       	ldd	r24, Y+5	; 0x05
    1df4:	9e 81       	ldd	r25, Y+6	; 0x06
    1df6:	9a 83       	std	Y+2, r25	; 0x02
    1df8:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1dfa:	89 81       	ldd	r24, Y+1	; 0x01
    1dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dfe:	4f 96       	adiw	r24, 0x1f	; 31
    1e00:	9a 83       	std	Y+2, r25	; 0x02
    1e02:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1e04:	29 81       	ldd	r18, Y+1	; 0x01
    1e06:	3a 81       	ldd	r19, Y+2	; 0x02
    1e08:	ed 81       	ldd	r30, Y+5	; 0x05
    1e0a:	fe 81       	ldd	r31, Y+6	; 0x06
    1e0c:	8f 81       	ldd	r24, Y+7	; 0x07
    1e0e:	68 85       	ldd	r22, Y+8	; 0x08
    1e10:	a9 01       	movw	r20, r18
    1e12:	29 85       	ldd	r18, Y+9	; 0x09
    1e14:	8f 01       	movw	r16, r30
    1e16:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1e1a:	8d 81       	ldd	r24, Y+5	; 0x05
    1e1c:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1e1e:	29 96       	adiw	r28, 0x09	; 9
    1e20:	0f b6       	in	r0, 0x3f	; 63
    1e22:	f8 94       	cli
    1e24:	de bf       	out	0x3e, r29	; 62
    1e26:	0f be       	out	0x3f, r0	; 63
    1e28:	cd bf       	out	0x3d, r28	; 61
    1e2a:	cf 91       	pop	r28
    1e2c:	df 91       	pop	r29
    1e2e:	1f 91       	pop	r17
    1e30:	0f 91       	pop	r16
    1e32:	08 95       	ret

00001e34 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1e34:	0f 93       	push	r16
    1e36:	1f 93       	push	r17
    1e38:	df 93       	push	r29
    1e3a:	cf 93       	push	r28
    1e3c:	cd b7       	in	r28, 0x3d	; 61
    1e3e:	de b7       	in	r29, 0x3e	; 62
    1e40:	27 97       	sbiw	r28, 0x07	; 7
    1e42:	0f b6       	in	r0, 0x3f	; 63
    1e44:	f8 94       	cli
    1e46:	de bf       	out	0x3e, r29	; 62
    1e48:	0f be       	out	0x3f, r0	; 63
    1e4a:	cd bf       	out	0x3d, r28	; 61
    1e4c:	89 83       	std	Y+1, r24	; 0x01
    1e4e:	6a 83       	std	Y+2, r22	; 0x02
    1e50:	5c 83       	std	Y+4, r21	; 0x04
    1e52:	4b 83       	std	Y+3, r20	; 0x03
    1e54:	2d 83       	std	Y+5, r18	; 0x05
    1e56:	1f 83       	std	Y+7, r17	; 0x07
    1e58:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e5c:	88 23       	and	r24, r24
    1e5e:	39 f4       	brne	.+14     	; 0x1e6e <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1e60:	8e 81       	ldd	r24, Y+6	; 0x06
    1e62:	9f 81       	ldd	r25, Y+7	; 0x07
    1e64:	ee 81       	ldd	r30, Y+6	; 0x06
    1e66:	ff 81       	ldd	r31, Y+7	; 0x07
    1e68:	91 83       	std	Z+1, r25	; 0x01
    1e6a:	80 83       	st	Z, r24
    1e6c:	06 c0       	rjmp	.+12     	; 0x1e7a <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e70:	9c 81       	ldd	r25, Y+4	; 0x04
    1e72:	ee 81       	ldd	r30, Y+6	; 0x06
    1e74:	ff 81       	ldd	r31, Y+7	; 0x07
    1e76:	91 83       	std	Z+1, r25	; 0x01
    1e78:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1e7a:	ee 81       	ldd	r30, Y+6	; 0x06
    1e7c:	ff 81       	ldd	r31, Y+7	; 0x07
    1e7e:	89 81       	ldd	r24, Y+1	; 0x01
    1e80:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1e82:	ee 81       	ldd	r30, Y+6	; 0x06
    1e84:	ff 81       	ldd	r31, Y+7	; 0x07
    1e86:	8a 81       	ldd	r24, Y+2	; 0x02
    1e88:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1e8a:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8c:	9f 81       	ldd	r25, Y+7	; 0x07
    1e8e:	61 e0       	ldi	r22, 0x01	; 1
    1e90:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1e94:	27 96       	adiw	r28, 0x07	; 7
    1e96:	0f b6       	in	r0, 0x3f	; 63
    1e98:	f8 94       	cli
    1e9a:	de bf       	out	0x3e, r29	; 62
    1e9c:	0f be       	out	0x3f, r0	; 63
    1e9e:	cd bf       	out	0x3d, r28	; 61
    1ea0:	cf 91       	pop	r28
    1ea2:	df 91       	pop	r29
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	08 95       	ret

00001eaa <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1eaa:	df 93       	push	r29
    1eac:	cf 93       	push	r28
    1eae:	cd b7       	in	r28, 0x3d	; 61
    1eb0:	de b7       	in	r29, 0x3e	; 62
    1eb2:	2f 97       	sbiw	r28, 0x0f	; 15
    1eb4:	0f b6       	in	r0, 0x3f	; 63
    1eb6:	f8 94       	cli
    1eb8:	de bf       	out	0x3e, r29	; 62
    1eba:	0f be       	out	0x3f, r0	; 63
    1ebc:	cd bf       	out	0x3d, r28	; 61
    1ebe:	99 87       	std	Y+9, r25	; 0x09
    1ec0:	88 87       	std	Y+8, r24	; 0x08
    1ec2:	7b 87       	std	Y+11, r23	; 0x0b
    1ec4:	6a 87       	std	Y+10, r22	; 0x0a
    1ec6:	5d 87       	std	Y+13, r21	; 0x0d
    1ec8:	4c 87       	std	Y+12, r20	; 0x0c
    1eca:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1ecc:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1ece:	88 85       	ldd	r24, Y+8	; 0x08
    1ed0:	99 85       	ldd	r25, Y+9	; 0x09
    1ed2:	9a 83       	std	Y+2, r25	; 0x02
    1ed4:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1edc:	e9 81       	ldd	r30, Y+1	; 0x01
    1ede:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ee2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ee8:	98 17       	cp	r25, r24
    1eea:	18 f0       	brcs	.+6      	; 0x1ef2 <xQueueGenericSend+0x48>
    1eec:	8e 85       	ldd	r24, Y+14	; 0x0e
    1eee:	82 30       	cpi	r24, 0x02	; 2
    1ef0:	11 f5       	brne	.+68     	; 0x1f36 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ef2:	89 81       	ldd	r24, Y+1	; 0x01
    1ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef6:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ef8:	3b 85       	ldd	r19, Y+11	; 0x0b
    1efa:	b9 01       	movw	r22, r18
    1efc:	4e 85       	ldd	r20, Y+14	; 0x0e
    1efe:	0e 94 a7 13 	call	0x274e	; 0x274e <prvCopyDataToQueue>
    1f02:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f04:	e9 81       	ldd	r30, Y+1	; 0x01
    1f06:	fa 81       	ldd	r31, Y+2	; 0x02
    1f08:	81 89       	ldd	r24, Z+17	; 0x11
    1f0a:	88 23       	and	r24, r24
    1f0c:	51 f0       	breq	.+20     	; 0x1f22 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f0e:	89 81       	ldd	r24, Y+1	; 0x01
    1f10:	9a 81       	ldd	r25, Y+2	; 0x02
    1f12:	41 96       	adiw	r24, 0x11	; 17
    1f14:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    1f18:	88 23       	and	r24, r24
    1f1a:	41 f0       	breq	.+16     	; 0x1f2c <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1f1c:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    1f20:	05 c0       	rjmp	.+10     	; 0x1f2c <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1f22:	8b 81       	ldd	r24, Y+3	; 0x03
    1f24:	88 23       	and	r24, r24
    1f26:	11 f0       	breq	.+4      	; 0x1f2c <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1f28:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f30:	81 e0       	ldi	r24, 0x01	; 1
    1f32:	8f 87       	std	Y+15, r24	; 0x0f
    1f34:	5c c0       	rjmp	.+184    	; 0x1fee <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f36:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f38:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f3a:	00 97       	sbiw	r24, 0x00	; 0
    1f3c:	21 f4       	brne	.+8      	; 0x1f46 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f3e:	0f 90       	pop	r0
    1f40:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1f42:	1f 86       	std	Y+15, r1	; 0x0f
    1f44:	54 c0       	rjmp	.+168    	; 0x1fee <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f46:	8c 81       	ldd	r24, Y+4	; 0x04
    1f48:	88 23       	and	r24, r24
    1f4a:	31 f4       	brne	.+12     	; 0x1f58 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f4c:	ce 01       	movw	r24, r28
    1f4e:	05 96       	adiw	r24, 0x05	; 5
    1f50:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f54:	81 e0       	ldi	r24, 0x01	; 1
    1f56:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f58:	0f 90       	pop	r0
    1f5a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f5c:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f60:	0f b6       	in	r0, 0x3f	; 63
    1f62:	f8 94       	cli
    1f64:	0f 92       	push	r0
    1f66:	e9 81       	ldd	r30, Y+1	; 0x01
    1f68:	fa 81       	ldd	r31, Y+2	; 0x02
    1f6a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f6c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f6e:	19 f4       	brne	.+6      	; 0x1f76 <xQueueGenericSend+0xcc>
    1f70:	e9 81       	ldd	r30, Y+1	; 0x01
    1f72:	fa 81       	ldd	r31, Y+2	; 0x02
    1f74:	15 8e       	std	Z+29, r1	; 0x1d
    1f76:	e9 81       	ldd	r30, Y+1	; 0x01
    1f78:	fa 81       	ldd	r31, Y+2	; 0x02
    1f7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f7c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f7e:	19 f4       	brne	.+6      	; 0x1f86 <xQueueGenericSend+0xdc>
    1f80:	e9 81       	ldd	r30, Y+1	; 0x01
    1f82:	fa 81       	ldd	r31, Y+2	; 0x02
    1f84:	16 8e       	std	Z+30, r1	; 0x1e
    1f86:	0f 90       	pop	r0
    1f88:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f8a:	ce 01       	movw	r24, r28
    1f8c:	05 96       	adiw	r24, 0x05	; 5
    1f8e:	9e 01       	movw	r18, r28
    1f90:	24 5f       	subi	r18, 0xF4	; 244
    1f92:	3f 4f       	sbci	r19, 0xFF	; 255
    1f94:	b9 01       	movw	r22, r18
    1f96:	0e 94 83 24 	call	0x4906	; 0x4906 <xTaskCheckForTimeOut>
    1f9a:	88 23       	and	r24, r24
    1f9c:	09 f5       	brne	.+66     	; 0x1fe0 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1f9e:	89 81       	ldd	r24, Y+1	; 0x01
    1fa0:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa2:	0e 94 23 15 	call	0x2a46	; 0x2a46 <prvIsQueueFull>
    1fa6:	88 23       	and	r24, r24
    1fa8:	a1 f0       	breq	.+40     	; 0x1fd2 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1faa:	89 81       	ldd	r24, Y+1	; 0x01
    1fac:	9a 81       	ldd	r25, Y+2	; 0x02
    1fae:	08 96       	adiw	r24, 0x08	; 8
    1fb0:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fb2:	3d 85       	ldd	r19, Y+13	; 0x0d
    1fb4:	b9 01       	movw	r22, r18
    1fb6:	0e 94 32 23 	call	0x4664	; 0x4664 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1fba:	89 81       	ldd	r24, Y+1	; 0x01
    1fbc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fbe:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1fc2:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    1fc6:	88 23       	and	r24, r24
    1fc8:	09 f0       	breq	.+2      	; 0x1fcc <xQueueGenericSend+0x122>
    1fca:	85 cf       	rjmp	.-246    	; 0x1ed6 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1fcc:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    1fd0:	82 cf       	rjmp	.-252    	; 0x1ed6 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1fd2:	89 81       	ldd	r24, Y+1	; 0x01
    1fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd6:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1fda:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    1fde:	7b cf       	rjmp	.-266    	; 0x1ed6 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1fe0:	89 81       	ldd	r24, Y+1	; 0x01
    1fe2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe4:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1fe8:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1fec:	1f 86       	std	Y+15, r1	; 0x0f
    1fee:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1ff0:	2f 96       	adiw	r28, 0x0f	; 15
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	de bf       	out	0x3e, r29	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	cd bf       	out	0x3d, r28	; 61
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	08 95       	ret

00002002 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2002:	df 93       	push	r29
    2004:	cf 93       	push	r28
    2006:	cd b7       	in	r28, 0x3d	; 61
    2008:	de b7       	in	r29, 0x3e	; 62
    200a:	2c 97       	sbiw	r28, 0x0c	; 12
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	de bf       	out	0x3e, r29	; 62
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	cd bf       	out	0x3d, r28	; 61
    2016:	9f 83       	std	Y+7, r25	; 0x07
    2018:	8e 83       	std	Y+6, r24	; 0x06
    201a:	79 87       	std	Y+9, r23	; 0x09
    201c:	68 87       	std	Y+8, r22	; 0x08
    201e:	5b 87       	std	Y+11, r21	; 0x0b
    2020:	4a 87       	std	Y+10, r20	; 0x0a
    2022:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2024:	8e 81       	ldd	r24, Y+6	; 0x06
    2026:	9f 81       	ldd	r25, Y+7	; 0x07
    2028:	9b 83       	std	Y+3, r25	; 0x03
    202a:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    202c:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    202e:	ea 81       	ldd	r30, Y+2	; 0x02
    2030:	fb 81       	ldd	r31, Y+3	; 0x03
    2032:	92 8d       	ldd	r25, Z+26	; 0x1a
    2034:	ea 81       	ldd	r30, Y+2	; 0x02
    2036:	fb 81       	ldd	r31, Y+3	; 0x03
    2038:	83 8d       	ldd	r24, Z+27	; 0x1b
    203a:	98 17       	cp	r25, r24
    203c:	18 f0       	brcs	.+6      	; 0x2044 <xQueueGenericSendFromISR+0x42>
    203e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2040:	82 30       	cpi	r24, 0x02	; 2
    2042:	61 f5       	brne	.+88     	; 0x209c <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2044:	ea 81       	ldd	r30, Y+2	; 0x02
    2046:	fb 81       	ldd	r31, Y+3	; 0x03
    2048:	86 8d       	ldd	r24, Z+30	; 0x1e
    204a:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    204c:	8a 81       	ldd	r24, Y+2	; 0x02
    204e:	9b 81       	ldd	r25, Y+3	; 0x03
    2050:	28 85       	ldd	r18, Y+8	; 0x08
    2052:	39 85       	ldd	r19, Y+9	; 0x09
    2054:	b9 01       	movw	r22, r18
    2056:	4c 85       	ldd	r20, Y+12	; 0x0c
    2058:	0e 94 a7 13 	call	0x274e	; 0x274e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    205c:	89 81       	ldd	r24, Y+1	; 0x01
    205e:	8f 3f       	cpi	r24, 0xFF	; 255
    2060:	a9 f4       	brne	.+42     	; 0x208c <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2062:	ea 81       	ldd	r30, Y+2	; 0x02
    2064:	fb 81       	ldd	r31, Y+3	; 0x03
    2066:	81 89       	ldd	r24, Z+17	; 0x11
    2068:	88 23       	and	r24, r24
    206a:	a9 f0       	breq	.+42     	; 0x2096 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    206c:	8a 81       	ldd	r24, Y+2	; 0x02
    206e:	9b 81       	ldd	r25, Y+3	; 0x03
    2070:	41 96       	adiw	r24, 0x11	; 17
    2072:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    2076:	88 23       	and	r24, r24
    2078:	71 f0       	breq	.+28     	; 0x2096 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    207a:	8a 85       	ldd	r24, Y+10	; 0x0a
    207c:	9b 85       	ldd	r25, Y+11	; 0x0b
    207e:	00 97       	sbiw	r24, 0x00	; 0
    2080:	51 f0       	breq	.+20     	; 0x2096 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2082:	ea 85       	ldd	r30, Y+10	; 0x0a
    2084:	fb 85       	ldd	r31, Y+11	; 0x0b
    2086:	81 e0       	ldi	r24, 0x01	; 1
    2088:	80 83       	st	Z, r24
    208a:	05 c0       	rjmp	.+10     	; 0x2096 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    208c:	89 81       	ldd	r24, Y+1	; 0x01
    208e:	8f 5f       	subi	r24, 0xFF	; 255
    2090:	ea 81       	ldd	r30, Y+2	; 0x02
    2092:	fb 81       	ldd	r31, Y+3	; 0x03
    2094:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2096:	81 e0       	ldi	r24, 0x01	; 1
    2098:	8d 83       	std	Y+5, r24	; 0x05
    209a:	01 c0       	rjmp	.+2      	; 0x209e <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    209c:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    209e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    20a0:	2c 96       	adiw	r28, 0x0c	; 12
    20a2:	0f b6       	in	r0, 0x3f	; 63
    20a4:	f8 94       	cli
    20a6:	de bf       	out	0x3e, r29	; 62
    20a8:	0f be       	out	0x3f, r0	; 63
    20aa:	cd bf       	out	0x3d, r28	; 61
    20ac:	cf 91       	pop	r28
    20ae:	df 91       	pop	r29
    20b0:	08 95       	ret

000020b2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    20b2:	df 93       	push	r29
    20b4:	cf 93       	push	r28
    20b6:	cd b7       	in	r28, 0x3d	; 61
    20b8:	de b7       	in	r29, 0x3e	; 62
    20ba:	2a 97       	sbiw	r28, 0x0a	; 10
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	de bf       	out	0x3e, r29	; 62
    20c2:	0f be       	out	0x3f, r0	; 63
    20c4:	cd bf       	out	0x3d, r28	; 61
    20c6:	98 87       	std	Y+8, r25	; 0x08
    20c8:	8f 83       	std	Y+7, r24	; 0x07
    20ca:	7a 87       	std	Y+10, r23	; 0x0a
    20cc:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    20ce:	8f 81       	ldd	r24, Y+7	; 0x07
    20d0:	98 85       	ldd	r25, Y+8	; 0x08
    20d2:	9c 83       	std	Y+4, r25	; 0x04
    20d4:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    20d6:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    20d8:	eb 81       	ldd	r30, Y+3	; 0x03
    20da:	fc 81       	ldd	r31, Y+4	; 0x04
    20dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    20de:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    20e0:	eb 81       	ldd	r30, Y+3	; 0x03
    20e2:	fc 81       	ldd	r31, Y+4	; 0x04
    20e4:	93 8d       	ldd	r25, Z+27	; 0x1b
    20e6:	8a 81       	ldd	r24, Y+2	; 0x02
    20e8:	89 17       	cp	r24, r25
    20ea:	48 f5       	brcc	.+82     	; 0x213e <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    20ec:	eb 81       	ldd	r30, Y+3	; 0x03
    20ee:	fc 81       	ldd	r31, Y+4	; 0x04
    20f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    20f2:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    20f4:	8a 81       	ldd	r24, Y+2	; 0x02
    20f6:	8f 5f       	subi	r24, 0xFF	; 255
    20f8:	eb 81       	ldd	r30, Y+3	; 0x03
    20fa:	fc 81       	ldd	r31, Y+4	; 0x04
    20fc:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    20fe:	89 81       	ldd	r24, Y+1	; 0x01
    2100:	8f 3f       	cpi	r24, 0xFF	; 255
    2102:	a9 f4       	brne	.+42     	; 0x212e <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2104:	eb 81       	ldd	r30, Y+3	; 0x03
    2106:	fc 81       	ldd	r31, Y+4	; 0x04
    2108:	81 89       	ldd	r24, Z+17	; 0x11
    210a:	88 23       	and	r24, r24
    210c:	a9 f0       	breq	.+42     	; 0x2138 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    210e:	8b 81       	ldd	r24, Y+3	; 0x03
    2110:	9c 81       	ldd	r25, Y+4	; 0x04
    2112:	41 96       	adiw	r24, 0x11	; 17
    2114:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    2118:	88 23       	and	r24, r24
    211a:	71 f0       	breq	.+28     	; 0x2138 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    211c:	89 85       	ldd	r24, Y+9	; 0x09
    211e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2120:	00 97       	sbiw	r24, 0x00	; 0
    2122:	51 f0       	breq	.+20     	; 0x2138 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2124:	e9 85       	ldd	r30, Y+9	; 0x09
    2126:	fa 85       	ldd	r31, Y+10	; 0x0a
    2128:	81 e0       	ldi	r24, 0x01	; 1
    212a:	80 83       	st	Z, r24
    212c:	05 c0       	rjmp	.+10     	; 0x2138 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    212e:	89 81       	ldd	r24, Y+1	; 0x01
    2130:	8f 5f       	subi	r24, 0xFF	; 255
    2132:	eb 81       	ldd	r30, Y+3	; 0x03
    2134:	fc 81       	ldd	r31, Y+4	; 0x04
    2136:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2138:	81 e0       	ldi	r24, 0x01	; 1
    213a:	8e 83       	std	Y+6, r24	; 0x06
    213c:	01 c0       	rjmp	.+2      	; 0x2140 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    213e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2140:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2142:	2a 96       	adiw	r28, 0x0a	; 10
    2144:	0f b6       	in	r0, 0x3f	; 63
    2146:	f8 94       	cli
    2148:	de bf       	out	0x3e, r29	; 62
    214a:	0f be       	out	0x3f, r0	; 63
    214c:	cd bf       	out	0x3d, r28	; 61
    214e:	cf 91       	pop	r28
    2150:	df 91       	pop	r29
    2152:	08 95       	ret

00002154 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2154:	df 93       	push	r29
    2156:	cf 93       	push	r28
    2158:	cd b7       	in	r28, 0x3d	; 61
    215a:	de b7       	in	r29, 0x3e	; 62
    215c:	2e 97       	sbiw	r28, 0x0e	; 14
    215e:	0f b6       	in	r0, 0x3f	; 63
    2160:	f8 94       	cli
    2162:	de bf       	out	0x3e, r29	; 62
    2164:	0f be       	out	0x3f, r0	; 63
    2166:	cd bf       	out	0x3d, r28	; 61
    2168:	99 87       	std	Y+9, r25	; 0x09
    216a:	88 87       	std	Y+8, r24	; 0x08
    216c:	7b 87       	std	Y+11, r23	; 0x0b
    216e:	6a 87       	std	Y+10, r22	; 0x0a
    2170:	5d 87       	std	Y+13, r21	; 0x0d
    2172:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2174:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2176:	88 85       	ldd	r24, Y+8	; 0x08
    2178:	99 85       	ldd	r25, Y+9	; 0x09
    217a:	9b 83       	std	Y+3, r25	; 0x03
    217c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    217e:	0f b6       	in	r0, 0x3f	; 63
    2180:	f8 94       	cli
    2182:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2184:	ea 81       	ldd	r30, Y+2	; 0x02
    2186:	fb 81       	ldd	r31, Y+3	; 0x03
    2188:	82 8d       	ldd	r24, Z+26	; 0x1a
    218a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	88 23       	and	r24, r24
    2190:	f9 f0       	breq	.+62     	; 0x21d0 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2192:	8a 81       	ldd	r24, Y+2	; 0x02
    2194:	9b 81       	ldd	r25, Y+3	; 0x03
    2196:	2a 85       	ldd	r18, Y+10	; 0x0a
    2198:	3b 85       	ldd	r19, Y+11	; 0x0b
    219a:	b9 01       	movw	r22, r18
    219c:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    21a0:	89 81       	ldd	r24, Y+1	; 0x01
    21a2:	81 50       	subi	r24, 0x01	; 1
    21a4:	ea 81       	ldd	r30, Y+2	; 0x02
    21a6:	fb 81       	ldd	r31, Y+3	; 0x03
    21a8:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    21aa:	ea 81       	ldd	r30, Y+2	; 0x02
    21ac:	fb 81       	ldd	r31, Y+3	; 0x03
    21ae:	80 85       	ldd	r24, Z+8	; 0x08
    21b0:	88 23       	and	r24, r24
    21b2:	49 f0       	breq	.+18     	; 0x21c6 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21b4:	8a 81       	ldd	r24, Y+2	; 0x02
    21b6:	9b 81       	ldd	r25, Y+3	; 0x03
    21b8:	08 96       	adiw	r24, 0x08	; 8
    21ba:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    21be:	88 23       	and	r24, r24
    21c0:	11 f0       	breq	.+4      	; 0x21c6 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    21c2:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    21c6:	0f 90       	pop	r0
    21c8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    21ca:	81 e0       	ldi	r24, 0x01	; 1
    21cc:	8e 87       	std	Y+14, r24	; 0x0e
    21ce:	63 c0       	rjmp	.+198    	; 0x2296 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    21d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    21d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    21d4:	00 97       	sbiw	r24, 0x00	; 0
    21d6:	21 f4       	brne	.+8      	; 0x21e0 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21d8:	0f 90       	pop	r0
    21da:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    21dc:	1e 86       	std	Y+14, r1	; 0x0e
    21de:	5b c0       	rjmp	.+182    	; 0x2296 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    21e0:	8c 81       	ldd	r24, Y+4	; 0x04
    21e2:	88 23       	and	r24, r24
    21e4:	31 f4       	brne	.+12     	; 0x21f2 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    21e6:	ce 01       	movw	r24, r28
    21e8:	05 96       	adiw	r24, 0x05	; 5
    21ea:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    21ee:	81 e0       	ldi	r24, 0x01	; 1
    21f0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    21f2:	0f 90       	pop	r0
    21f4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    21f6:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	0f 92       	push	r0
    2200:	ea 81       	ldd	r30, Y+2	; 0x02
    2202:	fb 81       	ldd	r31, Y+3	; 0x03
    2204:	85 8d       	ldd	r24, Z+29	; 0x1d
    2206:	8f 3f       	cpi	r24, 0xFF	; 255
    2208:	19 f4       	brne	.+6      	; 0x2210 <xQueueReceive+0xbc>
    220a:	ea 81       	ldd	r30, Y+2	; 0x02
    220c:	fb 81       	ldd	r31, Y+3	; 0x03
    220e:	15 8e       	std	Z+29, r1	; 0x1d
    2210:	ea 81       	ldd	r30, Y+2	; 0x02
    2212:	fb 81       	ldd	r31, Y+3	; 0x03
    2214:	86 8d       	ldd	r24, Z+30	; 0x1e
    2216:	8f 3f       	cpi	r24, 0xFF	; 255
    2218:	19 f4       	brne	.+6      	; 0x2220 <xQueueReceive+0xcc>
    221a:	ea 81       	ldd	r30, Y+2	; 0x02
    221c:	fb 81       	ldd	r31, Y+3	; 0x03
    221e:	16 8e       	std	Z+30, r1	; 0x1e
    2220:	0f 90       	pop	r0
    2222:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2224:	ce 01       	movw	r24, r28
    2226:	05 96       	adiw	r24, 0x05	; 5
    2228:	9e 01       	movw	r18, r28
    222a:	24 5f       	subi	r18, 0xF4	; 244
    222c:	3f 4f       	sbci	r19, 0xFF	; 255
    222e:	b9 01       	movw	r22, r18
    2230:	0e 94 83 24 	call	0x4906	; 0x4906 <xTaskCheckForTimeOut>
    2234:	88 23       	and	r24, r24
    2236:	09 f5       	brne	.+66     	; 0x227a <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2238:	8a 81       	ldd	r24, Y+2	; 0x02
    223a:	9b 81       	ldd	r25, Y+3	; 0x03
    223c:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvIsQueueEmpty>
    2240:	88 23       	and	r24, r24
    2242:	a1 f0       	breq	.+40     	; 0x226c <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2244:	8a 81       	ldd	r24, Y+2	; 0x02
    2246:	9b 81       	ldd	r25, Y+3	; 0x03
    2248:	41 96       	adiw	r24, 0x11	; 17
    224a:	2c 85       	ldd	r18, Y+12	; 0x0c
    224c:	3d 85       	ldd	r19, Y+13	; 0x0d
    224e:	b9 01       	movw	r22, r18
    2250:	0e 94 32 23 	call	0x4664	; 0x4664 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2254:	8a 81       	ldd	r24, Y+2	; 0x02
    2256:	9b 81       	ldd	r25, Y+3	; 0x03
    2258:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    225c:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    2260:	88 23       	and	r24, r24
    2262:	09 f0       	breq	.+2      	; 0x2266 <xQueueReceive+0x112>
    2264:	8c cf       	rjmp	.-232    	; 0x217e <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2266:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    226a:	89 cf       	rjmp	.-238    	; 0x217e <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    226c:	8a 81       	ldd	r24, Y+2	; 0x02
    226e:	9b 81       	ldd	r25, Y+3	; 0x03
    2270:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2274:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    2278:	82 cf       	rjmp	.-252    	; 0x217e <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    227a:	8a 81       	ldd	r24, Y+2	; 0x02
    227c:	9b 81       	ldd	r25, Y+3	; 0x03
    227e:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2282:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2286:	8a 81       	ldd	r24, Y+2	; 0x02
    2288:	9b 81       	ldd	r25, Y+3	; 0x03
    228a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvIsQueueEmpty>
    228e:	88 23       	and	r24, r24
    2290:	09 f4       	brne	.+2      	; 0x2294 <xQueueReceive+0x140>
    2292:	75 cf       	rjmp	.-278    	; 0x217e <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2294:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2296:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2298:	2e 96       	adiw	r28, 0x0e	; 14
    229a:	0f b6       	in	r0, 0x3f	; 63
    229c:	f8 94       	cli
    229e:	de bf       	out	0x3e, r29	; 62
    22a0:	0f be       	out	0x3f, r0	; 63
    22a2:	cd bf       	out	0x3d, r28	; 61
    22a4:	cf 91       	pop	r28
    22a6:	df 91       	pop	r29
    22a8:	08 95       	ret

000022aa <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    22aa:	df 93       	push	r29
    22ac:	cf 93       	push	r28
    22ae:	cd b7       	in	r28, 0x3d	; 61
    22b0:	de b7       	in	r29, 0x3e	; 62
    22b2:	2c 97       	sbiw	r28, 0x0c	; 12
    22b4:	0f b6       	in	r0, 0x3f	; 63
    22b6:	f8 94       	cli
    22b8:	de bf       	out	0x3e, r29	; 62
    22ba:	0f be       	out	0x3f, r0	; 63
    22bc:	cd bf       	out	0x3d, r28	; 61
    22be:	99 87       	std	Y+9, r25	; 0x09
    22c0:	88 87       	std	Y+8, r24	; 0x08
    22c2:	7b 87       	std	Y+11, r23	; 0x0b
    22c4:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    22c6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    22c8:	88 85       	ldd	r24, Y+8	; 0x08
    22ca:	99 85       	ldd	r25, Y+9	; 0x09
    22cc:	9b 83       	std	Y+3, r25	; 0x03
    22ce:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    22d0:	0f b6       	in	r0, 0x3f	; 63
    22d2:	f8 94       	cli
    22d4:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    22d6:	ea 81       	ldd	r30, Y+2	; 0x02
    22d8:	fb 81       	ldd	r31, Y+3	; 0x03
    22da:	82 8d       	ldd	r24, Z+26	; 0x1a
    22dc:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    22de:	89 81       	ldd	r24, Y+1	; 0x01
    22e0:	88 23       	and	r24, r24
    22e2:	c1 f0       	breq	.+48     	; 0x2314 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    22e4:	89 81       	ldd	r24, Y+1	; 0x01
    22e6:	81 50       	subi	r24, 0x01	; 1
    22e8:	ea 81       	ldd	r30, Y+2	; 0x02
    22ea:	fb 81       	ldd	r31, Y+3	; 0x03
    22ec:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22ee:	ea 81       	ldd	r30, Y+2	; 0x02
    22f0:	fb 81       	ldd	r31, Y+3	; 0x03
    22f2:	80 85       	ldd	r24, Z+8	; 0x08
    22f4:	88 23       	and	r24, r24
    22f6:	49 f0       	breq	.+18     	; 0x230a <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22f8:	8a 81       	ldd	r24, Y+2	; 0x02
    22fa:	9b 81       	ldd	r25, Y+3	; 0x03
    22fc:	08 96       	adiw	r24, 0x08	; 8
    22fe:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    2302:	88 23       	and	r24, r24
    2304:	11 f0       	breq	.+4      	; 0x230a <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2306:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    230a:	0f 90       	pop	r0
    230c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    230e:	81 e0       	ldi	r24, 0x01	; 1
    2310:	8c 87       	std	Y+12, r24	; 0x0c
    2312:	63 c0       	rjmp	.+198    	; 0x23da <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2314:	8a 85       	ldd	r24, Y+10	; 0x0a
    2316:	9b 85       	ldd	r25, Y+11	; 0x0b
    2318:	00 97       	sbiw	r24, 0x00	; 0
    231a:	21 f4       	brne	.+8      	; 0x2324 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    231c:	0f 90       	pop	r0
    231e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2320:	1c 86       	std	Y+12, r1	; 0x0c
    2322:	5b c0       	rjmp	.+182    	; 0x23da <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    2324:	8c 81       	ldd	r24, Y+4	; 0x04
    2326:	88 23       	and	r24, r24
    2328:	31 f4       	brne	.+12     	; 0x2336 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    232a:	ce 01       	movw	r24, r28
    232c:	05 96       	adiw	r24, 0x05	; 5
    232e:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2332:	81 e0       	ldi	r24, 0x01	; 1
    2334:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2336:	0f 90       	pop	r0
    2338:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    233a:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	0f 92       	push	r0
    2344:	ea 81       	ldd	r30, Y+2	; 0x02
    2346:	fb 81       	ldd	r31, Y+3	; 0x03
    2348:	85 8d       	ldd	r24, Z+29	; 0x1d
    234a:	8f 3f       	cpi	r24, 0xFF	; 255
    234c:	19 f4       	brne	.+6      	; 0x2354 <xQueueSemaphoreTake+0xaa>
    234e:	ea 81       	ldd	r30, Y+2	; 0x02
    2350:	fb 81       	ldd	r31, Y+3	; 0x03
    2352:	15 8e       	std	Z+29, r1	; 0x1d
    2354:	ea 81       	ldd	r30, Y+2	; 0x02
    2356:	fb 81       	ldd	r31, Y+3	; 0x03
    2358:	86 8d       	ldd	r24, Z+30	; 0x1e
    235a:	8f 3f       	cpi	r24, 0xFF	; 255
    235c:	19 f4       	brne	.+6      	; 0x2364 <xQueueSemaphoreTake+0xba>
    235e:	ea 81       	ldd	r30, Y+2	; 0x02
    2360:	fb 81       	ldd	r31, Y+3	; 0x03
    2362:	16 8e       	std	Z+30, r1	; 0x1e
    2364:	0f 90       	pop	r0
    2366:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2368:	ce 01       	movw	r24, r28
    236a:	05 96       	adiw	r24, 0x05	; 5
    236c:	9e 01       	movw	r18, r28
    236e:	26 5f       	subi	r18, 0xF6	; 246
    2370:	3f 4f       	sbci	r19, 0xFF	; 255
    2372:	b9 01       	movw	r22, r18
    2374:	0e 94 83 24 	call	0x4906	; 0x4906 <xTaskCheckForTimeOut>
    2378:	88 23       	and	r24, r24
    237a:	09 f5       	brne	.+66     	; 0x23be <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    237c:	8a 81       	ldd	r24, Y+2	; 0x02
    237e:	9b 81       	ldd	r25, Y+3	; 0x03
    2380:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvIsQueueEmpty>
    2384:	88 23       	and	r24, r24
    2386:	a1 f0       	breq	.+40     	; 0x23b0 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2388:	8a 81       	ldd	r24, Y+2	; 0x02
    238a:	9b 81       	ldd	r25, Y+3	; 0x03
    238c:	41 96       	adiw	r24, 0x11	; 17
    238e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2390:	3b 85       	ldd	r19, Y+11	; 0x0b
    2392:	b9 01       	movw	r22, r18
    2394:	0e 94 32 23 	call	0x4664	; 0x4664 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2398:	8a 81       	ldd	r24, Y+2	; 0x02
    239a:	9b 81       	ldd	r25, Y+3	; 0x03
    239c:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    23a0:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    23a4:	88 23       	and	r24, r24
    23a6:	09 f0       	breq	.+2      	; 0x23aa <xQueueSemaphoreTake+0x100>
    23a8:	93 cf       	rjmp	.-218    	; 0x22d0 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    23aa:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    23ae:	90 cf       	rjmp	.-224    	; 0x22d0 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    23b0:	8a 81       	ldd	r24, Y+2	; 0x02
    23b2:	9b 81       	ldd	r25, Y+3	; 0x03
    23b4:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    23b8:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    23bc:	89 cf       	rjmp	.-238    	; 0x22d0 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    23be:	8a 81       	ldd	r24, Y+2	; 0x02
    23c0:	9b 81       	ldd	r25, Y+3	; 0x03
    23c2:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    23c6:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23ca:	8a 81       	ldd	r24, Y+2	; 0x02
    23cc:	9b 81       	ldd	r25, Y+3	; 0x03
    23ce:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvIsQueueEmpty>
    23d2:	88 23       	and	r24, r24
    23d4:	09 f4       	brne	.+2      	; 0x23d8 <xQueueSemaphoreTake+0x12e>
    23d6:	7c cf       	rjmp	.-264    	; 0x22d0 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    23d8:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    23da:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    23dc:	2c 96       	adiw	r28, 0x0c	; 12
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	de bf       	out	0x3e, r29	; 62
    23e4:	0f be       	out	0x3f, r0	; 63
    23e6:	cd bf       	out	0x3d, r28	; 61
    23e8:	cf 91       	pop	r28
    23ea:	df 91       	pop	r29
    23ec:	08 95       	ret

000023ee <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    23ee:	df 93       	push	r29
    23f0:	cf 93       	push	r28
    23f2:	cd b7       	in	r28, 0x3d	; 61
    23f4:	de b7       	in	r29, 0x3e	; 62
    23f6:	60 97       	sbiw	r28, 0x10	; 16
    23f8:	0f b6       	in	r0, 0x3f	; 63
    23fa:	f8 94       	cli
    23fc:	de bf       	out	0x3e, r29	; 62
    23fe:	0f be       	out	0x3f, r0	; 63
    2400:	cd bf       	out	0x3d, r28	; 61
    2402:	9b 87       	std	Y+11, r25	; 0x0b
    2404:	8a 87       	std	Y+10, r24	; 0x0a
    2406:	7d 87       	std	Y+13, r23	; 0x0d
    2408:	6c 87       	std	Y+12, r22	; 0x0c
    240a:	5f 87       	std	Y+15, r21	; 0x0f
    240c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    240e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2410:	8a 85       	ldd	r24, Y+10	; 0x0a
    2412:	9b 85       	ldd	r25, Y+11	; 0x0b
    2414:	9b 83       	std	Y+3, r25	; 0x03
    2416:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2418:	0f b6       	in	r0, 0x3f	; 63
    241a:	f8 94       	cli
    241c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    241e:	ea 81       	ldd	r30, Y+2	; 0x02
    2420:	fb 81       	ldd	r31, Y+3	; 0x03
    2422:	82 8d       	ldd	r24, Z+26	; 0x1a
    2424:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2426:	89 81       	ldd	r24, Y+1	; 0x01
    2428:	88 23       	and	r24, r24
    242a:	31 f1       	breq	.+76     	; 0x2478 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    242c:	ea 81       	ldd	r30, Y+2	; 0x02
    242e:	fb 81       	ldd	r31, Y+3	; 0x03
    2430:	86 81       	ldd	r24, Z+6	; 0x06
    2432:	97 81       	ldd	r25, Z+7	; 0x07
    2434:	9d 83       	std	Y+5, r25	; 0x05
    2436:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2438:	8a 81       	ldd	r24, Y+2	; 0x02
    243a:	9b 81       	ldd	r25, Y+3	; 0x03
    243c:	2c 85       	ldd	r18, Y+12	; 0x0c
    243e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2440:	b9 01       	movw	r22, r18
    2442:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2446:	ea 81       	ldd	r30, Y+2	; 0x02
    2448:	fb 81       	ldd	r31, Y+3	; 0x03
    244a:	8c 81       	ldd	r24, Y+4	; 0x04
    244c:	9d 81       	ldd	r25, Y+5	; 0x05
    244e:	97 83       	std	Z+7, r25	; 0x07
    2450:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2452:	ea 81       	ldd	r30, Y+2	; 0x02
    2454:	fb 81       	ldd	r31, Y+3	; 0x03
    2456:	81 89       	ldd	r24, Z+17	; 0x11
    2458:	88 23       	and	r24, r24
    245a:	49 f0       	breq	.+18     	; 0x246e <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    245c:	8a 81       	ldd	r24, Y+2	; 0x02
    245e:	9b 81       	ldd	r25, Y+3	; 0x03
    2460:	41 96       	adiw	r24, 0x11	; 17
    2462:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    2466:	88 23       	and	r24, r24
    2468:	11 f0       	breq	.+4      	; 0x246e <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    246a:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    246e:	0f 90       	pop	r0
    2470:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2472:	81 e0       	ldi	r24, 0x01	; 1
    2474:	88 8b       	std	Y+16, r24	; 0x10
    2476:	63 c0       	rjmp	.+198    	; 0x253e <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2478:	8e 85       	ldd	r24, Y+14	; 0x0e
    247a:	9f 85       	ldd	r25, Y+15	; 0x0f
    247c:	00 97       	sbiw	r24, 0x00	; 0
    247e:	21 f4       	brne	.+8      	; 0x2488 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2480:	0f 90       	pop	r0
    2482:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2484:	18 8a       	std	Y+16, r1	; 0x10
    2486:	5b c0       	rjmp	.+182    	; 0x253e <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    2488:	8e 81       	ldd	r24, Y+6	; 0x06
    248a:	88 23       	and	r24, r24
    248c:	31 f4       	brne	.+12     	; 0x249a <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    248e:	ce 01       	movw	r24, r28
    2490:	07 96       	adiw	r24, 0x07	; 7
    2492:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    249a:	0f 90       	pop	r0
    249c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    249e:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	0f 92       	push	r0
    24a8:	ea 81       	ldd	r30, Y+2	; 0x02
    24aa:	fb 81       	ldd	r31, Y+3	; 0x03
    24ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    24ae:	8f 3f       	cpi	r24, 0xFF	; 255
    24b0:	19 f4       	brne	.+6      	; 0x24b8 <xQueuePeek+0xca>
    24b2:	ea 81       	ldd	r30, Y+2	; 0x02
    24b4:	fb 81       	ldd	r31, Y+3	; 0x03
    24b6:	15 8e       	std	Z+29, r1	; 0x1d
    24b8:	ea 81       	ldd	r30, Y+2	; 0x02
    24ba:	fb 81       	ldd	r31, Y+3	; 0x03
    24bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    24be:	8f 3f       	cpi	r24, 0xFF	; 255
    24c0:	19 f4       	brne	.+6      	; 0x24c8 <xQueuePeek+0xda>
    24c2:	ea 81       	ldd	r30, Y+2	; 0x02
    24c4:	fb 81       	ldd	r31, Y+3	; 0x03
    24c6:	16 8e       	std	Z+30, r1	; 0x1e
    24c8:	0f 90       	pop	r0
    24ca:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24cc:	ce 01       	movw	r24, r28
    24ce:	07 96       	adiw	r24, 0x07	; 7
    24d0:	9e 01       	movw	r18, r28
    24d2:	22 5f       	subi	r18, 0xF2	; 242
    24d4:	3f 4f       	sbci	r19, 0xFF	; 255
    24d6:	b9 01       	movw	r22, r18
    24d8:	0e 94 83 24 	call	0x4906	; 0x4906 <xTaskCheckForTimeOut>
    24dc:	88 23       	and	r24, r24
    24de:	09 f5       	brne	.+66     	; 0x2522 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    24e0:	8a 81       	ldd	r24, Y+2	; 0x02
    24e2:	9b 81       	ldd	r25, Y+3	; 0x03
    24e4:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvIsQueueEmpty>
    24e8:	88 23       	and	r24, r24
    24ea:	a1 f0       	breq	.+40     	; 0x2514 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24ec:	8a 81       	ldd	r24, Y+2	; 0x02
    24ee:	9b 81       	ldd	r25, Y+3	; 0x03
    24f0:	41 96       	adiw	r24, 0x11	; 17
    24f2:	2e 85       	ldd	r18, Y+14	; 0x0e
    24f4:	3f 85       	ldd	r19, Y+15	; 0x0f
    24f6:	b9 01       	movw	r22, r18
    24f8:	0e 94 32 23 	call	0x4664	; 0x4664 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    24fc:	8a 81       	ldd	r24, Y+2	; 0x02
    24fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2500:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2504:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    2508:	88 23       	and	r24, r24
    250a:	09 f0       	breq	.+2      	; 0x250e <xQueuePeek+0x120>
    250c:	85 cf       	rjmp	.-246    	; 0x2418 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    250e:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    2512:	82 cf       	rjmp	.-252    	; 0x2418 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2514:	8a 81       	ldd	r24, Y+2	; 0x02
    2516:	9b 81       	ldd	r25, Y+3	; 0x03
    2518:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    251c:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    2520:	7b cf       	rjmp	.-266    	; 0x2418 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2522:	8a 81       	ldd	r24, Y+2	; 0x02
    2524:	9b 81       	ldd	r25, Y+3	; 0x03
    2526:	0e 94 94 14 	call	0x2928	; 0x2928 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    252a:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    252e:	8a 81       	ldd	r24, Y+2	; 0x02
    2530:	9b 81       	ldd	r25, Y+3	; 0x03
    2532:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvIsQueueEmpty>
    2536:	88 23       	and	r24, r24
    2538:	09 f4       	brne	.+2      	; 0x253c <xQueuePeek+0x14e>
    253a:	6e cf       	rjmp	.-292    	; 0x2418 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    253c:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    253e:	88 89       	ldd	r24, Y+16	; 0x10
}
    2540:	60 96       	adiw	r28, 0x10	; 16
    2542:	0f b6       	in	r0, 0x3f	; 63
    2544:	f8 94       	cli
    2546:	de bf       	out	0x3e, r29	; 62
    2548:	0f be       	out	0x3f, r0	; 63
    254a:	cd bf       	out	0x3d, r28	; 61
    254c:	cf 91       	pop	r28
    254e:	df 91       	pop	r29
    2550:	08 95       	ret

00002552 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2552:	df 93       	push	r29
    2554:	cf 93       	push	r28
    2556:	cd b7       	in	r28, 0x3d	; 61
    2558:	de b7       	in	r29, 0x3e	; 62
    255a:	2c 97       	sbiw	r28, 0x0c	; 12
    255c:	0f b6       	in	r0, 0x3f	; 63
    255e:	f8 94       	cli
    2560:	de bf       	out	0x3e, r29	; 62
    2562:	0f be       	out	0x3f, r0	; 63
    2564:	cd bf       	out	0x3d, r28	; 61
    2566:	98 87       	std	Y+8, r25	; 0x08
    2568:	8f 83       	std	Y+7, r24	; 0x07
    256a:	7a 87       	std	Y+10, r23	; 0x0a
    256c:	69 87       	std	Y+9, r22	; 0x09
    256e:	5c 87       	std	Y+12, r21	; 0x0c
    2570:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2572:	8f 81       	ldd	r24, Y+7	; 0x07
    2574:	98 85       	ldd	r25, Y+8	; 0x08
    2576:	9c 83       	std	Y+4, r25	; 0x04
    2578:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    257a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    257c:	eb 81       	ldd	r30, Y+3	; 0x03
    257e:	fc 81       	ldd	r31, Y+4	; 0x04
    2580:	82 8d       	ldd	r24, Z+26	; 0x1a
    2582:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2584:	8a 81       	ldd	r24, Y+2	; 0x02
    2586:	88 23       	and	r24, r24
    2588:	81 f1       	breq	.+96     	; 0x25ea <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    258a:	eb 81       	ldd	r30, Y+3	; 0x03
    258c:	fc 81       	ldd	r31, Y+4	; 0x04
    258e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2590:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2592:	8b 81       	ldd	r24, Y+3	; 0x03
    2594:	9c 81       	ldd	r25, Y+4	; 0x04
    2596:	29 85       	ldd	r18, Y+9	; 0x09
    2598:	3a 85       	ldd	r19, Y+10	; 0x0a
    259a:	b9 01       	movw	r22, r18
    259c:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    25a0:	8a 81       	ldd	r24, Y+2	; 0x02
    25a2:	81 50       	subi	r24, 0x01	; 1
    25a4:	eb 81       	ldd	r30, Y+3	; 0x03
    25a6:	fc 81       	ldd	r31, Y+4	; 0x04
    25a8:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    25aa:	89 81       	ldd	r24, Y+1	; 0x01
    25ac:	8f 3f       	cpi	r24, 0xFF	; 255
    25ae:	a9 f4       	brne	.+42     	; 0x25da <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25b0:	eb 81       	ldd	r30, Y+3	; 0x03
    25b2:	fc 81       	ldd	r31, Y+4	; 0x04
    25b4:	80 85       	ldd	r24, Z+8	; 0x08
    25b6:	88 23       	and	r24, r24
    25b8:	a9 f0       	breq	.+42     	; 0x25e4 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    25ba:	8b 81       	ldd	r24, Y+3	; 0x03
    25bc:	9c 81       	ldd	r25, Y+4	; 0x04
    25be:	08 96       	adiw	r24, 0x08	; 8
    25c0:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    25c4:	88 23       	and	r24, r24
    25c6:	71 f0       	breq	.+28     	; 0x25e4 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    25c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    25ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    25cc:	00 97       	sbiw	r24, 0x00	; 0
    25ce:	51 f0       	breq	.+20     	; 0x25e4 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    25d0:	eb 85       	ldd	r30, Y+11	; 0x0b
    25d2:	fc 85       	ldd	r31, Y+12	; 0x0c
    25d4:	81 e0       	ldi	r24, 0x01	; 1
    25d6:	80 83       	st	Z, r24
    25d8:	05 c0       	rjmp	.+10     	; 0x25e4 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    25da:	89 81       	ldd	r24, Y+1	; 0x01
    25dc:	8f 5f       	subi	r24, 0xFF	; 255
    25de:	eb 81       	ldd	r30, Y+3	; 0x03
    25e0:	fc 81       	ldd	r31, Y+4	; 0x04
    25e2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    25e4:	81 e0       	ldi	r24, 0x01	; 1
    25e6:	8e 83       	std	Y+6, r24	; 0x06
    25e8:	01 c0       	rjmp	.+2      	; 0x25ec <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    25ea:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    25ec:	8e 81       	ldd	r24, Y+6	; 0x06
}
    25ee:	2c 96       	adiw	r28, 0x0c	; 12
    25f0:	0f b6       	in	r0, 0x3f	; 63
    25f2:	f8 94       	cli
    25f4:	de bf       	out	0x3e, r29	; 62
    25f6:	0f be       	out	0x3f, r0	; 63
    25f8:	cd bf       	out	0x3d, r28	; 61
    25fa:	cf 91       	pop	r28
    25fc:	df 91       	pop	r29
    25fe:	08 95       	ret

00002600 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2600:	df 93       	push	r29
    2602:	cf 93       	push	r28
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
    2608:	2a 97       	sbiw	r28, 0x0a	; 10
    260a:	0f b6       	in	r0, 0x3f	; 63
    260c:	f8 94       	cli
    260e:	de bf       	out	0x3e, r29	; 62
    2610:	0f be       	out	0x3f, r0	; 63
    2612:	cd bf       	out	0x3d, r28	; 61
    2614:	98 87       	std	Y+8, r25	; 0x08
    2616:	8f 83       	std	Y+7, r24	; 0x07
    2618:	7a 87       	std	Y+10, r23	; 0x0a
    261a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    261c:	8f 81       	ldd	r24, Y+7	; 0x07
    261e:	98 85       	ldd	r25, Y+8	; 0x08
    2620:	9a 83       	std	Y+2, r25	; 0x02
    2622:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2624:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2626:	e9 81       	ldd	r30, Y+1	; 0x01
    2628:	fa 81       	ldd	r31, Y+2	; 0x02
    262a:	82 8d       	ldd	r24, Z+26	; 0x1a
    262c:	88 23       	and	r24, r24
    262e:	b1 f0       	breq	.+44     	; 0x265c <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2630:	e9 81       	ldd	r30, Y+1	; 0x01
    2632:	fa 81       	ldd	r31, Y+2	; 0x02
    2634:	86 81       	ldd	r24, Z+6	; 0x06
    2636:	97 81       	ldd	r25, Z+7	; 0x07
    2638:	9c 83       	std	Y+4, r25	; 0x04
    263a:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    263c:	89 81       	ldd	r24, Y+1	; 0x01
    263e:	9a 81       	ldd	r25, Y+2	; 0x02
    2640:	29 85       	ldd	r18, Y+9	; 0x09
    2642:	3a 85       	ldd	r19, Y+10	; 0x0a
    2644:	b9 01       	movw	r22, r18
    2646:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    264a:	e9 81       	ldd	r30, Y+1	; 0x01
    264c:	fa 81       	ldd	r31, Y+2	; 0x02
    264e:	8b 81       	ldd	r24, Y+3	; 0x03
    2650:	9c 81       	ldd	r25, Y+4	; 0x04
    2652:	97 83       	std	Z+7, r25	; 0x07
    2654:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2656:	81 e0       	ldi	r24, 0x01	; 1
    2658:	8e 83       	std	Y+6, r24	; 0x06
    265a:	01 c0       	rjmp	.+2      	; 0x265e <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    265c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    265e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2660:	2a 96       	adiw	r28, 0x0a	; 10
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	de bf       	out	0x3e, r29	; 62
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	cd bf       	out	0x3d, r28	; 61
    266c:	cf 91       	pop	r28
    266e:	df 91       	pop	r29
    2670:	08 95       	ret

00002672 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2672:	df 93       	push	r29
    2674:	cf 93       	push	r28
    2676:	00 d0       	rcall	.+0      	; 0x2678 <uxQueueMessagesWaiting+0x6>
    2678:	0f 92       	push	r0
    267a:	cd b7       	in	r28, 0x3d	; 61
    267c:	de b7       	in	r29, 0x3e	; 62
    267e:	9b 83       	std	Y+3, r25	; 0x03
    2680:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2682:	0f b6       	in	r0, 0x3f	; 63
    2684:	f8 94       	cli
    2686:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2688:	ea 81       	ldd	r30, Y+2	; 0x02
    268a:	fb 81       	ldd	r31, Y+3	; 0x03
    268c:	82 8d       	ldd	r24, Z+26	; 0x1a
    268e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2690:	0f 90       	pop	r0
    2692:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2694:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2696:	0f 90       	pop	r0
    2698:	0f 90       	pop	r0
    269a:	0f 90       	pop	r0
    269c:	cf 91       	pop	r28
    269e:	df 91       	pop	r29
    26a0:	08 95       	ret

000026a2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    26a2:	df 93       	push	r29
    26a4:	cf 93       	push	r28
    26a6:	00 d0       	rcall	.+0      	; 0x26a8 <uxQueueSpacesAvailable+0x6>
    26a8:	00 d0       	rcall	.+0      	; 0x26aa <uxQueueSpacesAvailable+0x8>
    26aa:	0f 92       	push	r0
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	9d 83       	std	Y+5, r25	; 0x05
    26b2:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    26b4:	8c 81       	ldd	r24, Y+4	; 0x04
    26b6:	9d 81       	ldd	r25, Y+5	; 0x05
    26b8:	9a 83       	std	Y+2, r25	; 0x02
    26ba:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    26c2:	e9 81       	ldd	r30, Y+1	; 0x01
    26c4:	fa 81       	ldd	r31, Y+2	; 0x02
    26c6:	93 8d       	ldd	r25, Z+27	; 0x1b
    26c8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ca:	fa 81       	ldd	r31, Y+2	; 0x02
    26cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    26ce:	29 2f       	mov	r18, r25
    26d0:	28 1b       	sub	r18, r24
    26d2:	82 2f       	mov	r24, r18
    26d4:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    26d6:	0f 90       	pop	r0
    26d8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    26da:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    26dc:	0f 90       	pop	r0
    26de:	0f 90       	pop	r0
    26e0:	0f 90       	pop	r0
    26e2:	0f 90       	pop	r0
    26e4:	0f 90       	pop	r0
    26e6:	cf 91       	pop	r28
    26e8:	df 91       	pop	r29
    26ea:	08 95       	ret

000026ec <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    26ec:	df 93       	push	r29
    26ee:	cf 93       	push	r28
    26f0:	00 d0       	rcall	.+0      	; 0x26f2 <uxQueueMessagesWaitingFromISR+0x6>
    26f2:	00 d0       	rcall	.+0      	; 0x26f4 <uxQueueMessagesWaitingFromISR+0x8>
    26f4:	0f 92       	push	r0
    26f6:	cd b7       	in	r28, 0x3d	; 61
    26f8:	de b7       	in	r29, 0x3e	; 62
    26fa:	9d 83       	std	Y+5, r25	; 0x05
    26fc:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    26fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2700:	9d 81       	ldd	r25, Y+5	; 0x05
    2702:	9a 83       	std	Y+2, r25	; 0x02
    2704:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2706:	e9 81       	ldd	r30, Y+1	; 0x01
    2708:	fa 81       	ldd	r31, Y+2	; 0x02
    270a:	82 8d       	ldd	r24, Z+26	; 0x1a
    270c:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    270e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	0f 90       	pop	r0
    2716:	0f 90       	pop	r0
    2718:	0f 90       	pop	r0
    271a:	cf 91       	pop	r28
    271c:	df 91       	pop	r29
    271e:	08 95       	ret

00002720 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2720:	df 93       	push	r29
    2722:	cf 93       	push	r28
    2724:	00 d0       	rcall	.+0      	; 0x2726 <vQueueDelete+0x6>
    2726:	00 d0       	rcall	.+0      	; 0x2728 <vQueueDelete+0x8>
    2728:	cd b7       	in	r28, 0x3d	; 61
    272a:	de b7       	in	r29, 0x3e	; 62
    272c:	9c 83       	std	Y+4, r25	; 0x04
    272e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2730:	8b 81       	ldd	r24, Y+3	; 0x03
    2732:	9c 81       	ldd	r25, Y+4	; 0x04
    2734:	9a 83       	std	Y+2, r25	; 0x02
    2736:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2738:	89 81       	ldd	r24, Y+1	; 0x01
    273a:	9a 81       	ldd	r25, Y+2	; 0x02
    273c:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	0f 90       	pop	r0
    2746:	0f 90       	pop	r0
    2748:	cf 91       	pop	r28
    274a:	df 91       	pop	r29
    274c:	08 95       	ret

0000274e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    274e:	df 93       	push	r29
    2750:	cf 93       	push	r28
    2752:	cd b7       	in	r28, 0x3d	; 61
    2754:	de b7       	in	r29, 0x3e	; 62
    2756:	27 97       	sbiw	r28, 0x07	; 7
    2758:	0f b6       	in	r0, 0x3f	; 63
    275a:	f8 94       	cli
    275c:	de bf       	out	0x3e, r29	; 62
    275e:	0f be       	out	0x3f, r0	; 63
    2760:	cd bf       	out	0x3d, r28	; 61
    2762:	9c 83       	std	Y+4, r25	; 0x04
    2764:	8b 83       	std	Y+3, r24	; 0x03
    2766:	7e 83       	std	Y+6, r23	; 0x06
    2768:	6d 83       	std	Y+5, r22	; 0x05
    276a:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    276c:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    276e:	eb 81       	ldd	r30, Y+3	; 0x03
    2770:	fc 81       	ldd	r31, Y+4	; 0x04
    2772:	82 8d       	ldd	r24, Z+26	; 0x1a
    2774:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2776:	eb 81       	ldd	r30, Y+3	; 0x03
    2778:	fc 81       	ldd	r31, Y+4	; 0x04
    277a:	84 8d       	ldd	r24, Z+28	; 0x1c
    277c:	88 23       	and	r24, r24
    277e:	09 f4       	brne	.+2      	; 0x2782 <prvCopyDataToQueue+0x34>
    2780:	7d c0       	rjmp	.+250    	; 0x287c <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2782:	8f 81       	ldd	r24, Y+7	; 0x07
    2784:	88 23       	and	r24, r24
    2786:	99 f5       	brne	.+102    	; 0x27ee <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2788:	eb 81       	ldd	r30, Y+3	; 0x03
    278a:	fc 81       	ldd	r31, Y+4	; 0x04
    278c:	62 81       	ldd	r22, Z+2	; 0x02
    278e:	73 81       	ldd	r23, Z+3	; 0x03
    2790:	eb 81       	ldd	r30, Y+3	; 0x03
    2792:	fc 81       	ldd	r31, Y+4	; 0x04
    2794:	84 8d       	ldd	r24, Z+28	; 0x1c
    2796:	48 2f       	mov	r20, r24
    2798:	50 e0       	ldi	r21, 0x00	; 0
    279a:	2d 81       	ldd	r18, Y+5	; 0x05
    279c:	3e 81       	ldd	r19, Y+6	; 0x06
    279e:	cb 01       	movw	r24, r22
    27a0:	b9 01       	movw	r22, r18
    27a2:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    27a6:	eb 81       	ldd	r30, Y+3	; 0x03
    27a8:	fc 81       	ldd	r31, Y+4	; 0x04
    27aa:	22 81       	ldd	r18, Z+2	; 0x02
    27ac:	33 81       	ldd	r19, Z+3	; 0x03
    27ae:	eb 81       	ldd	r30, Y+3	; 0x03
    27b0:	fc 81       	ldd	r31, Y+4	; 0x04
    27b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    27b4:	88 2f       	mov	r24, r24
    27b6:	90 e0       	ldi	r25, 0x00	; 0
    27b8:	82 0f       	add	r24, r18
    27ba:	93 1f       	adc	r25, r19
    27bc:	eb 81       	ldd	r30, Y+3	; 0x03
    27be:	fc 81       	ldd	r31, Y+4	; 0x04
    27c0:	93 83       	std	Z+3, r25	; 0x03
    27c2:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    27c4:	eb 81       	ldd	r30, Y+3	; 0x03
    27c6:	fc 81       	ldd	r31, Y+4	; 0x04
    27c8:	22 81       	ldd	r18, Z+2	; 0x02
    27ca:	33 81       	ldd	r19, Z+3	; 0x03
    27cc:	eb 81       	ldd	r30, Y+3	; 0x03
    27ce:	fc 81       	ldd	r31, Y+4	; 0x04
    27d0:	84 81       	ldd	r24, Z+4	; 0x04
    27d2:	95 81       	ldd	r25, Z+5	; 0x05
    27d4:	28 17       	cp	r18, r24
    27d6:	39 07       	cpc	r19, r25
    27d8:	08 f4       	brcc	.+2      	; 0x27dc <prvCopyDataToQueue+0x8e>
    27da:	50 c0       	rjmp	.+160    	; 0x287c <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    27dc:	eb 81       	ldd	r30, Y+3	; 0x03
    27de:	fc 81       	ldd	r31, Y+4	; 0x04
    27e0:	80 81       	ld	r24, Z
    27e2:	91 81       	ldd	r25, Z+1	; 0x01
    27e4:	eb 81       	ldd	r30, Y+3	; 0x03
    27e6:	fc 81       	ldd	r31, Y+4	; 0x04
    27e8:	93 83       	std	Z+3, r25	; 0x03
    27ea:	82 83       	std	Z+2, r24	; 0x02
    27ec:	47 c0       	rjmp	.+142    	; 0x287c <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    27ee:	eb 81       	ldd	r30, Y+3	; 0x03
    27f0:	fc 81       	ldd	r31, Y+4	; 0x04
    27f2:	66 81       	ldd	r22, Z+6	; 0x06
    27f4:	77 81       	ldd	r23, Z+7	; 0x07
    27f6:	eb 81       	ldd	r30, Y+3	; 0x03
    27f8:	fc 81       	ldd	r31, Y+4	; 0x04
    27fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    27fc:	48 2f       	mov	r20, r24
    27fe:	50 e0       	ldi	r21, 0x00	; 0
    2800:	2d 81       	ldd	r18, Y+5	; 0x05
    2802:	3e 81       	ldd	r19, Y+6	; 0x06
    2804:	cb 01       	movw	r24, r22
    2806:	b9 01       	movw	r22, r18
    2808:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    280c:	eb 81       	ldd	r30, Y+3	; 0x03
    280e:	fc 81       	ldd	r31, Y+4	; 0x04
    2810:	26 81       	ldd	r18, Z+6	; 0x06
    2812:	37 81       	ldd	r19, Z+7	; 0x07
    2814:	eb 81       	ldd	r30, Y+3	; 0x03
    2816:	fc 81       	ldd	r31, Y+4	; 0x04
    2818:	84 8d       	ldd	r24, Z+28	; 0x1c
    281a:	88 2f       	mov	r24, r24
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	90 95       	com	r25
    2820:	81 95       	neg	r24
    2822:	9f 4f       	sbci	r25, 0xFF	; 255
    2824:	82 0f       	add	r24, r18
    2826:	93 1f       	adc	r25, r19
    2828:	eb 81       	ldd	r30, Y+3	; 0x03
    282a:	fc 81       	ldd	r31, Y+4	; 0x04
    282c:	97 83       	std	Z+7, r25	; 0x07
    282e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2830:	eb 81       	ldd	r30, Y+3	; 0x03
    2832:	fc 81       	ldd	r31, Y+4	; 0x04
    2834:	26 81       	ldd	r18, Z+6	; 0x06
    2836:	37 81       	ldd	r19, Z+7	; 0x07
    2838:	eb 81       	ldd	r30, Y+3	; 0x03
    283a:	fc 81       	ldd	r31, Y+4	; 0x04
    283c:	80 81       	ld	r24, Z
    283e:	91 81       	ldd	r25, Z+1	; 0x01
    2840:	28 17       	cp	r18, r24
    2842:	39 07       	cpc	r19, r25
    2844:	90 f4       	brcc	.+36     	; 0x286a <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2846:	eb 81       	ldd	r30, Y+3	; 0x03
    2848:	fc 81       	ldd	r31, Y+4	; 0x04
    284a:	24 81       	ldd	r18, Z+4	; 0x04
    284c:	35 81       	ldd	r19, Z+5	; 0x05
    284e:	eb 81       	ldd	r30, Y+3	; 0x03
    2850:	fc 81       	ldd	r31, Y+4	; 0x04
    2852:	84 8d       	ldd	r24, Z+28	; 0x1c
    2854:	88 2f       	mov	r24, r24
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	90 95       	com	r25
    285a:	81 95       	neg	r24
    285c:	9f 4f       	sbci	r25, 0xFF	; 255
    285e:	82 0f       	add	r24, r18
    2860:	93 1f       	adc	r25, r19
    2862:	eb 81       	ldd	r30, Y+3	; 0x03
    2864:	fc 81       	ldd	r31, Y+4	; 0x04
    2866:	97 83       	std	Z+7, r25	; 0x07
    2868:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    286a:	8f 81       	ldd	r24, Y+7	; 0x07
    286c:	82 30       	cpi	r24, 0x02	; 2
    286e:	31 f4       	brne	.+12     	; 0x287c <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2870:	89 81       	ldd	r24, Y+1	; 0x01
    2872:	88 23       	and	r24, r24
    2874:	19 f0       	breq	.+6      	; 0x287c <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2876:	89 81       	ldd	r24, Y+1	; 0x01
    2878:	81 50       	subi	r24, 0x01	; 1
    287a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	8f 5f       	subi	r24, 0xFF	; 255
    2880:	eb 81       	ldd	r30, Y+3	; 0x03
    2882:	fc 81       	ldd	r31, Y+4	; 0x04
    2884:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2886:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2888:	27 96       	adiw	r28, 0x07	; 7
    288a:	0f b6       	in	r0, 0x3f	; 63
    288c:	f8 94       	cli
    288e:	de bf       	out	0x3e, r29	; 62
    2890:	0f be       	out	0x3f, r0	; 63
    2892:	cd bf       	out	0x3d, r28	; 61
    2894:	cf 91       	pop	r28
    2896:	df 91       	pop	r29
    2898:	08 95       	ret

0000289a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    289a:	df 93       	push	r29
    289c:	cf 93       	push	r28
    289e:	00 d0       	rcall	.+0      	; 0x28a0 <prvCopyDataFromQueue+0x6>
    28a0:	00 d0       	rcall	.+0      	; 0x28a2 <prvCopyDataFromQueue+0x8>
    28a2:	cd b7       	in	r28, 0x3d	; 61
    28a4:	de b7       	in	r29, 0x3e	; 62
    28a6:	9a 83       	std	Y+2, r25	; 0x02
    28a8:	89 83       	std	Y+1, r24	; 0x01
    28aa:	7c 83       	std	Y+4, r23	; 0x04
    28ac:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    28ae:	e9 81       	ldd	r30, Y+1	; 0x01
    28b0:	fa 81       	ldd	r31, Y+2	; 0x02
    28b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    28b4:	88 23       	and	r24, r24
    28b6:	89 f1       	breq	.+98     	; 0x291a <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    28b8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ba:	fa 81       	ldd	r31, Y+2	; 0x02
    28bc:	26 81       	ldd	r18, Z+6	; 0x06
    28be:	37 81       	ldd	r19, Z+7	; 0x07
    28c0:	e9 81       	ldd	r30, Y+1	; 0x01
    28c2:	fa 81       	ldd	r31, Y+2	; 0x02
    28c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    28c6:	88 2f       	mov	r24, r24
    28c8:	90 e0       	ldi	r25, 0x00	; 0
    28ca:	82 0f       	add	r24, r18
    28cc:	93 1f       	adc	r25, r19
    28ce:	e9 81       	ldd	r30, Y+1	; 0x01
    28d0:	fa 81       	ldd	r31, Y+2	; 0x02
    28d2:	97 83       	std	Z+7, r25	; 0x07
    28d4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    28d6:	e9 81       	ldd	r30, Y+1	; 0x01
    28d8:	fa 81       	ldd	r31, Y+2	; 0x02
    28da:	26 81       	ldd	r18, Z+6	; 0x06
    28dc:	37 81       	ldd	r19, Z+7	; 0x07
    28de:	e9 81       	ldd	r30, Y+1	; 0x01
    28e0:	fa 81       	ldd	r31, Y+2	; 0x02
    28e2:	84 81       	ldd	r24, Z+4	; 0x04
    28e4:	95 81       	ldd	r25, Z+5	; 0x05
    28e6:	28 17       	cp	r18, r24
    28e8:	39 07       	cpc	r19, r25
    28ea:	40 f0       	brcs	.+16     	; 0x28fc <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    28ec:	e9 81       	ldd	r30, Y+1	; 0x01
    28ee:	fa 81       	ldd	r31, Y+2	; 0x02
    28f0:	80 81       	ld	r24, Z
    28f2:	91 81       	ldd	r25, Z+1	; 0x01
    28f4:	e9 81       	ldd	r30, Y+1	; 0x01
    28f6:	fa 81       	ldd	r31, Y+2	; 0x02
    28f8:	97 83       	std	Z+7, r25	; 0x07
    28fa:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    28fc:	e9 81       	ldd	r30, Y+1	; 0x01
    28fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2900:	46 81       	ldd	r20, Z+6	; 0x06
    2902:	57 81       	ldd	r21, Z+7	; 0x07
    2904:	e9 81       	ldd	r30, Y+1	; 0x01
    2906:	fa 81       	ldd	r31, Y+2	; 0x02
    2908:	84 8d       	ldd	r24, Z+28	; 0x1c
    290a:	28 2f       	mov	r18, r24
    290c:	30 e0       	ldi	r19, 0x00	; 0
    290e:	8b 81       	ldd	r24, Y+3	; 0x03
    2910:	9c 81       	ldd	r25, Y+4	; 0x04
    2912:	ba 01       	movw	r22, r20
    2914:	a9 01       	movw	r20, r18
    2916:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>
	}
}
    291a:	0f 90       	pop	r0
    291c:	0f 90       	pop	r0
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	cf 91       	pop	r28
    2924:	df 91       	pop	r29
    2926:	08 95       	ret

00002928 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2928:	df 93       	push	r29
    292a:	cf 93       	push	r28
    292c:	00 d0       	rcall	.+0      	; 0x292e <prvUnlockQueue+0x6>
    292e:	00 d0       	rcall	.+0      	; 0x2930 <prvUnlockQueue+0x8>
    2930:	cd b7       	in	r28, 0x3d	; 61
    2932:	de b7       	in	r29, 0x3e	; 62
    2934:	9c 83       	std	Y+4, r25	; 0x04
    2936:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    293e:	eb 81       	ldd	r30, Y+3	; 0x03
    2940:	fc 81       	ldd	r31, Y+4	; 0x04
    2942:	86 8d       	ldd	r24, Z+30	; 0x1e
    2944:	8a 83       	std	Y+2, r24	; 0x02
    2946:	11 c0       	rjmp	.+34     	; 0x296a <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2948:	eb 81       	ldd	r30, Y+3	; 0x03
    294a:	fc 81       	ldd	r31, Y+4	; 0x04
    294c:	81 89       	ldd	r24, Z+17	; 0x11
    294e:	88 23       	and	r24, r24
    2950:	79 f0       	breq	.+30     	; 0x2970 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2952:	8b 81       	ldd	r24, Y+3	; 0x03
    2954:	9c 81       	ldd	r25, Y+4	; 0x04
    2956:	41 96       	adiw	r24, 0x11	; 17
    2958:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    295c:	88 23       	and	r24, r24
    295e:	11 f0       	breq	.+4      	; 0x2964 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2960:	0e 94 f0 24 	call	0x49e0	; 0x49e0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2964:	8a 81       	ldd	r24, Y+2	; 0x02
    2966:	81 50       	subi	r24, 0x01	; 1
    2968:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    296a:	8a 81       	ldd	r24, Y+2	; 0x02
    296c:	18 16       	cp	r1, r24
    296e:	64 f3       	brlt	.-40     	; 0x2948 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2970:	eb 81       	ldd	r30, Y+3	; 0x03
    2972:	fc 81       	ldd	r31, Y+4	; 0x04
    2974:	8f ef       	ldi	r24, 0xFF	; 255
    2976:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2978:	0f 90       	pop	r0
    297a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    297c:	0f b6       	in	r0, 0x3f	; 63
    297e:	f8 94       	cli
    2980:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2982:	eb 81       	ldd	r30, Y+3	; 0x03
    2984:	fc 81       	ldd	r31, Y+4	; 0x04
    2986:	85 8d       	ldd	r24, Z+29	; 0x1d
    2988:	89 83       	std	Y+1, r24	; 0x01
    298a:	11 c0       	rjmp	.+34     	; 0x29ae <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    298c:	eb 81       	ldd	r30, Y+3	; 0x03
    298e:	fc 81       	ldd	r31, Y+4	; 0x04
    2990:	80 85       	ldd	r24, Z+8	; 0x08
    2992:	88 23       	and	r24, r24
    2994:	79 f0       	breq	.+30     	; 0x29b4 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2996:	8b 81       	ldd	r24, Y+3	; 0x03
    2998:	9c 81       	ldd	r25, Y+4	; 0x04
    299a:	08 96       	adiw	r24, 0x08	; 8
    299c:	0e 94 84 23 	call	0x4708	; 0x4708 <xTaskRemoveFromEventList>
    29a0:	88 23       	and	r24, r24
    29a2:	11 f0       	breq	.+4      	; 0x29a8 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    29a4:	0e 94 f0 24 	call	0x49e0	; 0x49e0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    29a8:	89 81       	ldd	r24, Y+1	; 0x01
    29aa:	81 50       	subi	r24, 0x01	; 1
    29ac:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    29ae:	89 81       	ldd	r24, Y+1	; 0x01
    29b0:	18 16       	cp	r1, r24
    29b2:	64 f3       	brlt	.-40     	; 0x298c <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    29b4:	eb 81       	ldd	r30, Y+3	; 0x03
    29b6:	fc 81       	ldd	r31, Y+4	; 0x04
    29b8:	8f ef       	ldi	r24, 0xFF	; 255
    29ba:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    29bc:	0f 90       	pop	r0
    29be:	0f be       	out	0x3f, r0	; 63
}
    29c0:	0f 90       	pop	r0
    29c2:	0f 90       	pop	r0
    29c4:	0f 90       	pop	r0
    29c6:	0f 90       	pop	r0
    29c8:	cf 91       	pop	r28
    29ca:	df 91       	pop	r29
    29cc:	08 95       	ret

000029ce <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    29ce:	df 93       	push	r29
    29d0:	cf 93       	push	r28
    29d2:	00 d0       	rcall	.+0      	; 0x29d4 <prvIsQueueEmpty+0x6>
    29d4:	0f 92       	push	r0
    29d6:	cd b7       	in	r28, 0x3d	; 61
    29d8:	de b7       	in	r29, 0x3e	; 62
    29da:	9b 83       	std	Y+3, r25	; 0x03
    29dc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    29de:	0f b6       	in	r0, 0x3f	; 63
    29e0:	f8 94       	cli
    29e2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    29e4:	ea 81       	ldd	r30, Y+2	; 0x02
    29e6:	fb 81       	ldd	r31, Y+3	; 0x03
    29e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    29ea:	88 23       	and	r24, r24
    29ec:	19 f4       	brne	.+6      	; 0x29f4 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    29ee:	81 e0       	ldi	r24, 0x01	; 1
    29f0:	89 83       	std	Y+1, r24	; 0x01
    29f2:	01 c0       	rjmp	.+2      	; 0x29f6 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    29f4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    29f6:	0f 90       	pop	r0
    29f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    29fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	0f 90       	pop	r0
    2a02:	cf 91       	pop	r28
    2a04:	df 91       	pop	r29
    2a06:	08 95       	ret

00002a08 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2a08:	df 93       	push	r29
    2a0a:	cf 93       	push	r28
    2a0c:	00 d0       	rcall	.+0      	; 0x2a0e <xQueueIsQueueEmptyFromISR+0x6>
    2a0e:	00 d0       	rcall	.+0      	; 0x2a10 <xQueueIsQueueEmptyFromISR+0x8>
    2a10:	0f 92       	push	r0
    2a12:	cd b7       	in	r28, 0x3d	; 61
    2a14:	de b7       	in	r29, 0x3e	; 62
    2a16:	9d 83       	std	Y+5, r25	; 0x05
    2a18:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2a1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2a1e:	9a 83       	std	Y+2, r25	; 0x02
    2a20:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2a22:	e9 81       	ldd	r30, Y+1	; 0x01
    2a24:	fa 81       	ldd	r31, Y+2	; 0x02
    2a26:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a28:	88 23       	and	r24, r24
    2a2a:	19 f4       	brne	.+6      	; 0x2a32 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2a2c:	81 e0       	ldi	r24, 0x01	; 1
    2a2e:	8b 83       	std	Y+3, r24	; 0x03
    2a30:	01 c0       	rjmp	.+2      	; 0x2a34 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2a32:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2a34:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2a36:	0f 90       	pop	r0
    2a38:	0f 90       	pop	r0
    2a3a:	0f 90       	pop	r0
    2a3c:	0f 90       	pop	r0
    2a3e:	0f 90       	pop	r0
    2a40:	cf 91       	pop	r28
    2a42:	df 91       	pop	r29
    2a44:	08 95       	ret

00002a46 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2a46:	df 93       	push	r29
    2a48:	cf 93       	push	r28
    2a4a:	00 d0       	rcall	.+0      	; 0x2a4c <prvIsQueueFull+0x6>
    2a4c:	0f 92       	push	r0
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
    2a52:	9b 83       	std	Y+3, r25	; 0x03
    2a54:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2a56:	0f b6       	in	r0, 0x3f	; 63
    2a58:	f8 94       	cli
    2a5a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2a5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2a60:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a62:	ea 81       	ldd	r30, Y+2	; 0x02
    2a64:	fb 81       	ldd	r31, Y+3	; 0x03
    2a66:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a68:	98 17       	cp	r25, r24
    2a6a:	19 f4       	brne	.+6      	; 0x2a72 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	89 83       	std	Y+1, r24	; 0x01
    2a70:	01 c0       	rjmp	.+2      	; 0x2a74 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2a72:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2a74:	0f 90       	pop	r0
    2a76:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2a78:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a7a:	0f 90       	pop	r0
    2a7c:	0f 90       	pop	r0
    2a7e:	0f 90       	pop	r0
    2a80:	cf 91       	pop	r28
    2a82:	df 91       	pop	r29
    2a84:	08 95       	ret

00002a86 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2a86:	df 93       	push	r29
    2a88:	cf 93       	push	r28
    2a8a:	00 d0       	rcall	.+0      	; 0x2a8c <xQueueIsQueueFullFromISR+0x6>
    2a8c:	00 d0       	rcall	.+0      	; 0x2a8e <xQueueIsQueueFullFromISR+0x8>
    2a8e:	0f 92       	push	r0
    2a90:	cd b7       	in	r28, 0x3d	; 61
    2a92:	de b7       	in	r29, 0x3e	; 62
    2a94:	9d 83       	std	Y+5, r25	; 0x05
    2a96:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2a98:	8c 81       	ldd	r24, Y+4	; 0x04
    2a9a:	9d 81       	ldd	r25, Y+5	; 0x05
    2a9c:	9a 83       	std	Y+2, r25	; 0x02
    2a9e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa4:	92 8d       	ldd	r25, Z+26	; 0x1a
    2aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aaa:	83 8d       	ldd	r24, Z+27	; 0x1b
    2aac:	98 17       	cp	r25, r24
    2aae:	19 f4       	brne	.+6      	; 0x2ab6 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2ab0:	81 e0       	ldi	r24, 0x01	; 1
    2ab2:	8b 83       	std	Y+3, r24	; 0x03
    2ab4:	01 c0       	rjmp	.+2      	; 0x2ab8 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2ab6:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2ab8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2aba:	0f 90       	pop	r0
    2abc:	0f 90       	pop	r0
    2abe:	0f 90       	pop	r0
    2ac0:	0f 90       	pop	r0
    2ac2:	0f 90       	pop	r0
    2ac4:	cf 91       	pop	r28
    2ac6:	df 91       	pop	r29
    2ac8:	08 95       	ret

00002aca <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2aca:	0f 93       	push	r16
    2acc:	df 93       	push	r29
    2ace:	cf 93       	push	r28
    2ad0:	cd b7       	in	r28, 0x3d	; 61
    2ad2:	de b7       	in	r29, 0x3e	; 62
    2ad4:	28 97       	sbiw	r28, 0x08	; 8
    2ad6:	0f b6       	in	r0, 0x3f	; 63
    2ad8:	f8 94       	cli
    2ada:	de bf       	out	0x3e, r29	; 62
    2adc:	0f be       	out	0x3f, r0	; 63
    2ade:	cd bf       	out	0x3d, r28	; 61
    2ae0:	9d 83       	std	Y+5, r25	; 0x05
    2ae2:	8c 83       	std	Y+4, r24	; 0x04
    2ae4:	7f 83       	std	Y+7, r23	; 0x07
    2ae6:	6e 83       	std	Y+6, r22	; 0x06
    2ae8:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2aea:	88 85       	ldd	r24, Y+8	; 0x08
    2aec:	81 30       	cpi	r24, 0x01	; 1
    2aee:	19 f4       	brne	.+6      	; 0x2af6 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2af0:	81 e0       	ldi	r24, 0x01	; 1
    2af2:	89 83       	std	Y+1, r24	; 0x01
    2af4:	01 c0       	rjmp	.+2      	; 0x2af8 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2af6:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2af8:	8e 81       	ldd	r24, Y+6	; 0x06
    2afa:	9f 81       	ldd	r25, Y+7	; 0x07
    2afc:	00 97       	sbiw	r24, 0x00	; 0
    2afe:	21 f4       	brne	.+8      	; 0x2b08 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2b00:	81 e0       	ldi	r24, 0x01	; 1
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	9f 83       	std	Y+7, r25	; 0x07
    2b06:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2b08:	8c 81       	ldd	r24, Y+4	; 0x04
    2b0a:	9d 81       	ldd	r25, Y+5	; 0x05
    2b0c:	01 96       	adiw	r24, 0x01	; 1
    2b0e:	9d 83       	std	Y+5, r25	; 0x05
    2b10:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2b12:	8c 81       	ldd	r24, Y+4	; 0x04
    2b14:	9d 81       	ldd	r25, Y+5	; 0x05
    2b16:	0f 96       	adiw	r24, 0x0f	; 15
    2b18:	0e 94 1b 08 	call	0x1036	; 0x1036 <pvPortMalloc>
    2b1c:	9b 83       	std	Y+3, r25	; 0x03
    2b1e:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2b20:	8a 81       	ldd	r24, Y+2	; 0x02
    2b22:	9b 81       	ldd	r25, Y+3	; 0x03
    2b24:	00 97       	sbiw	r24, 0x00	; 0
    2b26:	89 f0       	breq	.+34     	; 0x2b4a <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2b28:	6a 81       	ldd	r22, Y+2	; 0x02
    2b2a:	7b 81       	ldd	r23, Y+3	; 0x03
    2b2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b2e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b30:	9c 01       	movw	r18, r24
    2b32:	21 5f       	subi	r18, 0xF1	; 241
    2b34:	3f 4f       	sbci	r19, 0xFF	; 255
    2b36:	4c 81       	ldd	r20, Y+4	; 0x04
    2b38:	5d 81       	ldd	r21, Y+5	; 0x05
    2b3a:	ee 81       	ldd	r30, Y+6	; 0x06
    2b3c:	ff 81       	ldd	r31, Y+7	; 0x07
    2b3e:	cb 01       	movw	r24, r22
    2b40:	b9 01       	movw	r22, r18
    2b42:	9f 01       	movw	r18, r30
    2b44:	09 81       	ldd	r16, Y+1	; 0x01
    2b46:	0e 94 bd 1c 	call	0x397a	; 0x397a <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2b4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4c:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2b4e:	28 96       	adiw	r28, 0x08	; 8
    2b50:	0f b6       	in	r0, 0x3f	; 63
    2b52:	f8 94       	cli
    2b54:	de bf       	out	0x3e, r29	; 62
    2b56:	0f be       	out	0x3f, r0	; 63
    2b58:	cd bf       	out	0x3d, r28	; 61
    2b5a:	cf 91       	pop	r28
    2b5c:	df 91       	pop	r29
    2b5e:	0f 91       	pop	r16
    2b60:	08 95       	ret

00002b62 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2b62:	df 93       	push	r29
    2b64:	cf 93       	push	r28
    2b66:	00 d0       	rcall	.+0      	; 0x2b68 <vStreamBufferDelete+0x6>
    2b68:	00 d0       	rcall	.+0      	; 0x2b6a <vStreamBufferDelete+0x8>
    2b6a:	cd b7       	in	r28, 0x3d	; 61
    2b6c:	de b7       	in	r29, 0x3e	; 62
    2b6e:	9c 83       	std	Y+4, r25	; 0x04
    2b70:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2b72:	8b 81       	ldd	r24, Y+3	; 0x03
    2b74:	9c 81       	ldd	r25, Y+4	; 0x04
    2b76:	9a 83       	std	Y+2, r25	; 0x02
    2b78:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7e:	86 85       	ldd	r24, Z+14	; 0x0e
    2b80:	88 2f       	mov	r24, r24
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	82 70       	andi	r24, 0x02	; 2
    2b86:	90 70       	andi	r25, 0x00	; 0
    2b88:	00 97       	sbiw	r24, 0x00	; 0
    2b8a:	29 f4       	brne	.+10     	; 0x2b96 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2b8c:	89 81       	ldd	r24, Y+1	; 0x01
    2b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b90:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vPortFree>
    2b94:	08 c0       	rjmp	.+16     	; 0x2ba6 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2b96:	89 81       	ldd	r24, Y+1	; 0x01
    2b98:	9a 81       	ldd	r25, Y+2	; 0x02
    2b9a:	60 e0       	ldi	r22, 0x00	; 0
    2b9c:	70 e0       	ldi	r23, 0x00	; 0
    2b9e:	4f e0       	ldi	r20, 0x0F	; 15
    2ba0:	50 e0       	ldi	r21, 0x00	; 0
    2ba2:	0e 94 1b 2a 	call	0x5436	; 0x5436 <memset>
	}
}
    2ba6:	0f 90       	pop	r0
    2ba8:	0f 90       	pop	r0
    2baa:	0f 90       	pop	r0
    2bac:	0f 90       	pop	r0
    2bae:	cf 91       	pop	r28
    2bb0:	df 91       	pop	r29
    2bb2:	08 95       	ret

00002bb4 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2bb4:	0f 93       	push	r16
    2bb6:	df 93       	push	r29
    2bb8:	cf 93       	push	r28
    2bba:	00 d0       	rcall	.+0      	; 0x2bbc <xStreamBufferReset+0x8>
    2bbc:	00 d0       	rcall	.+0      	; 0x2bbe <xStreamBufferReset+0xa>
    2bbe:	0f 92       	push	r0
    2bc0:	cd b7       	in	r28, 0x3d	; 61
    2bc2:	de b7       	in	r29, 0x3e	; 62
    2bc4:	9d 83       	std	Y+5, r25	; 0x05
    2bc6:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2bc8:	8c 81       	ldd	r24, Y+4	; 0x04
    2bca:	9d 81       	ldd	r25, Y+5	; 0x05
    2bcc:	9b 83       	std	Y+3, r25	; 0x03
    2bce:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2bd0:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2bd2:	0f b6       	in	r0, 0x3f	; 63
    2bd4:	f8 94       	cli
    2bd6:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2bd8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bda:	fb 81       	ldd	r31, Y+3	; 0x03
    2bdc:	80 85       	ldd	r24, Z+8	; 0x08
    2bde:	91 85       	ldd	r25, Z+9	; 0x09
    2be0:	00 97       	sbiw	r24, 0x00	; 0
    2be2:	f1 f4       	brne	.+60     	; 0x2c20 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2be4:	ea 81       	ldd	r30, Y+2	; 0x02
    2be6:	fb 81       	ldd	r31, Y+3	; 0x03
    2be8:	82 85       	ldd	r24, Z+10	; 0x0a
    2bea:	93 85       	ldd	r25, Z+11	; 0x0b
    2bec:	00 97       	sbiw	r24, 0x00	; 0
    2bee:	c1 f4       	brne	.+48     	; 0x2c20 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2bf0:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf2:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf4:	24 85       	ldd	r18, Z+12	; 0x0c
    2bf6:	35 85       	ldd	r19, Z+13	; 0x0d
    2bf8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bfa:	fb 81       	ldd	r31, Y+3	; 0x03
    2bfc:	44 81       	ldd	r20, Z+4	; 0x04
    2bfe:	55 81       	ldd	r21, Z+5	; 0x05
    2c00:	ea 81       	ldd	r30, Y+2	; 0x02
    2c02:	fb 81       	ldd	r31, Y+3	; 0x03
    2c04:	a6 81       	ldd	r26, Z+6	; 0x06
    2c06:	b7 81       	ldd	r27, Z+7	; 0x07
    2c08:	ea 81       	ldd	r30, Y+2	; 0x02
    2c0a:	fb 81       	ldd	r31, Y+3	; 0x03
    2c0c:	e6 85       	ldd	r30, Z+14	; 0x0e
    2c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c10:	9b 81       	ldd	r25, Y+3	; 0x03
    2c12:	b9 01       	movw	r22, r18
    2c14:	9d 01       	movw	r18, r26
    2c16:	0e 2f       	mov	r16, r30
    2c18:	0e 94 bd 1c 	call	0x397a	; 0x397a <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2c1c:	81 e0       	ldi	r24, 0x01	; 1
    2c1e:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2c20:	0f 90       	pop	r0
    2c22:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c24:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c26:	0f 90       	pop	r0
    2c28:	0f 90       	pop	r0
    2c2a:	0f 90       	pop	r0
    2c2c:	0f 90       	pop	r0
    2c2e:	0f 90       	pop	r0
    2c30:	cf 91       	pop	r28
    2c32:	df 91       	pop	r29
    2c34:	0f 91       	pop	r16
    2c36:	08 95       	ret

00002c38 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2c38:	df 93       	push	r29
    2c3a:	cf 93       	push	r28
    2c3c:	cd b7       	in	r28, 0x3d	; 61
    2c3e:	de b7       	in	r29, 0x3e	; 62
    2c40:	27 97       	sbiw	r28, 0x07	; 7
    2c42:	0f b6       	in	r0, 0x3f	; 63
    2c44:	f8 94       	cli
    2c46:	de bf       	out	0x3e, r29	; 62
    2c48:	0f be       	out	0x3f, r0	; 63
    2c4a:	cd bf       	out	0x3d, r28	; 61
    2c4c:	9d 83       	std	Y+5, r25	; 0x05
    2c4e:	8c 83       	std	Y+4, r24	; 0x04
    2c50:	7f 83       	std	Y+7, r23	; 0x07
    2c52:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c54:	8c 81       	ldd	r24, Y+4	; 0x04
    2c56:	9d 81       	ldd	r25, Y+5	; 0x05
    2c58:	9b 83       	std	Y+3, r25	; 0x03
    2c5a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2c5c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c5e:	9f 81       	ldd	r25, Y+7	; 0x07
    2c60:	00 97       	sbiw	r24, 0x00	; 0
    2c62:	21 f4       	brne	.+8      	; 0x2c6c <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2c64:	81 e0       	ldi	r24, 0x01	; 1
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	9f 83       	std	Y+7, r25	; 0x07
    2c6a:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2c6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c70:	24 81       	ldd	r18, Z+4	; 0x04
    2c72:	35 81       	ldd	r19, Z+5	; 0x05
    2c74:	8e 81       	ldd	r24, Y+6	; 0x06
    2c76:	9f 81       	ldd	r25, Y+7	; 0x07
    2c78:	28 17       	cp	r18, r24
    2c7a:	39 07       	cpc	r19, r25
    2c7c:	48 f0       	brcs	.+18     	; 0x2c90 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2c7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c80:	fb 81       	ldd	r31, Y+3	; 0x03
    2c82:	8e 81       	ldd	r24, Y+6	; 0x06
    2c84:	9f 81       	ldd	r25, Y+7	; 0x07
    2c86:	97 83       	std	Z+7, r25	; 0x07
    2c88:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2c8a:	81 e0       	ldi	r24, 0x01	; 1
    2c8c:	89 83       	std	Y+1, r24	; 0x01
    2c8e:	01 c0       	rjmp	.+2      	; 0x2c92 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2c90:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2c92:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c94:	27 96       	adiw	r28, 0x07	; 7
    2c96:	0f b6       	in	r0, 0x3f	; 63
    2c98:	f8 94       	cli
    2c9a:	de bf       	out	0x3e, r29	; 62
    2c9c:	0f be       	out	0x3f, r0	; 63
    2c9e:	cd bf       	out	0x3d, r28	; 61
    2ca0:	cf 91       	pop	r28
    2ca2:	df 91       	pop	r29
    2ca4:	08 95       	ret

00002ca6 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2ca6:	df 93       	push	r29
    2ca8:	cf 93       	push	r28
    2caa:	00 d0       	rcall	.+0      	; 0x2cac <xStreamBufferSpacesAvailable+0x6>
    2cac:	00 d0       	rcall	.+0      	; 0x2cae <xStreamBufferSpacesAvailable+0x8>
    2cae:	00 d0       	rcall	.+0      	; 0x2cb0 <xStreamBufferSpacesAvailable+0xa>
    2cb0:	cd b7       	in	r28, 0x3d	; 61
    2cb2:	de b7       	in	r29, 0x3e	; 62
    2cb4:	9e 83       	std	Y+6, r25	; 0x06
    2cb6:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    2cba:	9e 81       	ldd	r25, Y+6	; 0x06
    2cbc:	9c 83       	std	Y+4, r25	; 0x04
    2cbe:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc4:	24 81       	ldd	r18, Z+4	; 0x04
    2cc6:	35 81       	ldd	r19, Z+5	; 0x05
    2cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cca:	fc 81       	ldd	r31, Y+4	; 0x04
    2ccc:	80 81       	ld	r24, Z
    2cce:	91 81       	ldd	r25, Z+1	; 0x01
    2cd0:	82 0f       	add	r24, r18
    2cd2:	93 1f       	adc	r25, r19
    2cd4:	9a 83       	std	Y+2, r25	; 0x02
    2cd6:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2cd8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cda:	fc 81       	ldd	r31, Y+4	; 0x04
    2cdc:	22 81       	ldd	r18, Z+2	; 0x02
    2cde:	33 81       	ldd	r19, Z+3	; 0x03
    2ce0:	89 81       	ldd	r24, Y+1	; 0x01
    2ce2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ce4:	82 1b       	sub	r24, r18
    2ce6:	93 0b       	sbc	r25, r19
    2ce8:	9a 83       	std	Y+2, r25	; 0x02
    2cea:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2cec:	89 81       	ldd	r24, Y+1	; 0x01
    2cee:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf0:	01 97       	sbiw	r24, 0x01	; 1
    2cf2:	9a 83       	std	Y+2, r25	; 0x02
    2cf4:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2cf6:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfa:	24 81       	ldd	r18, Z+4	; 0x04
    2cfc:	35 81       	ldd	r19, Z+5	; 0x05
    2cfe:	89 81       	ldd	r24, Y+1	; 0x01
    2d00:	9a 81       	ldd	r25, Y+2	; 0x02
    2d02:	82 17       	cp	r24, r18
    2d04:	93 07       	cpc	r25, r19
    2d06:	50 f0       	brcs	.+20     	; 0x2d1c <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2d08:	eb 81       	ldd	r30, Y+3	; 0x03
    2d0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0c:	24 81       	ldd	r18, Z+4	; 0x04
    2d0e:	35 81       	ldd	r19, Z+5	; 0x05
    2d10:	89 81       	ldd	r24, Y+1	; 0x01
    2d12:	9a 81       	ldd	r25, Y+2	; 0x02
    2d14:	82 1b       	sub	r24, r18
    2d16:	93 0b       	sbc	r25, r19
    2d18:	9a 83       	std	Y+2, r25	; 0x02
    2d1a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2d1c:	89 81       	ldd	r24, Y+1	; 0x01
    2d1e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d20:	26 96       	adiw	r28, 0x06	; 6
    2d22:	0f b6       	in	r0, 0x3f	; 63
    2d24:	f8 94       	cli
    2d26:	de bf       	out	0x3e, r29	; 62
    2d28:	0f be       	out	0x3f, r0	; 63
    2d2a:	cd bf       	out	0x3d, r28	; 61
    2d2c:	cf 91       	pop	r28
    2d2e:	df 91       	pop	r29
    2d30:	08 95       	ret

00002d32 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2d32:	df 93       	push	r29
    2d34:	cf 93       	push	r28
    2d36:	00 d0       	rcall	.+0      	; 0x2d38 <xStreamBufferBytesAvailable+0x6>
    2d38:	00 d0       	rcall	.+0      	; 0x2d3a <xStreamBufferBytesAvailable+0x8>
    2d3a:	00 d0       	rcall	.+0      	; 0x2d3c <xStreamBufferBytesAvailable+0xa>
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	9e 83       	std	Y+6, r25	; 0x06
    2d42:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d44:	8d 81       	ldd	r24, Y+5	; 0x05
    2d46:	9e 81       	ldd	r25, Y+6	; 0x06
    2d48:	9c 83       	std	Y+4, r25	; 0x04
    2d4a:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d50:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    2d54:	9a 83       	std	Y+2, r25	; 0x02
    2d56:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2d58:	89 81       	ldd	r24, Y+1	; 0x01
    2d5a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d5c:	26 96       	adiw	r28, 0x06	; 6
    2d5e:	0f b6       	in	r0, 0x3f	; 63
    2d60:	f8 94       	cli
    2d62:	de bf       	out	0x3e, r29	; 62
    2d64:	0f be       	out	0x3f, r0	; 63
    2d66:	cd bf       	out	0x3d, r28	; 61
    2d68:	cf 91       	pop	r28
    2d6a:	df 91       	pop	r29
    2d6c:	08 95       	ret

00002d6e <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2d6e:	ef 92       	push	r14
    2d70:	ff 92       	push	r15
    2d72:	0f 93       	push	r16
    2d74:	1f 93       	push	r17
    2d76:	df 93       	push	r29
    2d78:	cf 93       	push	r28
    2d7a:	cd b7       	in	r28, 0x3d	; 61
    2d7c:	de b7       	in	r29, 0x3e	; 62
    2d7e:	63 97       	sbiw	r28, 0x13	; 19
    2d80:	0f b6       	in	r0, 0x3f	; 63
    2d82:	f8 94       	cli
    2d84:	de bf       	out	0x3e, r29	; 62
    2d86:	0f be       	out	0x3f, r0	; 63
    2d88:	cd bf       	out	0x3d, r28	; 61
    2d8a:	9d 87       	std	Y+13, r25	; 0x0d
    2d8c:	8c 87       	std	Y+12, r24	; 0x0c
    2d8e:	7f 87       	std	Y+15, r23	; 0x0f
    2d90:	6e 87       	std	Y+14, r22	; 0x0e
    2d92:	59 8b       	std	Y+17, r21	; 0x11
    2d94:	48 8b       	std	Y+16, r20	; 0x10
    2d96:	3b 8b       	std	Y+19, r19	; 0x13
    2d98:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d9a:	8c 85       	ldd	r24, Y+12	; 0x0c
    2d9c:	9d 85       	ldd	r25, Y+13	; 0x0d
    2d9e:	98 87       	std	Y+8, r25	; 0x08
    2da0:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2da2:	1c 82       	std	Y+4, r1	; 0x04
    2da4:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2da6:	88 89       	ldd	r24, Y+16	; 0x10
    2da8:	99 89       	ldd	r25, Y+17	; 0x11
    2daa:	9a 83       	std	Y+2, r25	; 0x02
    2dac:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2dae:	ef 81       	ldd	r30, Y+7	; 0x07
    2db0:	f8 85       	ldd	r31, Y+8	; 0x08
    2db2:	86 85       	ldd	r24, Z+14	; 0x0e
    2db4:	88 2f       	mov	r24, r24
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	81 70       	andi	r24, 0x01	; 1
    2dba:	90 70       	andi	r25, 0x00	; 0
    2dbc:	88 23       	and	r24, r24
    2dbe:	29 f0       	breq	.+10     	; 0x2dca <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2dc0:	89 81       	ldd	r24, Y+1	; 0x01
    2dc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc4:	02 96       	adiw	r24, 0x02	; 2
    2dc6:	9a 83       	std	Y+2, r25	; 0x02
    2dc8:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2dca:	8a 89       	ldd	r24, Y+18	; 0x12
    2dcc:	9b 89       	ldd	r25, Y+19	; 0x13
    2dce:	00 97       	sbiw	r24, 0x00	; 0
    2dd0:	09 f4       	brne	.+2      	; 0x2dd4 <xStreamBufferSend+0x66>
    2dd2:	40 c0       	rjmp	.+128    	; 0x2e54 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2dd4:	ce 01       	movw	r24, r28
    2dd6:	09 96       	adiw	r24, 0x09	; 9
    2dd8:	0e 94 4c 24 	call	0x4898	; 0x4898 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2ddc:	0f b6       	in	r0, 0x3f	; 63
    2dde:	f8 94       	cli
    2de0:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2de2:	8f 81       	ldd	r24, Y+7	; 0x07
    2de4:	98 85       	ldd	r25, Y+8	; 0x08
    2de6:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xStreamBufferSpacesAvailable>
    2dea:	9c 83       	std	Y+4, r25	; 0x04
    2dec:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2dee:	2b 81       	ldd	r18, Y+3	; 0x03
    2df0:	3c 81       	ldd	r19, Y+4	; 0x04
    2df2:	89 81       	ldd	r24, Y+1	; 0x01
    2df4:	9a 81       	ldd	r25, Y+2	; 0x02
    2df6:	28 17       	cp	r18, r24
    2df8:	39 07       	cpc	r19, r25
    2dfa:	50 f5       	brcc	.+84     	; 0x2e50 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2dfc:	80 e0       	ldi	r24, 0x00	; 0
    2dfe:	90 e0       	ldi	r25, 0x00	; 0
    2e00:	0e 94 5c 29 	call	0x52b8	; 0x52b8 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2e04:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <xTaskGetCurrentTaskHandle>
    2e08:	ef 81       	ldd	r30, Y+7	; 0x07
    2e0a:	f8 85       	ldd	r31, Y+8	; 0x08
    2e0c:	93 87       	std	Z+11, r25	; 0x0b
    2e0e:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2e10:	0f 90       	pop	r0
    2e12:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2e14:	ea 89       	ldd	r30, Y+18	; 0x12
    2e16:	fb 89       	ldd	r31, Y+19	; 0x13
    2e18:	60 e0       	ldi	r22, 0x00	; 0
    2e1a:	70 e0       	ldi	r23, 0x00	; 0
    2e1c:	80 e0       	ldi	r24, 0x00	; 0
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	20 e0       	ldi	r18, 0x00	; 0
    2e22:	30 e0       	ldi	r19, 0x00	; 0
    2e24:	40 e0       	ldi	r20, 0x00	; 0
    2e26:	50 e0       	ldi	r21, 0x00	; 0
    2e28:	00 e0       	ldi	r16, 0x00	; 0
    2e2a:	10 e0       	ldi	r17, 0x00	; 0
    2e2c:	7f 01       	movw	r14, r30
    2e2e:	0e 94 65 26 	call	0x4cca	; 0x4cca <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2e32:	ef 81       	ldd	r30, Y+7	; 0x07
    2e34:	f8 85       	ldd	r31, Y+8	; 0x08
    2e36:	13 86       	std	Z+11, r1	; 0x0b
    2e38:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2e3a:	ce 01       	movw	r24, r28
    2e3c:	09 96       	adiw	r24, 0x09	; 9
    2e3e:	9e 01       	movw	r18, r28
    2e40:	2e 5e       	subi	r18, 0xEE	; 238
    2e42:	3f 4f       	sbci	r19, 0xFF	; 255
    2e44:	b9 01       	movw	r22, r18
    2e46:	0e 94 83 24 	call	0x4906	; 0x4906 <xTaskCheckForTimeOut>
    2e4a:	88 23       	and	r24, r24
    2e4c:	39 f2       	breq	.-114    	; 0x2ddc <xStreamBufferSend+0x6e>
    2e4e:	02 c0       	rjmp	.+4      	; 0x2e54 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2e50:	0f 90       	pop	r0
    2e52:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2e54:	8b 81       	ldd	r24, Y+3	; 0x03
    2e56:	9c 81       	ldd	r25, Y+4	; 0x04
    2e58:	00 97       	sbiw	r24, 0x00	; 0
    2e5a:	31 f4       	brne	.+12     	; 0x2e68 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2e5c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e5e:	98 85       	ldd	r25, Y+8	; 0x08
    2e60:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xStreamBufferSpacesAvailable>
    2e64:	9c 83       	std	Y+4, r25	; 0x04
    2e66:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2e68:	8f 81       	ldd	r24, Y+7	; 0x07
    2e6a:	98 85       	ldd	r25, Y+8	; 0x08
    2e6c:	2e 85       	ldd	r18, Y+14	; 0x0e
    2e6e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2e70:	48 89       	ldd	r20, Y+16	; 0x10
    2e72:	59 89       	ldd	r21, Y+17	; 0x11
    2e74:	eb 81       	ldd	r30, Y+3	; 0x03
    2e76:	fc 81       	ldd	r31, Y+4	; 0x04
    2e78:	a9 81       	ldd	r26, Y+1	; 0x01
    2e7a:	ba 81       	ldd	r27, Y+2	; 0x02
    2e7c:	b9 01       	movw	r22, r18
    2e7e:	9f 01       	movw	r18, r30
    2e80:	8d 01       	movw	r16, r26
    2e82:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <prvWriteMessageToBuffer>
    2e86:	9e 83       	std	Y+6, r25	; 0x06
    2e88:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2e8a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e8c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e8e:	00 97       	sbiw	r24, 0x00	; 0
    2e90:	39 f1       	breq	.+78     	; 0x2ee0 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2e92:	8f 81       	ldd	r24, Y+7	; 0x07
    2e94:	98 85       	ldd	r25, Y+8	; 0x08
    2e96:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    2e9a:	9c 01       	movw	r18, r24
    2e9c:	ef 81       	ldd	r30, Y+7	; 0x07
    2e9e:	f8 85       	ldd	r31, Y+8	; 0x08
    2ea0:	86 81       	ldd	r24, Z+6	; 0x06
    2ea2:	97 81       	ldd	r25, Z+7	; 0x07
    2ea4:	28 17       	cp	r18, r24
    2ea6:	39 07       	cpc	r19, r25
    2ea8:	d8 f0       	brcs	.+54     	; 0x2ee0 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2eaa:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
    2eae:	ef 81       	ldd	r30, Y+7	; 0x07
    2eb0:	f8 85       	ldd	r31, Y+8	; 0x08
    2eb2:	80 85       	ldd	r24, Z+8	; 0x08
    2eb4:	91 85       	ldd	r25, Z+9	; 0x09
    2eb6:	00 97       	sbiw	r24, 0x00	; 0
    2eb8:	89 f0       	breq	.+34     	; 0x2edc <xStreamBufferSend+0x16e>
    2eba:	ef 81       	ldd	r30, Y+7	; 0x07
    2ebc:	f8 85       	ldd	r31, Y+8	; 0x08
    2ebe:	80 85       	ldd	r24, Z+8	; 0x08
    2ec0:	91 85       	ldd	r25, Z+9	; 0x09
    2ec2:	40 e0       	ldi	r20, 0x00	; 0
    2ec4:	50 e0       	ldi	r21, 0x00	; 0
    2ec6:	60 e0       	ldi	r22, 0x00	; 0
    2ec8:	70 e0       	ldi	r23, 0x00	; 0
    2eca:	20 e0       	ldi	r18, 0x00	; 0
    2ecc:	00 e0       	ldi	r16, 0x00	; 0
    2ece:	10 e0       	ldi	r17, 0x00	; 0
    2ed0:	0e 94 01 27 	call	0x4e02	; 0x4e02 <xTaskGenericNotify>
    2ed4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ed6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ed8:	11 86       	std	Z+9, r1	; 0x09
    2eda:	10 86       	std	Z+8, r1	; 0x08
    2edc:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2ee0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ee2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2ee4:	63 96       	adiw	r28, 0x13	; 19
    2ee6:	0f b6       	in	r0, 0x3f	; 63
    2ee8:	f8 94       	cli
    2eea:	de bf       	out	0x3e, r29	; 62
    2eec:	0f be       	out	0x3f, r0	; 63
    2eee:	cd bf       	out	0x3d, r28	; 61
    2ef0:	cf 91       	pop	r28
    2ef2:	df 91       	pop	r29
    2ef4:	1f 91       	pop	r17
    2ef6:	0f 91       	pop	r16
    2ef8:	ff 90       	pop	r15
    2efa:	ef 90       	pop	r14
    2efc:	08 95       	ret

00002efe <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2efe:	ef 92       	push	r14
    2f00:	ff 92       	push	r15
    2f02:	0f 93       	push	r16
    2f04:	1f 93       	push	r17
    2f06:	df 93       	push	r29
    2f08:	cf 93       	push	r28
    2f0a:	cd b7       	in	r28, 0x3d	; 61
    2f0c:	de b7       	in	r29, 0x3e	; 62
    2f0e:	61 97       	sbiw	r28, 0x11	; 17
    2f10:	0f b6       	in	r0, 0x3f	; 63
    2f12:	f8 94       	cli
    2f14:	de bf       	out	0x3e, r29	; 62
    2f16:	0f be       	out	0x3f, r0	; 63
    2f18:	cd bf       	out	0x3d, r28	; 61
    2f1a:	9b 87       	std	Y+11, r25	; 0x0b
    2f1c:	8a 87       	std	Y+10, r24	; 0x0a
    2f1e:	7d 87       	std	Y+13, r23	; 0x0d
    2f20:	6c 87       	std	Y+12, r22	; 0x0c
    2f22:	5f 87       	std	Y+15, r21	; 0x0f
    2f24:	4e 87       	std	Y+14, r20	; 0x0e
    2f26:	39 8b       	std	Y+17, r19	; 0x11
    2f28:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f2c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f2e:	99 87       	std	Y+9, r25	; 0x09
    2f30:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2f32:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f34:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f36:	9b 83       	std	Y+3, r25	; 0x03
    2f38:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2f3a:	e8 85       	ldd	r30, Y+8	; 0x08
    2f3c:	f9 85       	ldd	r31, Y+9	; 0x09
    2f3e:	86 85       	ldd	r24, Z+14	; 0x0e
    2f40:	88 2f       	mov	r24, r24
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	81 70       	andi	r24, 0x01	; 1
    2f46:	90 70       	andi	r25, 0x00	; 0
    2f48:	88 23       	and	r24, r24
    2f4a:	29 f0       	breq	.+10     	; 0x2f56 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2f4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f50:	02 96       	adiw	r24, 0x02	; 2
    2f52:	9b 83       	std	Y+3, r25	; 0x03
    2f54:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2f56:	88 85       	ldd	r24, Y+8	; 0x08
    2f58:	99 85       	ldd	r25, Y+9	; 0x09
    2f5a:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xStreamBufferSpacesAvailable>
    2f5e:	9d 83       	std	Y+5, r25	; 0x05
    2f60:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2f62:	88 85       	ldd	r24, Y+8	; 0x08
    2f64:	99 85       	ldd	r25, Y+9	; 0x09
    2f66:	2c 85       	ldd	r18, Y+12	; 0x0c
    2f68:	3d 85       	ldd	r19, Y+13	; 0x0d
    2f6a:	4e 85       	ldd	r20, Y+14	; 0x0e
    2f6c:	5f 85       	ldd	r21, Y+15	; 0x0f
    2f6e:	ec 81       	ldd	r30, Y+4	; 0x04
    2f70:	fd 81       	ldd	r31, Y+5	; 0x05
    2f72:	aa 81       	ldd	r26, Y+2	; 0x02
    2f74:	bb 81       	ldd	r27, Y+3	; 0x03
    2f76:	b9 01       	movw	r22, r18
    2f78:	9f 01       	movw	r18, r30
    2f7a:	8d 01       	movw	r16, r26
    2f7c:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <prvWriteMessageToBuffer>
    2f80:	9f 83       	std	Y+7, r25	; 0x07
    2f82:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2f84:	8e 81       	ldd	r24, Y+6	; 0x06
    2f86:	9f 81       	ldd	r25, Y+7	; 0x07
    2f88:	00 97       	sbiw	r24, 0x00	; 0
    2f8a:	39 f1       	breq	.+78     	; 0x2fda <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2f8c:	88 85       	ldd	r24, Y+8	; 0x08
    2f8e:	99 85       	ldd	r25, Y+9	; 0x09
    2f90:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    2f94:	9c 01       	movw	r18, r24
    2f96:	e8 85       	ldd	r30, Y+8	; 0x08
    2f98:	f9 85       	ldd	r31, Y+9	; 0x09
    2f9a:	86 81       	ldd	r24, Z+6	; 0x06
    2f9c:	97 81       	ldd	r25, Z+7	; 0x07
    2f9e:	28 17       	cp	r18, r24
    2fa0:	39 07       	cpc	r19, r25
    2fa2:	d8 f0       	brcs	.+54     	; 0x2fda <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2fa4:	19 82       	std	Y+1, r1	; 0x01
    2fa6:	e8 85       	ldd	r30, Y+8	; 0x08
    2fa8:	f9 85       	ldd	r31, Y+9	; 0x09
    2faa:	80 85       	ldd	r24, Z+8	; 0x08
    2fac:	91 85       	ldd	r25, Z+9	; 0x09
    2fae:	00 97       	sbiw	r24, 0x00	; 0
    2fb0:	a1 f0       	breq	.+40     	; 0x2fda <xStreamBufferSendFromISR+0xdc>
    2fb2:	e8 85       	ldd	r30, Y+8	; 0x08
    2fb4:	f9 85       	ldd	r31, Y+9	; 0x09
    2fb6:	80 85       	ldd	r24, Z+8	; 0x08
    2fb8:	91 85       	ldd	r25, Z+9	; 0x09
    2fba:	e8 89       	ldd	r30, Y+16	; 0x10
    2fbc:	f9 89       	ldd	r31, Y+17	; 0x11
    2fbe:	40 e0       	ldi	r20, 0x00	; 0
    2fc0:	50 e0       	ldi	r21, 0x00	; 0
    2fc2:	60 e0       	ldi	r22, 0x00	; 0
    2fc4:	70 e0       	ldi	r23, 0x00	; 0
    2fc6:	20 e0       	ldi	r18, 0x00	; 0
    2fc8:	00 e0       	ldi	r16, 0x00	; 0
    2fca:	10 e0       	ldi	r17, 0x00	; 0
    2fcc:	7f 01       	movw	r14, r30
    2fce:	0e 94 de 27 	call	0x4fbc	; 0x4fbc <xTaskGenericNotifyFromISR>
    2fd2:	e8 85       	ldd	r30, Y+8	; 0x08
    2fd4:	f9 85       	ldd	r31, Y+9	; 0x09
    2fd6:	11 86       	std	Z+9, r1	; 0x09
    2fd8:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2fda:	8e 81       	ldd	r24, Y+6	; 0x06
    2fdc:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2fde:	61 96       	adiw	r28, 0x11	; 17
    2fe0:	0f b6       	in	r0, 0x3f	; 63
    2fe2:	f8 94       	cli
    2fe4:	de bf       	out	0x3e, r29	; 62
    2fe6:	0f be       	out	0x3f, r0	; 63
    2fe8:	cd bf       	out	0x3d, r28	; 61
    2fea:	cf 91       	pop	r28
    2fec:	df 91       	pop	r29
    2fee:	1f 91       	pop	r17
    2ff0:	0f 91       	pop	r16
    2ff2:	ff 90       	pop	r15
    2ff4:	ef 90       	pop	r14
    2ff6:	08 95       	ret

00002ff8 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    2ff8:	0f 93       	push	r16
    2ffa:	1f 93       	push	r17
    2ffc:	df 93       	push	r29
    2ffe:	cf 93       	push	r28
    3000:	cd b7       	in	r28, 0x3d	; 61
    3002:	de b7       	in	r29, 0x3e	; 62
    3004:	61 97       	sbiw	r28, 0x11	; 17
    3006:	0f b6       	in	r0, 0x3f	; 63
    3008:	f8 94       	cli
    300a:	de bf       	out	0x3e, r29	; 62
    300c:	0f be       	out	0x3f, r0	; 63
    300e:	cd bf       	out	0x3d, r28	; 61
    3010:	9d 83       	std	Y+5, r25	; 0x05
    3012:	8c 83       	std	Y+4, r24	; 0x04
    3014:	7f 83       	std	Y+7, r23	; 0x07
    3016:	6e 83       	std	Y+6, r22	; 0x06
    3018:	59 87       	std	Y+9, r21	; 0x09
    301a:	48 87       	std	Y+8, r20	; 0x08
    301c:	3b 87       	std	Y+11, r19	; 0x0b
    301e:	2a 87       	std	Y+10, r18	; 0x0a
    3020:	1d 87       	std	Y+13, r17	; 0x0d
    3022:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    3024:	8a 85       	ldd	r24, Y+10	; 0x0a
    3026:	9b 85       	ldd	r25, Y+11	; 0x0b
    3028:	00 97       	sbiw	r24, 0x00	; 0
    302a:	11 f4       	brne	.+4      	; 0x3030 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    302c:	1b 82       	std	Y+3, r1	; 0x03
    302e:	38 c0       	rjmp	.+112    	; 0x30a0 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3030:	ec 81       	ldd	r30, Y+4	; 0x04
    3032:	fd 81       	ldd	r31, Y+5	; 0x05
    3034:	86 85       	ldd	r24, Z+14	; 0x0e
    3036:	88 2f       	mov	r24, r24
    3038:	90 e0       	ldi	r25, 0x00	; 0
    303a:	81 70       	andi	r24, 0x01	; 1
    303c:	90 70       	andi	r25, 0x00	; 0
    303e:	00 97       	sbiw	r24, 0x00	; 0
    3040:	d1 f4       	brne	.+52     	; 0x3076 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    3042:	81 e0       	ldi	r24, 0x01	; 1
    3044:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3046:	28 85       	ldd	r18, Y+8	; 0x08
    3048:	39 85       	ldd	r19, Y+9	; 0x09
    304a:	39 8b       	std	Y+17, r19	; 0x11
    304c:	28 8b       	std	Y+16, r18	; 0x10
    304e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3050:	9b 85       	ldd	r25, Y+11	; 0x0b
    3052:	9f 87       	std	Y+15, r25	; 0x0f
    3054:	8e 87       	std	Y+14, r24	; 0x0e
    3056:	2e 85       	ldd	r18, Y+14	; 0x0e
    3058:	3f 85       	ldd	r19, Y+15	; 0x0f
    305a:	88 89       	ldd	r24, Y+16	; 0x10
    305c:	99 89       	ldd	r25, Y+17	; 0x11
    305e:	82 17       	cp	r24, r18
    3060:	93 07       	cpc	r25, r19
    3062:	20 f4       	brcc	.+8      	; 0x306c <prvWriteMessageToBuffer+0x74>
    3064:	28 89       	ldd	r18, Y+16	; 0x10
    3066:	39 89       	ldd	r19, Y+17	; 0x11
    3068:	3f 87       	std	Y+15, r19	; 0x0f
    306a:	2e 87       	std	Y+14, r18	; 0x0e
    306c:	8e 85       	ldd	r24, Y+14	; 0x0e
    306e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3070:	99 87       	std	Y+9, r25	; 0x09
    3072:	88 87       	std	Y+8, r24	; 0x08
    3074:	15 c0       	rjmp	.+42     	; 0x30a0 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    3076:	2a 85       	ldd	r18, Y+10	; 0x0a
    3078:	3b 85       	ldd	r19, Y+11	; 0x0b
    307a:	8c 85       	ldd	r24, Y+12	; 0x0c
    307c:	9d 85       	ldd	r25, Y+13	; 0x0d
    307e:	28 17       	cp	r18, r24
    3080:	39 07       	cpc	r19, r25
    3082:	68 f0       	brcs	.+26     	; 0x309e <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    3084:	81 e0       	ldi	r24, 0x01	; 1
    3086:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3088:	9e 01       	movw	r18, r28
    308a:	28 5f       	subi	r18, 0xF8	; 248
    308c:	3f 4f       	sbci	r19, 0xFF	; 255
    308e:	8c 81       	ldd	r24, Y+4	; 0x04
    3090:	9d 81       	ldd	r25, Y+5	; 0x05
    3092:	b9 01       	movw	r22, r18
    3094:	42 e0       	ldi	r20, 0x02	; 2
    3096:	50 e0       	ldi	r21, 0x00	; 0
    3098:	0e 94 49 1b 	call	0x3692	; 0x3692 <prvWriteBytesToBuffer>
    309c:	01 c0       	rjmp	.+2      	; 0x30a0 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    309e:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    30a0:	8b 81       	ldd	r24, Y+3	; 0x03
    30a2:	88 23       	and	r24, r24
    30a4:	61 f0       	breq	.+24     	; 0x30be <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    30a6:	2e 81       	ldd	r18, Y+6	; 0x06
    30a8:	3f 81       	ldd	r19, Y+7	; 0x07
    30aa:	48 85       	ldd	r20, Y+8	; 0x08
    30ac:	59 85       	ldd	r21, Y+9	; 0x09
    30ae:	8c 81       	ldd	r24, Y+4	; 0x04
    30b0:	9d 81       	ldd	r25, Y+5	; 0x05
    30b2:	b9 01       	movw	r22, r18
    30b4:	0e 94 49 1b 	call	0x3692	; 0x3692 <prvWriteBytesToBuffer>
    30b8:	9a 83       	std	Y+2, r25	; 0x02
    30ba:	89 83       	std	Y+1, r24	; 0x01
    30bc:	02 c0       	rjmp	.+4      	; 0x30c2 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    30be:	1a 82       	std	Y+2, r1	; 0x02
    30c0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    30c2:	89 81       	ldd	r24, Y+1	; 0x01
    30c4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30c6:	61 96       	adiw	r28, 0x11	; 17
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	f8 94       	cli
    30cc:	de bf       	out	0x3e, r29	; 62
    30ce:	0f be       	out	0x3f, r0	; 63
    30d0:	cd bf       	out	0x3d, r28	; 61
    30d2:	cf 91       	pop	r28
    30d4:	df 91       	pop	r29
    30d6:	1f 91       	pop	r17
    30d8:	0f 91       	pop	r16
    30da:	08 95       	ret

000030dc <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    30dc:	ef 92       	push	r14
    30de:	ff 92       	push	r15
    30e0:	0f 93       	push	r16
    30e2:	1f 93       	push	r17
    30e4:	df 93       	push	r29
    30e6:	cf 93       	push	r28
    30e8:	cd b7       	in	r28, 0x3d	; 61
    30ea:	de b7       	in	r29, 0x3e	; 62
    30ec:	60 97       	sbiw	r28, 0x10	; 16
    30ee:	0f b6       	in	r0, 0x3f	; 63
    30f0:	f8 94       	cli
    30f2:	de bf       	out	0x3e, r29	; 62
    30f4:	0f be       	out	0x3f, r0	; 63
    30f6:	cd bf       	out	0x3d, r28	; 61
    30f8:	9a 87       	std	Y+10, r25	; 0x0a
    30fa:	89 87       	std	Y+9, r24	; 0x09
    30fc:	7c 87       	std	Y+12, r23	; 0x0c
    30fe:	6b 87       	std	Y+11, r22	; 0x0b
    3100:	5e 87       	std	Y+14, r21	; 0x0e
    3102:	4d 87       	std	Y+13, r20	; 0x0d
    3104:	38 8b       	std	Y+16, r19	; 0x10
    3106:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3108:	89 85       	ldd	r24, Y+9	; 0x09
    310a:	9a 85       	ldd	r25, Y+10	; 0x0a
    310c:	98 87       	std	Y+8, r25	; 0x08
    310e:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3110:	1e 82       	std	Y+6, r1	; 0x06
    3112:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3114:	ef 81       	ldd	r30, Y+7	; 0x07
    3116:	f8 85       	ldd	r31, Y+8	; 0x08
    3118:	86 85       	ldd	r24, Z+14	; 0x0e
    311a:	88 2f       	mov	r24, r24
    311c:	90 e0       	ldi	r25, 0x00	; 0
    311e:	81 70       	andi	r24, 0x01	; 1
    3120:	90 70       	andi	r25, 0x00	; 0
    3122:	88 23       	and	r24, r24
    3124:	29 f0       	breq	.+10     	; 0x3130 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3126:	82 e0       	ldi	r24, 0x02	; 2
    3128:	90 e0       	ldi	r25, 0x00	; 0
    312a:	9a 83       	std	Y+2, r25	; 0x02
    312c:	89 83       	std	Y+1, r24	; 0x01
    312e:	02 c0       	rjmp	.+4      	; 0x3134 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3130:	1a 82       	std	Y+2, r1	; 0x02
    3132:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3134:	8f 85       	ldd	r24, Y+15	; 0x0f
    3136:	98 89       	ldd	r25, Y+16	; 0x10
    3138:	00 97       	sbiw	r24, 0x00	; 0
    313a:	09 f4       	brne	.+2      	; 0x313e <xStreamBufferReceive+0x62>
    313c:	3d c0       	rjmp	.+122    	; 0x31b8 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    313e:	0f b6       	in	r0, 0x3f	; 63
    3140:	f8 94       	cli
    3142:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3144:	8f 81       	ldd	r24, Y+7	; 0x07
    3146:	98 85       	ldd	r25, Y+8	; 0x08
    3148:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    314c:	9c 83       	std	Y+4, r25	; 0x04
    314e:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3150:	2b 81       	ldd	r18, Y+3	; 0x03
    3152:	3c 81       	ldd	r19, Y+4	; 0x04
    3154:	89 81       	ldd	r24, Y+1	; 0x01
    3156:	9a 81       	ldd	r25, Y+2	; 0x02
    3158:	82 17       	cp	r24, r18
    315a:	93 07       	cpc	r25, r19
    315c:	50 f0       	brcs	.+20     	; 0x3172 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    315e:	80 e0       	ldi	r24, 0x00	; 0
    3160:	90 e0       	ldi	r25, 0x00	; 0
    3162:	0e 94 5c 29 	call	0x52b8	; 0x52b8 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3166:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <xTaskGetCurrentTaskHandle>
    316a:	ef 81       	ldd	r30, Y+7	; 0x07
    316c:	f8 85       	ldd	r31, Y+8	; 0x08
    316e:	91 87       	std	Z+9, r25	; 0x09
    3170:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3172:	0f 90       	pop	r0
    3174:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3176:	2b 81       	ldd	r18, Y+3	; 0x03
    3178:	3c 81       	ldd	r19, Y+4	; 0x04
    317a:	89 81       	ldd	r24, Y+1	; 0x01
    317c:	9a 81       	ldd	r25, Y+2	; 0x02
    317e:	82 17       	cp	r24, r18
    3180:	93 07       	cpc	r25, r19
    3182:	00 f1       	brcs	.+64     	; 0x31c4 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3184:	ef 85       	ldd	r30, Y+15	; 0x0f
    3186:	f8 89       	ldd	r31, Y+16	; 0x10
    3188:	60 e0       	ldi	r22, 0x00	; 0
    318a:	70 e0       	ldi	r23, 0x00	; 0
    318c:	80 e0       	ldi	r24, 0x00	; 0
    318e:	90 e0       	ldi	r25, 0x00	; 0
    3190:	20 e0       	ldi	r18, 0x00	; 0
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	40 e0       	ldi	r20, 0x00	; 0
    3196:	50 e0       	ldi	r21, 0x00	; 0
    3198:	00 e0       	ldi	r16, 0x00	; 0
    319a:	10 e0       	ldi	r17, 0x00	; 0
    319c:	7f 01       	movw	r14, r30
    319e:	0e 94 65 26 	call	0x4cca	; 0x4cca <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    31a2:	ef 81       	ldd	r30, Y+7	; 0x07
    31a4:	f8 85       	ldd	r31, Y+8	; 0x08
    31a6:	11 86       	std	Z+9, r1	; 0x09
    31a8:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31aa:	8f 81       	ldd	r24, Y+7	; 0x07
    31ac:	98 85       	ldd	r25, Y+8	; 0x08
    31ae:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    31b2:	9c 83       	std	Y+4, r25	; 0x04
    31b4:	8b 83       	std	Y+3, r24	; 0x03
    31b6:	06 c0       	rjmp	.+12     	; 0x31c4 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31b8:	8f 81       	ldd	r24, Y+7	; 0x07
    31ba:	98 85       	ldd	r25, Y+8	; 0x08
    31bc:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    31c0:	9c 83       	std	Y+4, r25	; 0x04
    31c2:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    31c4:	2b 81       	ldd	r18, Y+3	; 0x03
    31c6:	3c 81       	ldd	r19, Y+4	; 0x04
    31c8:	89 81       	ldd	r24, Y+1	; 0x01
    31ca:	9a 81       	ldd	r25, Y+2	; 0x02
    31cc:	82 17       	cp	r24, r18
    31ce:	93 07       	cpc	r25, r19
    31d0:	80 f5       	brcc	.+96     	; 0x3232 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    31d2:	8f 81       	ldd	r24, Y+7	; 0x07
    31d4:	98 85       	ldd	r25, Y+8	; 0x08
    31d6:	2b 85       	ldd	r18, Y+11	; 0x0b
    31d8:	3c 85       	ldd	r19, Y+12	; 0x0c
    31da:	4d 85       	ldd	r20, Y+13	; 0x0d
    31dc:	5e 85       	ldd	r21, Y+14	; 0x0e
    31de:	eb 81       	ldd	r30, Y+3	; 0x03
    31e0:	fc 81       	ldd	r31, Y+4	; 0x04
    31e2:	a9 81       	ldd	r26, Y+1	; 0x01
    31e4:	ba 81       	ldd	r27, Y+2	; 0x02
    31e6:	b9 01       	movw	r22, r18
    31e8:	9f 01       	movw	r18, r30
    31ea:	8d 01       	movw	r16, r26
    31ec:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvReadMessageFromBuffer>
    31f0:	9e 83       	std	Y+6, r25	; 0x06
    31f2:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    31f4:	8d 81       	ldd	r24, Y+5	; 0x05
    31f6:	9e 81       	ldd	r25, Y+6	; 0x06
    31f8:	00 97       	sbiw	r24, 0x00	; 0
    31fa:	d9 f0       	breq	.+54     	; 0x3232 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    31fc:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
    3200:	ef 81       	ldd	r30, Y+7	; 0x07
    3202:	f8 85       	ldd	r31, Y+8	; 0x08
    3204:	82 85       	ldd	r24, Z+10	; 0x0a
    3206:	93 85       	ldd	r25, Z+11	; 0x0b
    3208:	00 97       	sbiw	r24, 0x00	; 0
    320a:	89 f0       	breq	.+34     	; 0x322e <xStreamBufferReceive+0x152>
    320c:	ef 81       	ldd	r30, Y+7	; 0x07
    320e:	f8 85       	ldd	r31, Y+8	; 0x08
    3210:	82 85       	ldd	r24, Z+10	; 0x0a
    3212:	93 85       	ldd	r25, Z+11	; 0x0b
    3214:	40 e0       	ldi	r20, 0x00	; 0
    3216:	50 e0       	ldi	r21, 0x00	; 0
    3218:	60 e0       	ldi	r22, 0x00	; 0
    321a:	70 e0       	ldi	r23, 0x00	; 0
    321c:	20 e0       	ldi	r18, 0x00	; 0
    321e:	00 e0       	ldi	r16, 0x00	; 0
    3220:	10 e0       	ldi	r17, 0x00	; 0
    3222:	0e 94 01 27 	call	0x4e02	; 0x4e02 <xTaskGenericNotify>
    3226:	ef 81       	ldd	r30, Y+7	; 0x07
    3228:	f8 85       	ldd	r31, Y+8	; 0x08
    322a:	13 86       	std	Z+11, r1	; 0x0b
    322c:	12 86       	std	Z+10, r1	; 0x0a
    322e:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    3232:	8d 81       	ldd	r24, Y+5	; 0x05
    3234:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3236:	60 96       	adiw	r28, 0x10	; 16
    3238:	0f b6       	in	r0, 0x3f	; 63
    323a:	f8 94       	cli
    323c:	de bf       	out	0x3e, r29	; 62
    323e:	0f be       	out	0x3f, r0	; 63
    3240:	cd bf       	out	0x3d, r28	; 61
    3242:	cf 91       	pop	r28
    3244:	df 91       	pop	r29
    3246:	1f 91       	pop	r17
    3248:	0f 91       	pop	r16
    324a:	ff 90       	pop	r15
    324c:	ef 90       	pop	r14
    324e:	08 95       	ret

00003250 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3250:	df 93       	push	r29
    3252:	cf 93       	push	r28
    3254:	cd b7       	in	r28, 0x3d	; 61
    3256:	de b7       	in	r29, 0x3e	; 62
    3258:	2c 97       	sbiw	r28, 0x0c	; 12
    325a:	0f b6       	in	r0, 0x3f	; 63
    325c:	f8 94       	cli
    325e:	de bf       	out	0x3e, r29	; 62
    3260:	0f be       	out	0x3f, r0	; 63
    3262:	cd bf       	out	0x3d, r28	; 61
    3264:	9c 87       	std	Y+12, r25	; 0x0c
    3266:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3268:	8b 85       	ldd	r24, Y+11	; 0x0b
    326a:	9c 85       	ldd	r25, Y+12	; 0x0c
    326c:	98 87       	std	Y+8, r25	; 0x08
    326e:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3270:	ef 81       	ldd	r30, Y+7	; 0x07
    3272:	f8 85       	ldd	r31, Y+8	; 0x08
    3274:	86 85       	ldd	r24, Z+14	; 0x0e
    3276:	88 2f       	mov	r24, r24
    3278:	90 e0       	ldi	r25, 0x00	; 0
    327a:	81 70       	andi	r24, 0x01	; 1
    327c:	90 70       	andi	r25, 0x00	; 0
    327e:	88 23       	and	r24, r24
    3280:	61 f1       	breq	.+88     	; 0x32da <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3282:	8f 81       	ldd	r24, Y+7	; 0x07
    3284:	98 85       	ldd	r25, Y+8	; 0x08
    3286:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    328a:	9c 83       	std	Y+4, r25	; 0x04
    328c:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    328e:	8b 81       	ldd	r24, Y+3	; 0x03
    3290:	9c 81       	ldd	r25, Y+4	; 0x04
    3292:	83 30       	cpi	r24, 0x03	; 3
    3294:	91 05       	cpc	r25, r1
    3296:	f0 f0       	brcs	.+60     	; 0x32d4 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3298:	ef 81       	ldd	r30, Y+7	; 0x07
    329a:	f8 85       	ldd	r31, Y+8	; 0x08
    329c:	80 81       	ld	r24, Z
    329e:	91 81       	ldd	r25, Z+1	; 0x01
    32a0:	9a 83       	std	Y+2, r25	; 0x02
    32a2:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    32a4:	9e 01       	movw	r18, r28
    32a6:	27 5f       	subi	r18, 0xF7	; 247
    32a8:	3f 4f       	sbci	r19, 0xFF	; 255
    32aa:	8f 81       	ldd	r24, Y+7	; 0x07
    32ac:	98 85       	ldd	r25, Y+8	; 0x08
    32ae:	eb 81       	ldd	r30, Y+3	; 0x03
    32b0:	fc 81       	ldd	r31, Y+4	; 0x04
    32b2:	b9 01       	movw	r22, r18
    32b4:	42 e0       	ldi	r20, 0x02	; 2
    32b6:	50 e0       	ldi	r21, 0x00	; 0
    32b8:	9f 01       	movw	r18, r30
    32ba:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    32be:	89 85       	ldd	r24, Y+9	; 0x09
    32c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    32c2:	9e 83       	std	Y+6, r25	; 0x06
    32c4:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    32c6:	ef 81       	ldd	r30, Y+7	; 0x07
    32c8:	f8 85       	ldd	r31, Y+8	; 0x08
    32ca:	89 81       	ldd	r24, Y+1	; 0x01
    32cc:	9a 81       	ldd	r25, Y+2	; 0x02
    32ce:	91 83       	std	Z+1, r25	; 0x01
    32d0:	80 83       	st	Z, r24
    32d2:	05 c0       	rjmp	.+10     	; 0x32de <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    32d4:	1e 82       	std	Y+6, r1	; 0x06
    32d6:	1d 82       	std	Y+5, r1	; 0x05
    32d8:	02 c0       	rjmp	.+4      	; 0x32de <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    32da:	1e 82       	std	Y+6, r1	; 0x06
    32dc:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    32de:	8d 81       	ldd	r24, Y+5	; 0x05
    32e0:	9e 81       	ldd	r25, Y+6	; 0x06
}
    32e2:	2c 96       	adiw	r28, 0x0c	; 12
    32e4:	0f b6       	in	r0, 0x3f	; 63
    32e6:	f8 94       	cli
    32e8:	de bf       	out	0x3e, r29	; 62
    32ea:	0f be       	out	0x3f, r0	; 63
    32ec:	cd bf       	out	0x3d, r28	; 61
    32ee:	cf 91       	pop	r28
    32f0:	df 91       	pop	r29
    32f2:	08 95       	ret

000032f4 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    32f4:	ef 92       	push	r14
    32f6:	ff 92       	push	r15
    32f8:	0f 93       	push	r16
    32fa:	1f 93       	push	r17
    32fc:	df 93       	push	r29
    32fe:	cf 93       	push	r28
    3300:	cd b7       	in	r28, 0x3d	; 61
    3302:	de b7       	in	r29, 0x3e	; 62
    3304:	61 97       	sbiw	r28, 0x11	; 17
    3306:	0f b6       	in	r0, 0x3f	; 63
    3308:	f8 94       	cli
    330a:	de bf       	out	0x3e, r29	; 62
    330c:	0f be       	out	0x3f, r0	; 63
    330e:	cd bf       	out	0x3d, r28	; 61
    3310:	9b 87       	std	Y+11, r25	; 0x0b
    3312:	8a 87       	std	Y+10, r24	; 0x0a
    3314:	7d 87       	std	Y+13, r23	; 0x0d
    3316:	6c 87       	std	Y+12, r22	; 0x0c
    3318:	5f 87       	std	Y+15, r21	; 0x0f
    331a:	4e 87       	std	Y+14, r20	; 0x0e
    331c:	39 8b       	std	Y+17, r19	; 0x11
    331e:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3320:	8a 85       	ldd	r24, Y+10	; 0x0a
    3322:	9b 85       	ldd	r25, Y+11	; 0x0b
    3324:	99 87       	std	Y+9, r25	; 0x09
    3326:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3328:	1f 82       	std	Y+7, r1	; 0x07
    332a:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    332c:	e8 85       	ldd	r30, Y+8	; 0x08
    332e:	f9 85       	ldd	r31, Y+9	; 0x09
    3330:	86 85       	ldd	r24, Z+14	; 0x0e
    3332:	88 2f       	mov	r24, r24
    3334:	90 e0       	ldi	r25, 0x00	; 0
    3336:	81 70       	andi	r24, 0x01	; 1
    3338:	90 70       	andi	r25, 0x00	; 0
    333a:	88 23       	and	r24, r24
    333c:	29 f0       	breq	.+10     	; 0x3348 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    333e:	82 e0       	ldi	r24, 0x02	; 2
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	9b 83       	std	Y+3, r25	; 0x03
    3344:	8a 83       	std	Y+2, r24	; 0x02
    3346:	02 c0       	rjmp	.+4      	; 0x334c <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3348:	1b 82       	std	Y+3, r1	; 0x03
    334a:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    334c:	88 85       	ldd	r24, Y+8	; 0x08
    334e:	99 85       	ldd	r25, Y+9	; 0x09
    3350:	0e 94 83 1c 	call	0x3906	; 0x3906 <prvBytesInBuffer>
    3354:	9d 83       	std	Y+5, r25	; 0x05
    3356:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3358:	2c 81       	ldd	r18, Y+4	; 0x04
    335a:	3d 81       	ldd	r19, Y+5	; 0x05
    335c:	8a 81       	ldd	r24, Y+2	; 0x02
    335e:	9b 81       	ldd	r25, Y+3	; 0x03
    3360:	82 17       	cp	r24, r18
    3362:	93 07       	cpc	r25, r19
    3364:	80 f5       	brcc	.+96     	; 0x33c6 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3366:	88 85       	ldd	r24, Y+8	; 0x08
    3368:	99 85       	ldd	r25, Y+9	; 0x09
    336a:	2c 85       	ldd	r18, Y+12	; 0x0c
    336c:	3d 85       	ldd	r19, Y+13	; 0x0d
    336e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3370:	5f 85       	ldd	r21, Y+15	; 0x0f
    3372:	ec 81       	ldd	r30, Y+4	; 0x04
    3374:	fd 81       	ldd	r31, Y+5	; 0x05
    3376:	aa 81       	ldd	r26, Y+2	; 0x02
    3378:	bb 81       	ldd	r27, Y+3	; 0x03
    337a:	b9 01       	movw	r22, r18
    337c:	9f 01       	movw	r18, r30
    337e:	8d 01       	movw	r16, r26
    3380:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <prvReadMessageFromBuffer>
    3384:	9f 83       	std	Y+7, r25	; 0x07
    3386:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3388:	8e 81       	ldd	r24, Y+6	; 0x06
    338a:	9f 81       	ldd	r25, Y+7	; 0x07
    338c:	00 97       	sbiw	r24, 0x00	; 0
    338e:	d9 f0       	breq	.+54     	; 0x33c6 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3390:	19 82       	std	Y+1, r1	; 0x01
    3392:	e8 85       	ldd	r30, Y+8	; 0x08
    3394:	f9 85       	ldd	r31, Y+9	; 0x09
    3396:	82 85       	ldd	r24, Z+10	; 0x0a
    3398:	93 85       	ldd	r25, Z+11	; 0x0b
    339a:	00 97       	sbiw	r24, 0x00	; 0
    339c:	a1 f0       	breq	.+40     	; 0x33c6 <xStreamBufferReceiveFromISR+0xd2>
    339e:	e8 85       	ldd	r30, Y+8	; 0x08
    33a0:	f9 85       	ldd	r31, Y+9	; 0x09
    33a2:	82 85       	ldd	r24, Z+10	; 0x0a
    33a4:	93 85       	ldd	r25, Z+11	; 0x0b
    33a6:	e8 89       	ldd	r30, Y+16	; 0x10
    33a8:	f9 89       	ldd	r31, Y+17	; 0x11
    33aa:	40 e0       	ldi	r20, 0x00	; 0
    33ac:	50 e0       	ldi	r21, 0x00	; 0
    33ae:	60 e0       	ldi	r22, 0x00	; 0
    33b0:	70 e0       	ldi	r23, 0x00	; 0
    33b2:	20 e0       	ldi	r18, 0x00	; 0
    33b4:	00 e0       	ldi	r16, 0x00	; 0
    33b6:	10 e0       	ldi	r17, 0x00	; 0
    33b8:	7f 01       	movw	r14, r30
    33ba:	0e 94 de 27 	call	0x4fbc	; 0x4fbc <xTaskGenericNotifyFromISR>
    33be:	e8 85       	ldd	r30, Y+8	; 0x08
    33c0:	f9 85       	ldd	r31, Y+9	; 0x09
    33c2:	13 86       	std	Z+11, r1	; 0x0b
    33c4:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    33c6:	8e 81       	ldd	r24, Y+6	; 0x06
    33c8:	9f 81       	ldd	r25, Y+7	; 0x07
}
    33ca:	61 96       	adiw	r28, 0x11	; 17
    33cc:	0f b6       	in	r0, 0x3f	; 63
    33ce:	f8 94       	cli
    33d0:	de bf       	out	0x3e, r29	; 62
    33d2:	0f be       	out	0x3f, r0	; 63
    33d4:	cd bf       	out	0x3d, r28	; 61
    33d6:	cf 91       	pop	r28
    33d8:	df 91       	pop	r29
    33da:	1f 91       	pop	r17
    33dc:	0f 91       	pop	r16
    33de:	ff 90       	pop	r15
    33e0:	ef 90       	pop	r14
    33e2:	08 95       	ret

000033e4 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    33e4:	0f 93       	push	r16
    33e6:	1f 93       	push	r17
    33e8:	df 93       	push	r29
    33ea:	cf 93       	push	r28
    33ec:	cd b7       	in	r28, 0x3d	; 61
    33ee:	de b7       	in	r29, 0x3e	; 62
    33f0:	62 97       	sbiw	r28, 0x12	; 18
    33f2:	0f b6       	in	r0, 0x3f	; 63
    33f4:	f8 94       	cli
    33f6:	de bf       	out	0x3e, r29	; 62
    33f8:	0f be       	out	0x3f, r0	; 63
    33fa:	cd bf       	out	0x3d, r28	; 61
    33fc:	9a 87       	std	Y+10, r25	; 0x0a
    33fe:	89 87       	std	Y+9, r24	; 0x09
    3400:	7c 87       	std	Y+12, r23	; 0x0c
    3402:	6b 87       	std	Y+11, r22	; 0x0b
    3404:	5e 87       	std	Y+14, r21	; 0x0e
    3406:	4d 87       	std	Y+13, r20	; 0x0d
    3408:	38 8b       	std	Y+16, r19	; 0x10
    340a:	2f 87       	std	Y+15, r18	; 0x0f
    340c:	1a 8b       	std	Y+18, r17	; 0x12
    340e:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3410:	89 89       	ldd	r24, Y+17	; 0x11
    3412:	9a 89       	ldd	r25, Y+18	; 0x12
    3414:	00 97       	sbiw	r24, 0x00	; 0
    3416:	91 f1       	breq	.+100    	; 0x347c <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3418:	e9 85       	ldd	r30, Y+9	; 0x09
    341a:	fa 85       	ldd	r31, Y+10	; 0x0a
    341c:	80 81       	ld	r24, Z
    341e:	91 81       	ldd	r25, Z+1	; 0x01
    3420:	9e 83       	std	Y+6, r25	; 0x06
    3422:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    3424:	ae 01       	movw	r20, r28
    3426:	49 5f       	subi	r20, 0xF9	; 249
    3428:	5f 4f       	sbci	r21, 0xFF	; 255
    342a:	89 85       	ldd	r24, Y+9	; 0x09
    342c:	9a 85       	ldd	r25, Y+10	; 0x0a
    342e:	29 89       	ldd	r18, Y+17	; 0x11
    3430:	3a 89       	ldd	r19, Y+18	; 0x12
    3432:	ef 85       	ldd	r30, Y+15	; 0x0f
    3434:	f8 89       	ldd	r31, Y+16	; 0x10
    3436:	ba 01       	movw	r22, r20
    3438:	a9 01       	movw	r20, r18
    343a:	9f 01       	movw	r18, r30
    343c:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3440:	8f 81       	ldd	r24, Y+7	; 0x07
    3442:	98 85       	ldd	r25, Y+8	; 0x08
    3444:	9a 83       	std	Y+2, r25	; 0x02
    3446:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3448:	2f 85       	ldd	r18, Y+15	; 0x0f
    344a:	38 89       	ldd	r19, Y+16	; 0x10
    344c:	89 89       	ldd	r24, Y+17	; 0x11
    344e:	9a 89       	ldd	r25, Y+18	; 0x12
    3450:	a9 01       	movw	r20, r18
    3452:	48 1b       	sub	r20, r24
    3454:	59 0b       	sbc	r21, r25
    3456:	ca 01       	movw	r24, r20
    3458:	98 8b       	std	Y+16, r25	; 0x10
    345a:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    345c:	29 81       	ldd	r18, Y+1	; 0x01
    345e:	3a 81       	ldd	r19, Y+2	; 0x02
    3460:	8d 85       	ldd	r24, Y+13	; 0x0d
    3462:	9e 85       	ldd	r25, Y+14	; 0x0e
    3464:	82 17       	cp	r24, r18
    3466:	93 07       	cpc	r25, r19
    3468:	68 f4       	brcc	.+26     	; 0x3484 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    346a:	e9 85       	ldd	r30, Y+9	; 0x09
    346c:	fa 85       	ldd	r31, Y+10	; 0x0a
    346e:	8d 81       	ldd	r24, Y+5	; 0x05
    3470:	9e 81       	ldd	r25, Y+6	; 0x06
    3472:	91 83       	std	Z+1, r25	; 0x01
    3474:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    3476:	1a 82       	std	Y+2, r1	; 0x02
    3478:	19 82       	std	Y+1, r1	; 0x01
    347a:	04 c0       	rjmp	.+8      	; 0x3484 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    347c:	8d 85       	ldd	r24, Y+13	; 0x0d
    347e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3480:	9a 83       	std	Y+2, r25	; 0x02
    3482:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3484:	4b 85       	ldd	r20, Y+11	; 0x0b
    3486:	5c 85       	ldd	r21, Y+12	; 0x0c
    3488:	89 85       	ldd	r24, Y+9	; 0x09
    348a:	9a 85       	ldd	r25, Y+10	; 0x0a
    348c:	29 81       	ldd	r18, Y+1	; 0x01
    348e:	3a 81       	ldd	r19, Y+2	; 0x02
    3490:	ef 85       	ldd	r30, Y+15	; 0x0f
    3492:	f8 89       	ldd	r31, Y+16	; 0x10
    3494:	ba 01       	movw	r22, r20
    3496:	a9 01       	movw	r20, r18
    3498:	9f 01       	movw	r18, r30
    349a:	0e 94 d6 1b 	call	0x37ac	; 0x37ac <prvReadBytesFromBuffer>
    349e:	9c 83       	std	Y+4, r25	; 0x04
    34a0:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    34a2:	8b 81       	ldd	r24, Y+3	; 0x03
    34a4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    34a6:	62 96       	adiw	r28, 0x12	; 18
    34a8:	0f b6       	in	r0, 0x3f	; 63
    34aa:	f8 94       	cli
    34ac:	de bf       	out	0x3e, r29	; 62
    34ae:	0f be       	out	0x3f, r0	; 63
    34b0:	cd bf       	out	0x3d, r28	; 61
    34b2:	cf 91       	pop	r28
    34b4:	df 91       	pop	r29
    34b6:	1f 91       	pop	r17
    34b8:	0f 91       	pop	r16
    34ba:	08 95       	ret

000034bc <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    34bc:	df 93       	push	r29
    34be:	cf 93       	push	r28
    34c0:	cd b7       	in	r28, 0x3d	; 61
    34c2:	de b7       	in	r29, 0x3e	; 62
    34c4:	27 97       	sbiw	r28, 0x07	; 7
    34c6:	0f b6       	in	r0, 0x3f	; 63
    34c8:	f8 94       	cli
    34ca:	de bf       	out	0x3e, r29	; 62
    34cc:	0f be       	out	0x3f, r0	; 63
    34ce:	cd bf       	out	0x3d, r28	; 61
    34d0:	9f 83       	std	Y+7, r25	; 0x07
    34d2:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    34d4:	8e 81       	ldd	r24, Y+6	; 0x06
    34d6:	9f 81       	ldd	r25, Y+7	; 0x07
    34d8:	9d 83       	std	Y+5, r25	; 0x05
    34da:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    34dc:	ec 81       	ldd	r30, Y+4	; 0x04
    34de:	fd 81       	ldd	r31, Y+5	; 0x05
    34e0:	80 81       	ld	r24, Z
    34e2:	91 81       	ldd	r25, Z+1	; 0x01
    34e4:	9a 83       	std	Y+2, r25	; 0x02
    34e6:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    34e8:	ec 81       	ldd	r30, Y+4	; 0x04
    34ea:	fd 81       	ldd	r31, Y+5	; 0x05
    34ec:	22 81       	ldd	r18, Z+2	; 0x02
    34ee:	33 81       	ldd	r19, Z+3	; 0x03
    34f0:	89 81       	ldd	r24, Y+1	; 0x01
    34f2:	9a 81       	ldd	r25, Y+2	; 0x02
    34f4:	28 17       	cp	r18, r24
    34f6:	39 07       	cpc	r19, r25
    34f8:	19 f4       	brne	.+6      	; 0x3500 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    34fa:	81 e0       	ldi	r24, 0x01	; 1
    34fc:	8b 83       	std	Y+3, r24	; 0x03
    34fe:	01 c0       	rjmp	.+2      	; 0x3502 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    3500:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3502:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3504:	27 96       	adiw	r28, 0x07	; 7
    3506:	0f b6       	in	r0, 0x3f	; 63
    3508:	f8 94       	cli
    350a:	de bf       	out	0x3e, r29	; 62
    350c:	0f be       	out	0x3f, r0	; 63
    350e:	cd bf       	out	0x3d, r28	; 61
    3510:	cf 91       	pop	r28
    3512:	df 91       	pop	r29
    3514:	08 95       	ret

00003516 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    3516:	df 93       	push	r29
    3518:	cf 93       	push	r28
    351a:	cd b7       	in	r28, 0x3d	; 61
    351c:	de b7       	in	r29, 0x3e	; 62
    351e:	27 97       	sbiw	r28, 0x07	; 7
    3520:	0f b6       	in	r0, 0x3f	; 63
    3522:	f8 94       	cli
    3524:	de bf       	out	0x3e, r29	; 62
    3526:	0f be       	out	0x3f, r0	; 63
    3528:	cd bf       	out	0x3d, r28	; 61
    352a:	9f 83       	std	Y+7, r25	; 0x07
    352c:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    352e:	8e 81       	ldd	r24, Y+6	; 0x06
    3530:	9f 81       	ldd	r25, Y+7	; 0x07
    3532:	9a 83       	std	Y+2, r25	; 0x02
    3534:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3536:	e9 81       	ldd	r30, Y+1	; 0x01
    3538:	fa 81       	ldd	r31, Y+2	; 0x02
    353a:	86 85       	ldd	r24, Z+14	; 0x0e
    353c:	88 2f       	mov	r24, r24
    353e:	90 e0       	ldi	r25, 0x00	; 0
    3540:	81 70       	andi	r24, 0x01	; 1
    3542:	90 70       	andi	r25, 0x00	; 0
    3544:	88 23       	and	r24, r24
    3546:	29 f0       	breq	.+10     	; 0x3552 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3548:	82 e0       	ldi	r24, 0x02	; 2
    354a:	90 e0       	ldi	r25, 0x00	; 0
    354c:	9c 83       	std	Y+4, r25	; 0x04
    354e:	8b 83       	std	Y+3, r24	; 0x03
    3550:	02 c0       	rjmp	.+4      	; 0x3556 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3552:	1c 82       	std	Y+4, r1	; 0x04
    3554:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    3556:	8e 81       	ldd	r24, Y+6	; 0x06
    3558:	9f 81       	ldd	r25, Y+7	; 0x07
    355a:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xStreamBufferSpacesAvailable>
    355e:	9c 01       	movw	r18, r24
    3560:	8b 81       	ldd	r24, Y+3	; 0x03
    3562:	9c 81       	ldd	r25, Y+4	; 0x04
    3564:	82 17       	cp	r24, r18
    3566:	93 07       	cpc	r25, r19
    3568:	18 f0       	brcs	.+6      	; 0x3570 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    356a:	81 e0       	ldi	r24, 0x01	; 1
    356c:	8d 83       	std	Y+5, r24	; 0x05
    356e:	01 c0       	rjmp	.+2      	; 0x3572 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    3570:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3572:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3574:	27 96       	adiw	r28, 0x07	; 7
    3576:	0f b6       	in	r0, 0x3f	; 63
    3578:	f8 94       	cli
    357a:	de bf       	out	0x3e, r29	; 62
    357c:	0f be       	out	0x3f, r0	; 63
    357e:	cd bf       	out	0x3d, r28	; 61
    3580:	cf 91       	pop	r28
    3582:	df 91       	pop	r29
    3584:	08 95       	ret

00003586 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3586:	ef 92       	push	r14
    3588:	ff 92       	push	r15
    358a:	0f 93       	push	r16
    358c:	1f 93       	push	r17
    358e:	df 93       	push	r29
    3590:	cf 93       	push	r28
    3592:	cd b7       	in	r28, 0x3d	; 61
    3594:	de b7       	in	r29, 0x3e	; 62
    3596:	28 97       	sbiw	r28, 0x08	; 8
    3598:	0f b6       	in	r0, 0x3f	; 63
    359a:	f8 94       	cli
    359c:	de bf       	out	0x3e, r29	; 62
    359e:	0f be       	out	0x3f, r0	; 63
    35a0:	cd bf       	out	0x3d, r28	; 61
    35a2:	9e 83       	std	Y+6, r25	; 0x06
    35a4:	8d 83       	std	Y+5, r24	; 0x05
    35a6:	78 87       	std	Y+8, r23	; 0x08
    35a8:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    35aa:	8d 81       	ldd	r24, Y+5	; 0x05
    35ac:	9e 81       	ldd	r25, Y+6	; 0x06
    35ae:	9c 83       	std	Y+4, r25	; 0x04
    35b0:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    35b2:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    35b4:	eb 81       	ldd	r30, Y+3	; 0x03
    35b6:	fc 81       	ldd	r31, Y+4	; 0x04
    35b8:	80 85       	ldd	r24, Z+8	; 0x08
    35ba:	91 85       	ldd	r25, Z+9	; 0x09
    35bc:	00 97       	sbiw	r24, 0x00	; 0
    35be:	b9 f0       	breq	.+46     	; 0x35ee <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    35c0:	eb 81       	ldd	r30, Y+3	; 0x03
    35c2:	fc 81       	ldd	r31, Y+4	; 0x04
    35c4:	80 85       	ldd	r24, Z+8	; 0x08
    35c6:	91 85       	ldd	r25, Z+9	; 0x09
    35c8:	ef 81       	ldd	r30, Y+7	; 0x07
    35ca:	f8 85       	ldd	r31, Y+8	; 0x08
    35cc:	40 e0       	ldi	r20, 0x00	; 0
    35ce:	50 e0       	ldi	r21, 0x00	; 0
    35d0:	60 e0       	ldi	r22, 0x00	; 0
    35d2:	70 e0       	ldi	r23, 0x00	; 0
    35d4:	20 e0       	ldi	r18, 0x00	; 0
    35d6:	00 e0       	ldi	r16, 0x00	; 0
    35d8:	10 e0       	ldi	r17, 0x00	; 0
    35da:	7f 01       	movw	r14, r30
    35dc:	0e 94 de 27 	call	0x4fbc	; 0x4fbc <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    35e0:	eb 81       	ldd	r30, Y+3	; 0x03
    35e2:	fc 81       	ldd	r31, Y+4	; 0x04
    35e4:	11 86       	std	Z+9, r1	; 0x09
    35e6:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	8a 83       	std	Y+2, r24	; 0x02
    35ec:	01 c0       	rjmp	.+2      	; 0x35f0 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    35ee:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    35f0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    35f2:	28 96       	adiw	r28, 0x08	; 8
    35f4:	0f b6       	in	r0, 0x3f	; 63
    35f6:	f8 94       	cli
    35f8:	de bf       	out	0x3e, r29	; 62
    35fa:	0f be       	out	0x3f, r0	; 63
    35fc:	cd bf       	out	0x3d, r28	; 61
    35fe:	cf 91       	pop	r28
    3600:	df 91       	pop	r29
    3602:	1f 91       	pop	r17
    3604:	0f 91       	pop	r16
    3606:	ff 90       	pop	r15
    3608:	ef 90       	pop	r14
    360a:	08 95       	ret

0000360c <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    360c:	ef 92       	push	r14
    360e:	ff 92       	push	r15
    3610:	0f 93       	push	r16
    3612:	1f 93       	push	r17
    3614:	df 93       	push	r29
    3616:	cf 93       	push	r28
    3618:	cd b7       	in	r28, 0x3d	; 61
    361a:	de b7       	in	r29, 0x3e	; 62
    361c:	28 97       	sbiw	r28, 0x08	; 8
    361e:	0f b6       	in	r0, 0x3f	; 63
    3620:	f8 94       	cli
    3622:	de bf       	out	0x3e, r29	; 62
    3624:	0f be       	out	0x3f, r0	; 63
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	9e 83       	std	Y+6, r25	; 0x06
    362a:	8d 83       	std	Y+5, r24	; 0x05
    362c:	78 87       	std	Y+8, r23	; 0x08
    362e:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3630:	8d 81       	ldd	r24, Y+5	; 0x05
    3632:	9e 81       	ldd	r25, Y+6	; 0x06
    3634:	9c 83       	std	Y+4, r25	; 0x04
    3636:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3638:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    363a:	eb 81       	ldd	r30, Y+3	; 0x03
    363c:	fc 81       	ldd	r31, Y+4	; 0x04
    363e:	82 85       	ldd	r24, Z+10	; 0x0a
    3640:	93 85       	ldd	r25, Z+11	; 0x0b
    3642:	00 97       	sbiw	r24, 0x00	; 0
    3644:	b9 f0       	breq	.+46     	; 0x3674 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3646:	eb 81       	ldd	r30, Y+3	; 0x03
    3648:	fc 81       	ldd	r31, Y+4	; 0x04
    364a:	82 85       	ldd	r24, Z+10	; 0x0a
    364c:	93 85       	ldd	r25, Z+11	; 0x0b
    364e:	ef 81       	ldd	r30, Y+7	; 0x07
    3650:	f8 85       	ldd	r31, Y+8	; 0x08
    3652:	40 e0       	ldi	r20, 0x00	; 0
    3654:	50 e0       	ldi	r21, 0x00	; 0
    3656:	60 e0       	ldi	r22, 0x00	; 0
    3658:	70 e0       	ldi	r23, 0x00	; 0
    365a:	20 e0       	ldi	r18, 0x00	; 0
    365c:	00 e0       	ldi	r16, 0x00	; 0
    365e:	10 e0       	ldi	r17, 0x00	; 0
    3660:	7f 01       	movw	r14, r30
    3662:	0e 94 de 27 	call	0x4fbc	; 0x4fbc <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3666:	eb 81       	ldd	r30, Y+3	; 0x03
    3668:	fc 81       	ldd	r31, Y+4	; 0x04
    366a:	13 86       	std	Z+11, r1	; 0x0b
    366c:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    366e:	81 e0       	ldi	r24, 0x01	; 1
    3670:	8a 83       	std	Y+2, r24	; 0x02
    3672:	01 c0       	rjmp	.+2      	; 0x3676 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3674:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3676:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3678:	28 96       	adiw	r28, 0x08	; 8
    367a:	0f b6       	in	r0, 0x3f	; 63
    367c:	f8 94       	cli
    367e:	de bf       	out	0x3e, r29	; 62
    3680:	0f be       	out	0x3f, r0	; 63
    3682:	cd bf       	out	0x3d, r28	; 61
    3684:	cf 91       	pop	r28
    3686:	df 91       	pop	r29
    3688:	1f 91       	pop	r17
    368a:	0f 91       	pop	r16
    368c:	ff 90       	pop	r15
    368e:	ef 90       	pop	r14
    3690:	08 95       	ret

00003692 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3692:	df 93       	push	r29
    3694:	cf 93       	push	r28
    3696:	cd b7       	in	r28, 0x3d	; 61
    3698:	de b7       	in	r29, 0x3e	; 62
    369a:	2e 97       	sbiw	r28, 0x0e	; 14
    369c:	0f b6       	in	r0, 0x3f	; 63
    369e:	f8 94       	cli
    36a0:	de bf       	out	0x3e, r29	; 62
    36a2:	0f be       	out	0x3f, r0	; 63
    36a4:	cd bf       	out	0x3d, r28	; 61
    36a6:	9e 83       	std	Y+6, r25	; 0x06
    36a8:	8d 83       	std	Y+5, r24	; 0x05
    36aa:	78 87       	std	Y+8, r23	; 0x08
    36ac:	6f 83       	std	Y+7, r22	; 0x07
    36ae:	5a 87       	std	Y+10, r21	; 0x0a
    36b0:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    36b2:	ed 81       	ldd	r30, Y+5	; 0x05
    36b4:	fe 81       	ldd	r31, Y+6	; 0x06
    36b6:	82 81       	ldd	r24, Z+2	; 0x02
    36b8:	93 81       	ldd	r25, Z+3	; 0x03
    36ba:	9c 83       	std	Y+4, r25	; 0x04
    36bc:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    36be:	ed 81       	ldd	r30, Y+5	; 0x05
    36c0:	fe 81       	ldd	r31, Y+6	; 0x06
    36c2:	24 81       	ldd	r18, Z+4	; 0x04
    36c4:	35 81       	ldd	r19, Z+5	; 0x05
    36c6:	8b 81       	ldd	r24, Y+3	; 0x03
    36c8:	9c 81       	ldd	r25, Y+4	; 0x04
    36ca:	a9 01       	movw	r20, r18
    36cc:	48 1b       	sub	r20, r24
    36ce:	59 0b       	sbc	r21, r25
    36d0:	ca 01       	movw	r24, r20
    36d2:	29 85       	ldd	r18, Y+9	; 0x09
    36d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    36d6:	3e 87       	std	Y+14, r19	; 0x0e
    36d8:	2d 87       	std	Y+13, r18	; 0x0d
    36da:	9c 87       	std	Y+12, r25	; 0x0c
    36dc:	8b 87       	std	Y+11, r24	; 0x0b
    36de:	4b 85       	ldd	r20, Y+11	; 0x0b
    36e0:	5c 85       	ldd	r21, Y+12	; 0x0c
    36e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    36e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    36e6:	84 17       	cp	r24, r20
    36e8:	95 07       	cpc	r25, r21
    36ea:	20 f4       	brcc	.+8      	; 0x36f4 <prvWriteBytesToBuffer+0x62>
    36ec:	2d 85       	ldd	r18, Y+13	; 0x0d
    36ee:	3e 85       	ldd	r19, Y+14	; 0x0e
    36f0:	3c 87       	std	Y+12, r19	; 0x0c
    36f2:	2b 87       	std	Y+11, r18	; 0x0b
    36f4:	4b 85       	ldd	r20, Y+11	; 0x0b
    36f6:	5c 85       	ldd	r21, Y+12	; 0x0c
    36f8:	5a 83       	std	Y+2, r21	; 0x02
    36fa:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    36fc:	ed 81       	ldd	r30, Y+5	; 0x05
    36fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3700:	24 85       	ldd	r18, Z+12	; 0x0c
    3702:	35 85       	ldd	r19, Z+13	; 0x0d
    3704:	8b 81       	ldd	r24, Y+3	; 0x03
    3706:	9c 81       	ldd	r25, Y+4	; 0x04
    3708:	82 0f       	add	r24, r18
    370a:	93 1f       	adc	r25, r19
    370c:	2f 81       	ldd	r18, Y+7	; 0x07
    370e:	38 85       	ldd	r19, Y+8	; 0x08
    3710:	49 81       	ldd	r20, Y+1	; 0x01
    3712:	5a 81       	ldd	r21, Y+2	; 0x02
    3714:	b9 01       	movw	r22, r18
    3716:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    371a:	29 85       	ldd	r18, Y+9	; 0x09
    371c:	3a 85       	ldd	r19, Y+10	; 0x0a
    371e:	89 81       	ldd	r24, Y+1	; 0x01
    3720:	9a 81       	ldd	r25, Y+2	; 0x02
    3722:	82 17       	cp	r24, r18
    3724:	93 07       	cpc	r25, r19
    3726:	b0 f4       	brcc	.+44     	; 0x3754 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3728:	ed 81       	ldd	r30, Y+5	; 0x05
    372a:	fe 81       	ldd	r31, Y+6	; 0x06
    372c:	64 85       	ldd	r22, Z+12	; 0x0c
    372e:	75 85       	ldd	r23, Z+13	; 0x0d
    3730:	2f 81       	ldd	r18, Y+7	; 0x07
    3732:	38 85       	ldd	r19, Y+8	; 0x08
    3734:	89 81       	ldd	r24, Y+1	; 0x01
    3736:	9a 81       	ldd	r25, Y+2	; 0x02
    3738:	a9 01       	movw	r20, r18
    373a:	48 0f       	add	r20, r24
    373c:	59 1f       	adc	r21, r25
    373e:	29 85       	ldd	r18, Y+9	; 0x09
    3740:	3a 85       	ldd	r19, Y+10	; 0x0a
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	9a 81       	ldd	r25, Y+2	; 0x02
    3746:	28 1b       	sub	r18, r24
    3748:	39 0b       	sbc	r19, r25
    374a:	cb 01       	movw	r24, r22
    374c:	ba 01       	movw	r22, r20
    374e:	a9 01       	movw	r20, r18
    3750:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3754:	2b 81       	ldd	r18, Y+3	; 0x03
    3756:	3c 81       	ldd	r19, Y+4	; 0x04
    3758:	89 85       	ldd	r24, Y+9	; 0x09
    375a:	9a 85       	ldd	r25, Y+10	; 0x0a
    375c:	82 0f       	add	r24, r18
    375e:	93 1f       	adc	r25, r19
    3760:	9c 83       	std	Y+4, r25	; 0x04
    3762:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    3764:	ed 81       	ldd	r30, Y+5	; 0x05
    3766:	fe 81       	ldd	r31, Y+6	; 0x06
    3768:	24 81       	ldd	r18, Z+4	; 0x04
    376a:	35 81       	ldd	r19, Z+5	; 0x05
    376c:	8b 81       	ldd	r24, Y+3	; 0x03
    376e:	9c 81       	ldd	r25, Y+4	; 0x04
    3770:	82 17       	cp	r24, r18
    3772:	93 07       	cpc	r25, r19
    3774:	50 f0       	brcs	.+20     	; 0x378a <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3776:	ed 81       	ldd	r30, Y+5	; 0x05
    3778:	fe 81       	ldd	r31, Y+6	; 0x06
    377a:	24 81       	ldd	r18, Z+4	; 0x04
    377c:	35 81       	ldd	r19, Z+5	; 0x05
    377e:	8b 81       	ldd	r24, Y+3	; 0x03
    3780:	9c 81       	ldd	r25, Y+4	; 0x04
    3782:	82 1b       	sub	r24, r18
    3784:	93 0b       	sbc	r25, r19
    3786:	9c 83       	std	Y+4, r25	; 0x04
    3788:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    378a:	ed 81       	ldd	r30, Y+5	; 0x05
    378c:	fe 81       	ldd	r31, Y+6	; 0x06
    378e:	8b 81       	ldd	r24, Y+3	; 0x03
    3790:	9c 81       	ldd	r25, Y+4	; 0x04
    3792:	93 83       	std	Z+3, r25	; 0x03
    3794:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    3796:	89 85       	ldd	r24, Y+9	; 0x09
    3798:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    379a:	2e 96       	adiw	r28, 0x0e	; 14
    379c:	0f b6       	in	r0, 0x3f	; 63
    379e:	f8 94       	cli
    37a0:	de bf       	out	0x3e, r29	; 62
    37a2:	0f be       	out	0x3f, r0	; 63
    37a4:	cd bf       	out	0x3d, r28	; 61
    37a6:	cf 91       	pop	r28
    37a8:	df 91       	pop	r29
    37aa:	08 95       	ret

000037ac <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    37ac:	df 93       	push	r29
    37ae:	cf 93       	push	r28
    37b0:	cd b7       	in	r28, 0x3d	; 61
    37b2:	de b7       	in	r29, 0x3e	; 62
    37b4:	66 97       	sbiw	r28, 0x16	; 22
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	f8 94       	cli
    37ba:	de bf       	out	0x3e, r29	; 62
    37bc:	0f be       	out	0x3f, r0	; 63
    37be:	cd bf       	out	0x3d, r28	; 61
    37c0:	98 87       	std	Y+8, r25	; 0x08
    37c2:	8f 83       	std	Y+7, r24	; 0x07
    37c4:	7a 87       	std	Y+10, r23	; 0x0a
    37c6:	69 87       	std	Y+9, r22	; 0x09
    37c8:	5c 87       	std	Y+12, r21	; 0x0c
    37ca:	4b 87       	std	Y+11, r20	; 0x0b
    37cc:	3e 87       	std	Y+14, r19	; 0x0e
    37ce:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    37d0:	2d 85       	ldd	r18, Y+13	; 0x0d
    37d2:	3e 85       	ldd	r19, Y+14	; 0x0e
    37d4:	3a 8b       	std	Y+18, r19	; 0x12
    37d6:	29 8b       	std	Y+17, r18	; 0x11
    37d8:	4b 85       	ldd	r20, Y+11	; 0x0b
    37da:	5c 85       	ldd	r21, Y+12	; 0x0c
    37dc:	58 8b       	std	Y+16, r21	; 0x10
    37de:	4f 87       	std	Y+15, r20	; 0x0f
    37e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    37e2:	98 89       	ldd	r25, Y+16	; 0x10
    37e4:	29 89       	ldd	r18, Y+17	; 0x11
    37e6:	3a 89       	ldd	r19, Y+18	; 0x12
    37e8:	28 17       	cp	r18, r24
    37ea:	39 07       	cpc	r19, r25
    37ec:	20 f4       	brcc	.+8      	; 0x37f6 <prvReadBytesFromBuffer+0x4a>
    37ee:	49 89       	ldd	r20, Y+17	; 0x11
    37f0:	5a 89       	ldd	r21, Y+18	; 0x12
    37f2:	58 8b       	std	Y+16, r21	; 0x10
    37f4:	4f 87       	std	Y+15, r20	; 0x0f
    37f6:	8f 85       	ldd	r24, Y+15	; 0x0f
    37f8:	98 89       	ldd	r25, Y+16	; 0x10
    37fa:	9e 83       	std	Y+6, r25	; 0x06
    37fc:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    37fe:	8d 81       	ldd	r24, Y+5	; 0x05
    3800:	9e 81       	ldd	r25, Y+6	; 0x06
    3802:	00 97       	sbiw	r24, 0x00	; 0
    3804:	09 f4       	brne	.+2      	; 0x3808 <prvReadBytesFromBuffer+0x5c>
    3806:	74 c0       	rjmp	.+232    	; 0x38f0 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3808:	ef 81       	ldd	r30, Y+7	; 0x07
    380a:	f8 85       	ldd	r31, Y+8	; 0x08
    380c:	80 81       	ld	r24, Z
    380e:	91 81       	ldd	r25, Z+1	; 0x01
    3810:	9a 83       	std	Y+2, r25	; 0x02
    3812:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3814:	ef 81       	ldd	r30, Y+7	; 0x07
    3816:	f8 85       	ldd	r31, Y+8	; 0x08
    3818:	24 81       	ldd	r18, Z+4	; 0x04
    381a:	35 81       	ldd	r19, Z+5	; 0x05
    381c:	89 81       	ldd	r24, Y+1	; 0x01
    381e:	9a 81       	ldd	r25, Y+2	; 0x02
    3820:	a9 01       	movw	r20, r18
    3822:	48 1b       	sub	r20, r24
    3824:	59 0b       	sbc	r21, r25
    3826:	ca 01       	movw	r24, r20
    3828:	2d 81       	ldd	r18, Y+5	; 0x05
    382a:	3e 81       	ldd	r19, Y+6	; 0x06
    382c:	3e 8b       	std	Y+22, r19	; 0x16
    382e:	2d 8b       	std	Y+21, r18	; 0x15
    3830:	9c 8b       	std	Y+20, r25	; 0x14
    3832:	8b 8b       	std	Y+19, r24	; 0x13
    3834:	4b 89       	ldd	r20, Y+19	; 0x13
    3836:	5c 89       	ldd	r21, Y+20	; 0x14
    3838:	8d 89       	ldd	r24, Y+21	; 0x15
    383a:	9e 89       	ldd	r25, Y+22	; 0x16
    383c:	84 17       	cp	r24, r20
    383e:	95 07       	cpc	r25, r21
    3840:	20 f4       	brcc	.+8      	; 0x384a <prvReadBytesFromBuffer+0x9e>
    3842:	2d 89       	ldd	r18, Y+21	; 0x15
    3844:	3e 89       	ldd	r19, Y+22	; 0x16
    3846:	3c 8b       	std	Y+20, r19	; 0x14
    3848:	2b 8b       	std	Y+19, r18	; 0x13
    384a:	4b 89       	ldd	r20, Y+19	; 0x13
    384c:	5c 89       	ldd	r21, Y+20	; 0x14
    384e:	5c 83       	std	Y+4, r21	; 0x04
    3850:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3852:	ef 81       	ldd	r30, Y+7	; 0x07
    3854:	f8 85       	ldd	r31, Y+8	; 0x08
    3856:	24 85       	ldd	r18, Z+12	; 0x0c
    3858:	35 85       	ldd	r19, Z+13	; 0x0d
    385a:	89 81       	ldd	r24, Y+1	; 0x01
    385c:	9a 81       	ldd	r25, Y+2	; 0x02
    385e:	a9 01       	movw	r20, r18
    3860:	48 0f       	add	r20, r24
    3862:	59 1f       	adc	r21, r25
    3864:	89 85       	ldd	r24, Y+9	; 0x09
    3866:	9a 85       	ldd	r25, Y+10	; 0x0a
    3868:	2b 81       	ldd	r18, Y+3	; 0x03
    386a:	3c 81       	ldd	r19, Y+4	; 0x04
    386c:	ba 01       	movw	r22, r20
    386e:	a9 01       	movw	r20, r18
    3870:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3874:	2d 81       	ldd	r18, Y+5	; 0x05
    3876:	3e 81       	ldd	r19, Y+6	; 0x06
    3878:	8b 81       	ldd	r24, Y+3	; 0x03
    387a:	9c 81       	ldd	r25, Y+4	; 0x04
    387c:	82 17       	cp	r24, r18
    387e:	93 07       	cpc	r25, r19
    3880:	b0 f4       	brcc	.+44     	; 0x38ae <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3882:	29 85       	ldd	r18, Y+9	; 0x09
    3884:	3a 85       	ldd	r19, Y+10	; 0x0a
    3886:	8b 81       	ldd	r24, Y+3	; 0x03
    3888:	9c 81       	ldd	r25, Y+4	; 0x04
    388a:	b9 01       	movw	r22, r18
    388c:	68 0f       	add	r22, r24
    388e:	79 1f       	adc	r23, r25
    3890:	ef 81       	ldd	r30, Y+7	; 0x07
    3892:	f8 85       	ldd	r31, Y+8	; 0x08
    3894:	44 85       	ldd	r20, Z+12	; 0x0c
    3896:	55 85       	ldd	r21, Z+13	; 0x0d
    3898:	2d 81       	ldd	r18, Y+5	; 0x05
    389a:	3e 81       	ldd	r19, Y+6	; 0x06
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	28 1b       	sub	r18, r24
    38a2:	39 0b       	sbc	r19, r25
    38a4:	cb 01       	movw	r24, r22
    38a6:	ba 01       	movw	r22, r20
    38a8:	a9 01       	movw	r20, r18
    38aa:	0e 94 12 2a 	call	0x5424	; 0x5424 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    38ae:	29 81       	ldd	r18, Y+1	; 0x01
    38b0:	3a 81       	ldd	r19, Y+2	; 0x02
    38b2:	8d 81       	ldd	r24, Y+5	; 0x05
    38b4:	9e 81       	ldd	r25, Y+6	; 0x06
    38b6:	82 0f       	add	r24, r18
    38b8:	93 1f       	adc	r25, r19
    38ba:	9a 83       	std	Y+2, r25	; 0x02
    38bc:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    38be:	ef 81       	ldd	r30, Y+7	; 0x07
    38c0:	f8 85       	ldd	r31, Y+8	; 0x08
    38c2:	24 81       	ldd	r18, Z+4	; 0x04
    38c4:	35 81       	ldd	r19, Z+5	; 0x05
    38c6:	89 81       	ldd	r24, Y+1	; 0x01
    38c8:	9a 81       	ldd	r25, Y+2	; 0x02
    38ca:	82 17       	cp	r24, r18
    38cc:	93 07       	cpc	r25, r19
    38ce:	50 f0       	brcs	.+20     	; 0x38e4 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    38d0:	ef 81       	ldd	r30, Y+7	; 0x07
    38d2:	f8 85       	ldd	r31, Y+8	; 0x08
    38d4:	24 81       	ldd	r18, Z+4	; 0x04
    38d6:	35 81       	ldd	r19, Z+5	; 0x05
    38d8:	89 81       	ldd	r24, Y+1	; 0x01
    38da:	9a 81       	ldd	r25, Y+2	; 0x02
    38dc:	82 1b       	sub	r24, r18
    38de:	93 0b       	sbc	r25, r19
    38e0:	9a 83       	std	Y+2, r25	; 0x02
    38e2:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    38e4:	ef 81       	ldd	r30, Y+7	; 0x07
    38e6:	f8 85       	ldd	r31, Y+8	; 0x08
    38e8:	89 81       	ldd	r24, Y+1	; 0x01
    38ea:	9a 81       	ldd	r25, Y+2	; 0x02
    38ec:	91 83       	std	Z+1, r25	; 0x01
    38ee:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    38f0:	8d 81       	ldd	r24, Y+5	; 0x05
    38f2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    38f4:	66 96       	adiw	r28, 0x16	; 22
    38f6:	0f b6       	in	r0, 0x3f	; 63
    38f8:	f8 94       	cli
    38fa:	de bf       	out	0x3e, r29	; 62
    38fc:	0f be       	out	0x3f, r0	; 63
    38fe:	cd bf       	out	0x3d, r28	; 61
    3900:	cf 91       	pop	r28
    3902:	df 91       	pop	r29
    3904:	08 95       	ret

00003906 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3906:	df 93       	push	r29
    3908:	cf 93       	push	r28
    390a:	00 d0       	rcall	.+0      	; 0x390c <prvBytesInBuffer+0x6>
    390c:	00 d0       	rcall	.+0      	; 0x390e <prvBytesInBuffer+0x8>
    390e:	cd b7       	in	r28, 0x3d	; 61
    3910:	de b7       	in	r29, 0x3e	; 62
    3912:	9c 83       	std	Y+4, r25	; 0x04
    3914:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3916:	eb 81       	ldd	r30, Y+3	; 0x03
    3918:	fc 81       	ldd	r31, Y+4	; 0x04
    391a:	24 81       	ldd	r18, Z+4	; 0x04
    391c:	35 81       	ldd	r19, Z+5	; 0x05
    391e:	eb 81       	ldd	r30, Y+3	; 0x03
    3920:	fc 81       	ldd	r31, Y+4	; 0x04
    3922:	82 81       	ldd	r24, Z+2	; 0x02
    3924:	93 81       	ldd	r25, Z+3	; 0x03
    3926:	82 0f       	add	r24, r18
    3928:	93 1f       	adc	r25, r19
    392a:	9a 83       	std	Y+2, r25	; 0x02
    392c:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    392e:	eb 81       	ldd	r30, Y+3	; 0x03
    3930:	fc 81       	ldd	r31, Y+4	; 0x04
    3932:	20 81       	ld	r18, Z
    3934:	31 81       	ldd	r19, Z+1	; 0x01
    3936:	89 81       	ldd	r24, Y+1	; 0x01
    3938:	9a 81       	ldd	r25, Y+2	; 0x02
    393a:	82 1b       	sub	r24, r18
    393c:	93 0b       	sbc	r25, r19
    393e:	9a 83       	std	Y+2, r25	; 0x02
    3940:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    3942:	eb 81       	ldd	r30, Y+3	; 0x03
    3944:	fc 81       	ldd	r31, Y+4	; 0x04
    3946:	24 81       	ldd	r18, Z+4	; 0x04
    3948:	35 81       	ldd	r19, Z+5	; 0x05
    394a:	89 81       	ldd	r24, Y+1	; 0x01
    394c:	9a 81       	ldd	r25, Y+2	; 0x02
    394e:	82 17       	cp	r24, r18
    3950:	93 07       	cpc	r25, r19
    3952:	50 f0       	brcs	.+20     	; 0x3968 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    3954:	eb 81       	ldd	r30, Y+3	; 0x03
    3956:	fc 81       	ldd	r31, Y+4	; 0x04
    3958:	24 81       	ldd	r18, Z+4	; 0x04
    395a:	35 81       	ldd	r19, Z+5	; 0x05
    395c:	89 81       	ldd	r24, Y+1	; 0x01
    395e:	9a 81       	ldd	r25, Y+2	; 0x02
    3960:	82 1b       	sub	r24, r18
    3962:	93 0b       	sbc	r25, r19
    3964:	9a 83       	std	Y+2, r25	; 0x02
    3966:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3968:	89 81       	ldd	r24, Y+1	; 0x01
    396a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    396c:	0f 90       	pop	r0
    396e:	0f 90       	pop	r0
    3970:	0f 90       	pop	r0
    3972:	0f 90       	pop	r0
    3974:	cf 91       	pop	r28
    3976:	df 91       	pop	r29
    3978:	08 95       	ret

0000397a <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    397a:	0f 93       	push	r16
    397c:	df 93       	push	r29
    397e:	cf 93       	push	r28
    3980:	cd b7       	in	r28, 0x3d	; 61
    3982:	de b7       	in	r29, 0x3e	; 62
    3984:	29 97       	sbiw	r28, 0x09	; 9
    3986:	0f b6       	in	r0, 0x3f	; 63
    3988:	f8 94       	cli
    398a:	de bf       	out	0x3e, r29	; 62
    398c:	0f be       	out	0x3f, r0	; 63
    398e:	cd bf       	out	0x3d, r28	; 61
    3990:	9a 83       	std	Y+2, r25	; 0x02
    3992:	89 83       	std	Y+1, r24	; 0x01
    3994:	7c 83       	std	Y+4, r23	; 0x04
    3996:	6b 83       	std	Y+3, r22	; 0x03
    3998:	5e 83       	std	Y+6, r21	; 0x06
    399a:	4d 83       	std	Y+5, r20	; 0x05
    399c:	38 87       	std	Y+8, r19	; 0x08
    399e:	2f 83       	std	Y+7, r18	; 0x07
    39a0:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    39a2:	89 81       	ldd	r24, Y+1	; 0x01
    39a4:	9a 81       	ldd	r25, Y+2	; 0x02
    39a6:	60 e0       	ldi	r22, 0x00	; 0
    39a8:	70 e0       	ldi	r23, 0x00	; 0
    39aa:	4f e0       	ldi	r20, 0x0F	; 15
    39ac:	50 e0       	ldi	r21, 0x00	; 0
    39ae:	0e 94 1b 2a 	call	0x5436	; 0x5436 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    39b2:	e9 81       	ldd	r30, Y+1	; 0x01
    39b4:	fa 81       	ldd	r31, Y+2	; 0x02
    39b6:	8b 81       	ldd	r24, Y+3	; 0x03
    39b8:	9c 81       	ldd	r25, Y+4	; 0x04
    39ba:	95 87       	std	Z+13, r25	; 0x0d
    39bc:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    39be:	e9 81       	ldd	r30, Y+1	; 0x01
    39c0:	fa 81       	ldd	r31, Y+2	; 0x02
    39c2:	8d 81       	ldd	r24, Y+5	; 0x05
    39c4:	9e 81       	ldd	r25, Y+6	; 0x06
    39c6:	95 83       	std	Z+5, r25	; 0x05
    39c8:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    39ca:	e9 81       	ldd	r30, Y+1	; 0x01
    39cc:	fa 81       	ldd	r31, Y+2	; 0x02
    39ce:	8f 81       	ldd	r24, Y+7	; 0x07
    39d0:	98 85       	ldd	r25, Y+8	; 0x08
    39d2:	97 83       	std	Z+7, r25	; 0x07
    39d4:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    39d6:	e9 81       	ldd	r30, Y+1	; 0x01
    39d8:	fa 81       	ldd	r31, Y+2	; 0x02
    39da:	89 85       	ldd	r24, Y+9	; 0x09
    39dc:	86 87       	std	Z+14, r24	; 0x0e
}
    39de:	29 96       	adiw	r28, 0x09	; 9
    39e0:	0f b6       	in	r0, 0x3f	; 63
    39e2:	f8 94       	cli
    39e4:	de bf       	out	0x3e, r29	; 62
    39e6:	0f be       	out	0x3f, r0	; 63
    39e8:	cd bf       	out	0x3d, r28	; 61
    39ea:	cf 91       	pop	r28
    39ec:	df 91       	pop	r29
    39ee:	0f 91       	pop	r16
    39f0:	08 95       	ret

000039f2 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    39f2:	8f 92       	push	r8
    39f4:	9f 92       	push	r9
    39f6:	af 92       	push	r10
    39f8:	bf 92       	push	r11
    39fa:	cf 92       	push	r12
    39fc:	df 92       	push	r13
    39fe:	ef 92       	push	r14
    3a00:	ff 92       	push	r15
    3a02:	0f 93       	push	r16
    3a04:	1f 93       	push	r17
    3a06:	df 93       	push	r29
    3a08:	cf 93       	push	r28
    3a0a:	cd b7       	in	r28, 0x3d	; 61
    3a0c:	de b7       	in	r29, 0x3e	; 62
    3a0e:	60 97       	sbiw	r28, 0x10	; 16
    3a10:	0f b6       	in	r0, 0x3f	; 63
    3a12:	f8 94       	cli
    3a14:	de bf       	out	0x3e, r29	; 62
    3a16:	0f be       	out	0x3f, r0	; 63
    3a18:	cd bf       	out	0x3d, r28	; 61
    3a1a:	9f 83       	std	Y+7, r25	; 0x07
    3a1c:	8e 83       	std	Y+6, r24	; 0x06
    3a1e:	79 87       	std	Y+9, r23	; 0x09
    3a20:	68 87       	std	Y+8, r22	; 0x08
    3a22:	5b 87       	std	Y+11, r21	; 0x0b
    3a24:	4a 87       	std	Y+10, r20	; 0x0a
    3a26:	3d 87       	std	Y+13, r19	; 0x0d
    3a28:	2c 87       	std	Y+12, r18	; 0x0c
    3a2a:	0e 87       	std	Y+14, r16	; 0x0e
    3a2c:	f8 8a       	std	Y+16, r15	; 0x10
    3a2e:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3a30:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a32:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a34:	0e 94 1b 08 	call	0x1036	; 0x1036 <pvPortMalloc>
    3a38:	9a 83       	std	Y+2, r25	; 0x02
    3a3a:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3a3c:	89 81       	ldd	r24, Y+1	; 0x01
    3a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a40:	00 97       	sbiw	r24, 0x00	; 0
    3a42:	b1 f0       	breq	.+44     	; 0x3a70 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3a44:	82 e3       	ldi	r24, 0x32	; 50
    3a46:	90 e0       	ldi	r25, 0x00	; 0
    3a48:	0e 94 1b 08 	call	0x1036	; 0x1036 <pvPortMalloc>
    3a4c:	9d 83       	std	Y+5, r25	; 0x05
    3a4e:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3a50:	8c 81       	ldd	r24, Y+4	; 0x04
    3a52:	9d 81       	ldd	r25, Y+5	; 0x05
    3a54:	00 97       	sbiw	r24, 0x00	; 0
    3a56:	39 f0       	breq	.+14     	; 0x3a66 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3a58:	ec 81       	ldd	r30, Y+4	; 0x04
    3a5a:	fd 81       	ldd	r31, Y+5	; 0x05
    3a5c:	89 81       	ldd	r24, Y+1	; 0x01
    3a5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a60:	90 8f       	std	Z+24, r25	; 0x18
    3a62:	87 8b       	std	Z+23, r24	; 0x17
    3a64:	07 c0       	rjmp	.+14     	; 0x3a74 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3a66:	89 81       	ldd	r24, Y+1	; 0x01
    3a68:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6a:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vPortFree>
    3a6e:	02 c0       	rjmp	.+4      	; 0x3a74 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3a70:	1d 82       	std	Y+5, r1	; 0x05
    3a72:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3a74:	8c 81       	ldd	r24, Y+4	; 0x04
    3a76:	9d 81       	ldd	r25, Y+5	; 0x05
    3a78:	00 97       	sbiw	r24, 0x00	; 0
    3a7a:	e9 f0       	breq	.+58     	; 0x3ab6 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3a7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a80:	9c 01       	movw	r18, r24
    3a82:	40 e0       	ldi	r20, 0x00	; 0
    3a84:	50 e0       	ldi	r21, 0x00	; 0
    3a86:	8e 81       	ldd	r24, Y+6	; 0x06
    3a88:	9f 81       	ldd	r25, Y+7	; 0x07
    3a8a:	68 85       	ldd	r22, Y+8	; 0x08
    3a8c:	79 85       	ldd	r23, Y+9	; 0x09
    3a8e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3a90:	fd 85       	ldd	r31, Y+13	; 0x0d
    3a92:	af 85       	ldd	r26, Y+15	; 0x0f
    3a94:	b8 89       	ldd	r27, Y+16	; 0x10
    3a96:	ac 80       	ldd	r10, Y+4	; 0x04
    3a98:	bd 80       	ldd	r11, Y+5	; 0x05
    3a9a:	8f 01       	movw	r16, r30
    3a9c:	ee 84       	ldd	r14, Y+14	; 0x0e
    3a9e:	6d 01       	movw	r12, r26
    3aa0:	88 24       	eor	r8, r8
    3aa2:	99 24       	eor	r9, r9
    3aa4:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3aa8:	8c 81       	ldd	r24, Y+4	; 0x04
    3aaa:	9d 81       	ldd	r25, Y+5	; 0x05
    3aac:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3ab0:	81 e0       	ldi	r24, 0x01	; 1
    3ab2:	8b 83       	std	Y+3, r24	; 0x03
    3ab4:	02 c0       	rjmp	.+4      	; 0x3aba <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3ab6:	8f ef       	ldi	r24, 0xFF	; 255
    3ab8:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3aba:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3abc:	60 96       	adiw	r28, 0x10	; 16
    3abe:	0f b6       	in	r0, 0x3f	; 63
    3ac0:	f8 94       	cli
    3ac2:	de bf       	out	0x3e, r29	; 62
    3ac4:	0f be       	out	0x3f, r0	; 63
    3ac6:	cd bf       	out	0x3d, r28	; 61
    3ac8:	cf 91       	pop	r28
    3aca:	df 91       	pop	r29
    3acc:	1f 91       	pop	r17
    3ace:	0f 91       	pop	r16
    3ad0:	ff 90       	pop	r15
    3ad2:	ef 90       	pop	r14
    3ad4:	df 90       	pop	r13
    3ad6:	cf 90       	pop	r12
    3ad8:	bf 90       	pop	r11
    3ada:	af 90       	pop	r10
    3adc:	9f 90       	pop	r9
    3ade:	8f 90       	pop	r8
    3ae0:	08 95       	ret

00003ae2 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3ae2:	8f 92       	push	r8
    3ae4:	9f 92       	push	r9
    3ae6:	af 92       	push	r10
    3ae8:	bf 92       	push	r11
    3aea:	cf 92       	push	r12
    3aec:	df 92       	push	r13
    3aee:	ef 92       	push	r14
    3af0:	0f 93       	push	r16
    3af2:	1f 93       	push	r17
    3af4:	df 93       	push	r29
    3af6:	cf 93       	push	r28
    3af8:	cd b7       	in	r28, 0x3d	; 61
    3afa:	de b7       	in	r29, 0x3e	; 62
    3afc:	64 97       	sbiw	r28, 0x14	; 20
    3afe:	0f b6       	in	r0, 0x3f	; 63
    3b00:	f8 94       	cli
    3b02:	de bf       	out	0x3e, r29	; 62
    3b04:	0f be       	out	0x3f, r0	; 63
    3b06:	cd bf       	out	0x3d, r28	; 61
    3b08:	9d 83       	std	Y+5, r25	; 0x05
    3b0a:	8c 83       	std	Y+4, r24	; 0x04
    3b0c:	7f 83       	std	Y+7, r23	; 0x07
    3b0e:	6e 83       	std	Y+6, r22	; 0x06
    3b10:	28 87       	std	Y+8, r18	; 0x08
    3b12:	39 87       	std	Y+9, r19	; 0x09
    3b14:	4a 87       	std	Y+10, r20	; 0x0a
    3b16:	5b 87       	std	Y+11, r21	; 0x0b
    3b18:	1d 87       	std	Y+13, r17	; 0x0d
    3b1a:	0c 87       	std	Y+12, r16	; 0x0c
    3b1c:	ee 86       	std	Y+14, r14	; 0x0e
    3b1e:	d8 8a       	std	Y+16, r13	; 0x10
    3b20:	cf 86       	std	Y+15, r12	; 0x0f
    3b22:	ba 8a       	std	Y+18, r11	; 0x12
    3b24:	a9 8a       	std	Y+17, r10	; 0x11
    3b26:	9c 8a       	std	Y+20, r9	; 0x14
    3b28:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3b2a:	e9 89       	ldd	r30, Y+17	; 0x11
    3b2c:	fa 89       	ldd	r31, Y+18	; 0x12
    3b2e:	27 89       	ldd	r18, Z+23	; 0x17
    3b30:	30 8d       	ldd	r19, Z+24	; 0x18
    3b32:	88 85       	ldd	r24, Y+8	; 0x08
    3b34:	99 85       	ldd	r25, Y+9	; 0x09
    3b36:	01 97       	sbiw	r24, 0x01	; 1
    3b38:	82 0f       	add	r24, r18
    3b3a:	93 1f       	adc	r25, r19
    3b3c:	9b 83       	std	Y+3, r25	; 0x03
    3b3e:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3b40:	8e 81       	ldd	r24, Y+6	; 0x06
    3b42:	9f 81       	ldd	r25, Y+7	; 0x07
    3b44:	00 97       	sbiw	r24, 0x00	; 0
    3b46:	51 f1       	breq	.+84     	; 0x3b9c <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3b48:	19 82       	std	Y+1, r1	; 0x01
    3b4a:	21 c0       	rjmp	.+66     	; 0x3b8e <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3b4c:	89 81       	ldd	r24, Y+1	; 0x01
    3b4e:	48 2f       	mov	r20, r24
    3b50:	50 e0       	ldi	r21, 0x00	; 0
    3b52:	89 81       	ldd	r24, Y+1	; 0x01
    3b54:	28 2f       	mov	r18, r24
    3b56:	30 e0       	ldi	r19, 0x00	; 0
    3b58:	8e 81       	ldd	r24, Y+6	; 0x06
    3b5a:	9f 81       	ldd	r25, Y+7	; 0x07
    3b5c:	fc 01       	movw	r30, r24
    3b5e:	e2 0f       	add	r30, r18
    3b60:	f3 1f       	adc	r31, r19
    3b62:	20 81       	ld	r18, Z
    3b64:	89 89       	ldd	r24, Y+17	; 0x11
    3b66:	9a 89       	ldd	r25, Y+18	; 0x12
    3b68:	84 0f       	add	r24, r20
    3b6a:	95 1f       	adc	r25, r21
    3b6c:	fc 01       	movw	r30, r24
    3b6e:	79 96       	adiw	r30, 0x19	; 25
    3b70:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3b72:	89 81       	ldd	r24, Y+1	; 0x01
    3b74:	28 2f       	mov	r18, r24
    3b76:	30 e0       	ldi	r19, 0x00	; 0
    3b78:	8e 81       	ldd	r24, Y+6	; 0x06
    3b7a:	9f 81       	ldd	r25, Y+7	; 0x07
    3b7c:	fc 01       	movw	r30, r24
    3b7e:	e2 0f       	add	r30, r18
    3b80:	f3 1f       	adc	r31, r19
    3b82:	80 81       	ld	r24, Z
    3b84:	88 23       	and	r24, r24
    3b86:	31 f0       	breq	.+12     	; 0x3b94 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3b88:	89 81       	ldd	r24, Y+1	; 0x01
    3b8a:	8f 5f       	subi	r24, 0xFF	; 255
    3b8c:	89 83       	std	Y+1, r24	; 0x01
    3b8e:	89 81       	ldd	r24, Y+1	; 0x01
    3b90:	84 31       	cpi	r24, 0x14	; 20
    3b92:	e0 f2       	brcs	.-72     	; 0x3b4c <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3b94:	e9 89       	ldd	r30, Y+17	; 0x11
    3b96:	fa 89       	ldd	r31, Y+18	; 0x12
    3b98:	14 a6       	std	Z+44, r1	; 0x2c
    3b9a:	03 c0       	rjmp	.+6      	; 0x3ba2 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3b9c:	e9 89       	ldd	r30, Y+17	; 0x11
    3b9e:	fa 89       	ldd	r31, Y+18	; 0x12
    3ba0:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3ba2:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ba4:	85 30       	cpi	r24, 0x05	; 5
    3ba6:	10 f0       	brcs	.+4      	; 0x3bac <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3ba8:	84 e0       	ldi	r24, 0x04	; 4
    3baa:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3bac:	e9 89       	ldd	r30, Y+17	; 0x11
    3bae:	fa 89       	ldd	r31, Y+18	; 0x12
    3bb0:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bb2:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3bb4:	89 89       	ldd	r24, Y+17	; 0x11
    3bb6:	9a 89       	ldd	r25, Y+18	; 0x12
    3bb8:	02 96       	adiw	r24, 0x02	; 2
    3bba:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3bbe:	89 89       	ldd	r24, Y+17	; 0x11
    3bc0:	9a 89       	ldd	r25, Y+18	; 0x12
    3bc2:	0c 96       	adiw	r24, 0x0c	; 12
    3bc4:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3bc8:	e9 89       	ldd	r30, Y+17	; 0x11
    3bca:	fa 89       	ldd	r31, Y+18	; 0x12
    3bcc:	89 89       	ldd	r24, Y+17	; 0x11
    3bce:	9a 89       	ldd	r25, Y+18	; 0x12
    3bd0:	91 87       	std	Z+9, r25	; 0x09
    3bd2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3bd4:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bd6:	28 2f       	mov	r18, r24
    3bd8:	30 e0       	ldi	r19, 0x00	; 0
    3bda:	85 e0       	ldi	r24, 0x05	; 5
    3bdc:	90 e0       	ldi	r25, 0x00	; 0
    3bde:	82 1b       	sub	r24, r18
    3be0:	93 0b       	sbc	r25, r19
    3be2:	e9 89       	ldd	r30, Y+17	; 0x11
    3be4:	fa 89       	ldd	r31, Y+18	; 0x12
    3be6:	95 87       	std	Z+13, r25	; 0x0d
    3be8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3bea:	e9 89       	ldd	r30, Y+17	; 0x11
    3bec:	fa 89       	ldd	r31, Y+18	; 0x12
    3bee:	89 89       	ldd	r24, Y+17	; 0x11
    3bf0:	9a 89       	ldd	r25, Y+18	; 0x12
    3bf2:	93 8b       	std	Z+19, r25	; 0x13
    3bf4:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3bf6:	e9 89       	ldd	r30, Y+17	; 0x11
    3bf8:	fa 89       	ldd	r31, Y+18	; 0x12
    3bfa:	15 a6       	std	Z+45, r1	; 0x2d
    3bfc:	16 a6       	std	Z+46, r1	; 0x2e
    3bfe:	17 a6       	std	Z+47, r1	; 0x2f
    3c00:	10 aa       	std	Z+48, r1	; 0x30
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3c02:	e9 89       	ldd	r30, Y+17	; 0x11
    3c04:	fa 89       	ldd	r31, Y+18	; 0x12
    3c06:	11 aa       	std	Z+49, r1	; 0x31
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3c08:	8a 81       	ldd	r24, Y+2	; 0x02
    3c0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c0c:	2c 81       	ldd	r18, Y+4	; 0x04
    3c0e:	3d 81       	ldd	r19, Y+5	; 0x05
    3c10:	4c 85       	ldd	r20, Y+12	; 0x0c
    3c12:	5d 85       	ldd	r21, Y+13	; 0x0d
    3c14:	b9 01       	movw	r22, r18
    3c16:	0e 94 6f 0b 	call	0x16de	; 0x16de <pxPortInitialiseStack>
    3c1a:	e9 89       	ldd	r30, Y+17	; 0x11
    3c1c:	fa 89       	ldd	r31, Y+18	; 0x12
    3c1e:	91 83       	std	Z+1, r25	; 0x01
    3c20:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3c22:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c24:	98 89       	ldd	r25, Y+16	; 0x10
    3c26:	00 97       	sbiw	r24, 0x00	; 0
    3c28:	31 f0       	breq	.+12     	; 0x3c36 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3c2a:	ef 85       	ldd	r30, Y+15	; 0x0f
    3c2c:	f8 89       	ldd	r31, Y+16	; 0x10
    3c2e:	89 89       	ldd	r24, Y+17	; 0x11
    3c30:	9a 89       	ldd	r25, Y+18	; 0x12
    3c32:	91 83       	std	Z+1, r25	; 0x01
    3c34:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3c36:	64 96       	adiw	r28, 0x14	; 20
    3c38:	0f b6       	in	r0, 0x3f	; 63
    3c3a:	f8 94       	cli
    3c3c:	de bf       	out	0x3e, r29	; 62
    3c3e:	0f be       	out	0x3f, r0	; 63
    3c40:	cd bf       	out	0x3d, r28	; 61
    3c42:	cf 91       	pop	r28
    3c44:	df 91       	pop	r29
    3c46:	1f 91       	pop	r17
    3c48:	0f 91       	pop	r16
    3c4a:	ef 90       	pop	r14
    3c4c:	df 90       	pop	r13
    3c4e:	cf 90       	pop	r12
    3c50:	bf 90       	pop	r11
    3c52:	af 90       	pop	r10
    3c54:	9f 90       	pop	r9
    3c56:	8f 90       	pop	r8
    3c58:	08 95       	ret

00003c5a <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3c5a:	df 93       	push	r29
    3c5c:	cf 93       	push	r28
    3c5e:	00 d0       	rcall	.+0      	; 0x3c60 <prvAddNewTaskToReadyList+0x6>
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
    3c64:	9a 83       	std	Y+2, r25	; 0x02
    3c66:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3c68:	0f b6       	in	r0, 0x3f	; 63
    3c6a:	f8 94       	cli
    3c6c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3c6e:	80 91 bd 06 	lds	r24, 0x06BD
    3c72:	8f 5f       	subi	r24, 0xFF	; 255
    3c74:	80 93 bd 06 	sts	0x06BD, r24
		if( pxCurrentTCB == NULL )
    3c78:	80 91 ba 06 	lds	r24, 0x06BA
    3c7c:	90 91 bb 06 	lds	r25, 0x06BB
    3c80:	00 97       	sbiw	r24, 0x00	; 0
    3c82:	69 f4       	brne	.+26     	; 0x3c9e <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3c84:	89 81       	ldd	r24, Y+1	; 0x01
    3c86:	9a 81       	ldd	r25, Y+2	; 0x02
    3c88:	90 93 bb 06 	sts	0x06BB, r25
    3c8c:	80 93 ba 06 	sts	0x06BA, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3c90:	80 91 bd 06 	lds	r24, 0x06BD
    3c94:	81 30       	cpi	r24, 0x01	; 1
    3c96:	b9 f4       	brne	.+46     	; 0x3cc6 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3c98:	0e 94 04 25 	call	0x4a08	; 0x4a08 <prvInitialiseTaskLists>
    3c9c:	14 c0       	rjmp	.+40     	; 0x3cc6 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3c9e:	80 91 c1 06 	lds	r24, 0x06C1
    3ca2:	88 23       	and	r24, r24
    3ca4:	81 f4       	brne	.+32     	; 0x3cc6 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3ca6:	e0 91 ba 06 	lds	r30, 0x06BA
    3caa:	f0 91 bb 06 	lds	r31, 0x06BB
    3cae:	96 89       	ldd	r25, Z+22	; 0x16
    3cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3cb4:	86 89       	ldd	r24, Z+22	; 0x16
    3cb6:	89 17       	cp	r24, r25
    3cb8:	30 f0       	brcs	.+12     	; 0x3cc6 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3cba:	89 81       	ldd	r24, Y+1	; 0x01
    3cbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3cbe:	90 93 bb 06 	sts	0x06BB, r25
    3cc2:	80 93 ba 06 	sts	0x06BA, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3cc6:	80 91 c5 06 	lds	r24, 0x06C5
    3cca:	8f 5f       	subi	r24, 0xFF	; 255
    3ccc:	80 93 c5 06 	sts	0x06C5, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3cd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3cd4:	96 89       	ldd	r25, Z+22	; 0x16
    3cd6:	80 91 c0 06 	lds	r24, 0x06C0
    3cda:	89 17       	cp	r24, r25
    3cdc:	28 f4       	brcc	.+10     	; 0x3ce8 <prvAddNewTaskToReadyList+0x8e>
    3cde:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce2:	86 89       	ldd	r24, Z+22	; 0x16
    3ce4:	80 93 c0 06 	sts	0x06C0, r24
    3ce8:	e9 81       	ldd	r30, Y+1	; 0x01
    3cea:	fa 81       	ldd	r31, Y+2	; 0x02
    3cec:	86 89       	ldd	r24, Z+22	; 0x16
    3cee:	28 2f       	mov	r18, r24
    3cf0:	30 e0       	ldi	r19, 0x00	; 0
    3cf2:	c9 01       	movw	r24, r18
    3cf4:	88 0f       	add	r24, r24
    3cf6:	99 1f       	adc	r25, r25
    3cf8:	88 0f       	add	r24, r24
    3cfa:	99 1f       	adc	r25, r25
    3cfc:	88 0f       	add	r24, r24
    3cfe:	99 1f       	adc	r25, r25
    3d00:	82 0f       	add	r24, r18
    3d02:	93 1f       	adc	r25, r19
    3d04:	ac 01       	movw	r20, r24
    3d06:	45 53       	subi	r20, 0x35	; 53
    3d08:	59 4f       	sbci	r21, 0xF9	; 249
    3d0a:	89 81       	ldd	r24, Y+1	; 0x01
    3d0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d0e:	9c 01       	movw	r18, r24
    3d10:	2e 5f       	subi	r18, 0xFE	; 254
    3d12:	3f 4f       	sbci	r19, 0xFF	; 255
    3d14:	ca 01       	movw	r24, r20
    3d16:	b9 01       	movw	r22, r18
    3d18:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3d1c:	0f 90       	pop	r0
    3d1e:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3d20:	80 91 c1 06 	lds	r24, 0x06C1
    3d24:	88 23       	and	r24, r24
    3d26:	61 f0       	breq	.+24     	; 0x3d40 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3d28:	e0 91 ba 06 	lds	r30, 0x06BA
    3d2c:	f0 91 bb 06 	lds	r31, 0x06BB
    3d30:	96 89       	ldd	r25, Z+22	; 0x16
    3d32:	e9 81       	ldd	r30, Y+1	; 0x01
    3d34:	fa 81       	ldd	r31, Y+2	; 0x02
    3d36:	86 89       	ldd	r24, Z+22	; 0x16
    3d38:	98 17       	cp	r25, r24
    3d3a:	10 f4       	brcc	.+4      	; 0x3d40 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3d3c:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3d40:	0f 90       	pop	r0
    3d42:	0f 90       	pop	r0
    3d44:	cf 91       	pop	r28
    3d46:	df 91       	pop	r29
    3d48:	08 95       	ret

00003d4a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3d4a:	df 93       	push	r29
    3d4c:	cf 93       	push	r28
    3d4e:	00 d0       	rcall	.+0      	; 0x3d50 <vTaskDelete+0x6>
    3d50:	00 d0       	rcall	.+0      	; 0x3d52 <vTaskDelete+0x8>
    3d52:	00 d0       	rcall	.+0      	; 0x3d54 <vTaskDelete+0xa>
    3d54:	cd b7       	in	r28, 0x3d	; 61
    3d56:	de b7       	in	r29, 0x3e	; 62
    3d58:	9c 83       	std	Y+4, r25	; 0x04
    3d5a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3d5c:	0f b6       	in	r0, 0x3f	; 63
    3d5e:	f8 94       	cli
    3d60:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3d62:	8b 81       	ldd	r24, Y+3	; 0x03
    3d64:	9c 81       	ldd	r25, Y+4	; 0x04
    3d66:	00 97       	sbiw	r24, 0x00	; 0
    3d68:	39 f4       	brne	.+14     	; 0x3d78 <vTaskDelete+0x2e>
    3d6a:	80 91 ba 06 	lds	r24, 0x06BA
    3d6e:	90 91 bb 06 	lds	r25, 0x06BB
    3d72:	9e 83       	std	Y+6, r25	; 0x06
    3d74:	8d 83       	std	Y+5, r24	; 0x05
    3d76:	04 c0       	rjmp	.+8      	; 0x3d80 <vTaskDelete+0x36>
    3d78:	8b 81       	ldd	r24, Y+3	; 0x03
    3d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d7c:	9e 83       	std	Y+6, r25	; 0x06
    3d7e:	8d 83       	std	Y+5, r24	; 0x05
    3d80:	8d 81       	ldd	r24, Y+5	; 0x05
    3d82:	9e 81       	ldd	r25, Y+6	; 0x06
    3d84:	9a 83       	std	Y+2, r25	; 0x02
    3d86:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3d88:	89 81       	ldd	r24, Y+1	; 0x01
    3d8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d8c:	02 96       	adiw	r24, 0x02	; 2
    3d8e:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3d92:	e9 81       	ldd	r30, Y+1	; 0x01
    3d94:	fa 81       	ldd	r31, Y+2	; 0x02
    3d96:	84 89       	ldd	r24, Z+20	; 0x14
    3d98:	95 89       	ldd	r25, Z+21	; 0x15
    3d9a:	00 97       	sbiw	r24, 0x00	; 0
    3d9c:	29 f0       	breq	.+10     	; 0x3da8 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3d9e:	89 81       	ldd	r24, Y+1	; 0x01
    3da0:	9a 81       	ldd	r25, Y+2	; 0x02
    3da2:	0c 96       	adiw	r24, 0x0c	; 12
    3da4:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3da8:	80 91 c5 06 	lds	r24, 0x06C5
    3dac:	8f 5f       	subi	r24, 0xFF	; 255
    3dae:	80 93 c5 06 	sts	0x06C5, r24

			if( pxTCB == pxCurrentTCB )
    3db2:	20 91 ba 06 	lds	r18, 0x06BA
    3db6:	30 91 bb 06 	lds	r19, 0x06BB
    3dba:	89 81       	ldd	r24, Y+1	; 0x01
    3dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3dbe:	82 17       	cp	r24, r18
    3dc0:	93 07       	cpc	r25, r19
    3dc2:	81 f4       	brne	.+32     	; 0x3de4 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3dc4:	89 81       	ldd	r24, Y+1	; 0x01
    3dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc8:	9c 01       	movw	r18, r24
    3dca:	2e 5f       	subi	r18, 0xFE	; 254
    3dcc:	3f 4f       	sbci	r19, 0xFF	; 255
    3dce:	87 e1       	ldi	r24, 0x17	; 23
    3dd0:	97 e0       	ldi	r25, 0x07	; 7
    3dd2:	b9 01       	movw	r22, r18
    3dd4:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    3dd8:	80 91 bc 06 	lds	r24, 0x06BC
    3ddc:	8f 5f       	subi	r24, 0xFF	; 255
    3dde:	80 93 bc 06 	sts	0x06BC, r24
    3de2:	0b c0       	rjmp	.+22     	; 0x3dfa <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3de4:	80 91 bd 06 	lds	r24, 0x06BD
    3de8:	81 50       	subi	r24, 0x01	; 1
    3dea:	80 93 bd 06 	sts	0x06BD, r24
				prvDeleteTCB( pxTCB );
    3dee:	89 81       	ldd	r24, Y+1	; 0x01
    3df0:	9a 81       	ldd	r25, Y+2	; 0x02
    3df2:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3df6:	0e 94 8a 25 	call	0x4b14	; 0x4b14 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3dfa:	0f 90       	pop	r0
    3dfc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3dfe:	80 91 c1 06 	lds	r24, 0x06C1
    3e02:	88 23       	and	r24, r24
    3e04:	59 f0       	breq	.+22     	; 0x3e1c <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    3e06:	20 91 ba 06 	lds	r18, 0x06BA
    3e0a:	30 91 bb 06 	lds	r19, 0x06BB
    3e0e:	89 81       	ldd	r24, Y+1	; 0x01
    3e10:	9a 81       	ldd	r25, Y+2	; 0x02
    3e12:	82 17       	cp	r24, r18
    3e14:	93 07       	cpc	r25, r19
    3e16:	11 f4       	brne	.+4      	; 0x3e1c <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3e18:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3e1c:	26 96       	adiw	r28, 0x06	; 6
    3e1e:	0f b6       	in	r0, 0x3f	; 63
    3e20:	f8 94       	cli
    3e22:	de bf       	out	0x3e, r29	; 62
    3e24:	0f be       	out	0x3f, r0	; 63
    3e26:	cd bf       	out	0x3d, r28	; 61
    3e28:	cf 91       	pop	r28
    3e2a:	df 91       	pop	r29
    3e2c:	08 95       	ret

00003e2e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3e2e:	df 93       	push	r29
    3e30:	cf 93       	push	r28
    3e32:	00 d0       	rcall	.+0      	; 0x3e34 <vTaskDelay+0x6>
    3e34:	0f 92       	push	r0
    3e36:	cd b7       	in	r28, 0x3d	; 61
    3e38:	de b7       	in	r29, 0x3e	; 62
    3e3a:	9b 83       	std	Y+3, r25	; 0x03
    3e3c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3e3e:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3e40:	8a 81       	ldd	r24, Y+2	; 0x02
    3e42:	9b 81       	ldd	r25, Y+3	; 0x03
    3e44:	00 97       	sbiw	r24, 0x00	; 0
    3e46:	51 f0       	breq	.+20     	; 0x3e5c <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3e48:	0e 94 e4 20 	call	0x41c8	; 0x41c8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e4e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e50:	60 e0       	ldi	r22, 0x00	; 0
    3e52:	0e 94 96 29 	call	0x532c	; 0x532c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3e56:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <xTaskResumeAll>
    3e5a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	88 23       	and	r24, r24
    3e60:	11 f4       	brne	.+4      	; 0x3e66 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3e62:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3e66:	0f 90       	pop	r0
    3e68:	0f 90       	pop	r0
    3e6a:	0f 90       	pop	r0
    3e6c:	cf 91       	pop	r28
    3e6e:	df 91       	pop	r29
    3e70:	08 95       	ret

00003e72 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3e72:	df 93       	push	r29
    3e74:	cf 93       	push	r28
    3e76:	00 d0       	rcall	.+0      	; 0x3e78 <vTaskSuspend+0x6>
    3e78:	00 d0       	rcall	.+0      	; 0x3e7a <vTaskSuspend+0x8>
    3e7a:	00 d0       	rcall	.+0      	; 0x3e7c <vTaskSuspend+0xa>
    3e7c:	cd b7       	in	r28, 0x3d	; 61
    3e7e:	de b7       	in	r29, 0x3e	; 62
    3e80:	9c 83       	std	Y+4, r25	; 0x04
    3e82:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3e84:	0f b6       	in	r0, 0x3f	; 63
    3e86:	f8 94       	cli
    3e88:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8e:	00 97       	sbiw	r24, 0x00	; 0
    3e90:	39 f4       	brne	.+14     	; 0x3ea0 <vTaskSuspend+0x2e>
    3e92:	80 91 ba 06 	lds	r24, 0x06BA
    3e96:	90 91 bb 06 	lds	r25, 0x06BB
    3e9a:	9e 83       	std	Y+6, r25	; 0x06
    3e9c:	8d 83       	std	Y+5, r24	; 0x05
    3e9e:	04 c0       	rjmp	.+8      	; 0x3ea8 <vTaskSuspend+0x36>
    3ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ea4:	9e 83       	std	Y+6, r25	; 0x06
    3ea6:	8d 83       	std	Y+5, r24	; 0x05
    3ea8:	8d 81       	ldd	r24, Y+5	; 0x05
    3eaa:	9e 81       	ldd	r25, Y+6	; 0x06
    3eac:	9a 83       	std	Y+2, r25	; 0x02
    3eae:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb4:	02 96       	adiw	r24, 0x02	; 2
    3eb6:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3eba:	e9 81       	ldd	r30, Y+1	; 0x01
    3ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ebe:	84 89       	ldd	r24, Z+20	; 0x14
    3ec0:	95 89       	ldd	r25, Z+21	; 0x15
    3ec2:	00 97       	sbiw	r24, 0x00	; 0
    3ec4:	29 f0       	breq	.+10     	; 0x3ed0 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3ec6:	89 81       	ldd	r24, Y+1	; 0x01
    3ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eca:	0c 96       	adiw	r24, 0x0c	; 12
    3ecc:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3ed0:	89 81       	ldd	r24, Y+1	; 0x01
    3ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed4:	9c 01       	movw	r18, r24
    3ed6:	2e 5f       	subi	r18, 0xFE	; 254
    3ed8:	3f 4f       	sbci	r19, 0xFF	; 255
    3eda:	80 e2       	ldi	r24, 0x20	; 32
    3edc:	97 e0       	ldi	r25, 0x07	; 7
    3ede:	b9 01       	movw	r22, r18
    3ee0:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee8:	81 a9       	ldd	r24, Z+49	; 0x31
    3eea:	81 30       	cpi	r24, 0x01	; 1
    3eec:	19 f4       	brne	.+6      	; 0x3ef4 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3eee:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef2:	11 aa       	std	Z+49, r1	; 0x31
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3ef4:	0f 90       	pop	r0
    3ef6:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3ef8:	80 91 c1 06 	lds	r24, 0x06C1
    3efc:	88 23       	and	r24, r24
    3efe:	39 f0       	breq	.+14     	; 0x3f0e <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3f00:	0f b6       	in	r0, 0x3f	; 63
    3f02:	f8 94       	cli
    3f04:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3f06:	0e 94 8a 25 	call	0x4b14	; 0x4b14 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3f0a:	0f 90       	pop	r0
    3f0c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3f0e:	20 91 ba 06 	lds	r18, 0x06BA
    3f12:	30 91 bb 06 	lds	r19, 0x06BB
    3f16:	89 81       	ldd	r24, Y+1	; 0x01
    3f18:	9a 81       	ldd	r25, Y+2	; 0x02
    3f1a:	82 17       	cp	r24, r18
    3f1c:	93 07       	cpc	r25, r19
    3f1e:	a1 f4       	brne	.+40     	; 0x3f48 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3f20:	80 91 c1 06 	lds	r24, 0x06C1
    3f24:	88 23       	and	r24, r24
    3f26:	19 f0       	breq	.+6      	; 0x3f2e <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3f28:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
    3f2c:	0d c0       	rjmp	.+26     	; 0x3f48 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3f2e:	90 91 20 07 	lds	r25, 0x0720
    3f32:	80 91 bd 06 	lds	r24, 0x06BD
    3f36:	98 17       	cp	r25, r24
    3f38:	29 f4       	brne	.+10     	; 0x3f44 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3f3a:	10 92 bb 06 	sts	0x06BB, r1
    3f3e:	10 92 ba 06 	sts	0x06BA, r1
    3f42:	02 c0       	rjmp	.+4      	; 0x3f48 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3f44:	0e 94 c5 22 	call	0x458a	; 0x458a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3f48:	26 96       	adiw	r28, 0x06	; 6
    3f4a:	0f b6       	in	r0, 0x3f	; 63
    3f4c:	f8 94       	cli
    3f4e:	de bf       	out	0x3e, r29	; 62
    3f50:	0f be       	out	0x3f, r0	; 63
    3f52:	cd bf       	out	0x3d, r28	; 61
    3f54:	cf 91       	pop	r28
    3f56:	df 91       	pop	r29
    3f58:	08 95       	ret

00003f5a <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3f5a:	df 93       	push	r29
    3f5c:	cf 93       	push	r28
    3f5e:	00 d0       	rcall	.+0      	; 0x3f60 <prvTaskIsTaskSuspended+0x6>
    3f60:	00 d0       	rcall	.+0      	; 0x3f62 <prvTaskIsTaskSuspended+0x8>
    3f62:	0f 92       	push	r0
    3f64:	cd b7       	in	r28, 0x3d	; 61
    3f66:	de b7       	in	r29, 0x3e	; 62
    3f68:	9d 83       	std	Y+5, r25	; 0x05
    3f6a:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3f6c:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3f6e:	8c 81       	ldd	r24, Y+4	; 0x04
    3f70:	9d 81       	ldd	r25, Y+5	; 0x05
    3f72:	9a 83       	std	Y+2, r25	; 0x02
    3f74:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3f76:	e9 81       	ldd	r30, Y+1	; 0x01
    3f78:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7a:	82 85       	ldd	r24, Z+10	; 0x0a
    3f7c:	93 85       	ldd	r25, Z+11	; 0x0b
    3f7e:	27 e0       	ldi	r18, 0x07	; 7
    3f80:	80 32       	cpi	r24, 0x20	; 32
    3f82:	92 07       	cpc	r25, r18
    3f84:	81 f4       	brne	.+32     	; 0x3fa6 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3f86:	e9 81       	ldd	r30, Y+1	; 0x01
    3f88:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8a:	84 89       	ldd	r24, Z+20	; 0x14
    3f8c:	95 89       	ldd	r25, Z+21	; 0x15
    3f8e:	27 e0       	ldi	r18, 0x07	; 7
    3f90:	8e 30       	cpi	r24, 0x0E	; 14
    3f92:	92 07       	cpc	r25, r18
    3f94:	41 f0       	breq	.+16     	; 0x3fa6 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3f96:	e9 81       	ldd	r30, Y+1	; 0x01
    3f98:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9a:	84 89       	ldd	r24, Z+20	; 0x14
    3f9c:	95 89       	ldd	r25, Z+21	; 0x15
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	11 f4       	brne	.+4      	; 0x3fa6 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3fa2:	81 e0       	ldi	r24, 0x01	; 1
    3fa4:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3fa6:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3fa8:	0f 90       	pop	r0
    3faa:	0f 90       	pop	r0
    3fac:	0f 90       	pop	r0
    3fae:	0f 90       	pop	r0
    3fb0:	0f 90       	pop	r0
    3fb2:	cf 91       	pop	r28
    3fb4:	df 91       	pop	r29
    3fb6:	08 95       	ret

00003fb8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3fb8:	df 93       	push	r29
    3fba:	cf 93       	push	r28
    3fbc:	00 d0       	rcall	.+0      	; 0x3fbe <vTaskResume+0x6>
    3fbe:	00 d0       	rcall	.+0      	; 0x3fc0 <vTaskResume+0x8>
    3fc0:	cd b7       	in	r28, 0x3d	; 61
    3fc2:	de b7       	in	r29, 0x3e	; 62
    3fc4:	9c 83       	std	Y+4, r25	; 0x04
    3fc6:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fca:	9c 81       	ldd	r25, Y+4	; 0x04
    3fcc:	9a 83       	std	Y+2, r25	; 0x02
    3fce:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3fd0:	20 91 ba 06 	lds	r18, 0x06BA
    3fd4:	30 91 bb 06 	lds	r19, 0x06BB
    3fd8:	89 81       	ldd	r24, Y+1	; 0x01
    3fda:	9a 81       	ldd	r25, Y+2	; 0x02
    3fdc:	82 17       	cp	r24, r18
    3fde:	93 07       	cpc	r25, r19
    3fe0:	09 f4       	brne	.+2      	; 0x3fe4 <vTaskResume+0x2c>
    3fe2:	47 c0       	rjmp	.+142    	; 0x4072 <vTaskResume+0xba>
    3fe4:	89 81       	ldd	r24, Y+1	; 0x01
    3fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe8:	00 97       	sbiw	r24, 0x00	; 0
    3fea:	09 f4       	brne	.+2      	; 0x3fee <vTaskResume+0x36>
    3fec:	42 c0       	rjmp	.+132    	; 0x4072 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3fee:	0f b6       	in	r0, 0x3f	; 63
    3ff0:	f8 94       	cli
    3ff2:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3ff4:	89 81       	ldd	r24, Y+1	; 0x01
    3ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff8:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <prvTaskIsTaskSuspended>
    3ffc:	88 23       	and	r24, r24
    3ffe:	b9 f1       	breq	.+110    	; 0x406e <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4000:	89 81       	ldd	r24, Y+1	; 0x01
    4002:	9a 81       	ldd	r25, Y+2	; 0x02
    4004:	02 96       	adiw	r24, 0x02	; 2
    4006:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    400a:	e9 81       	ldd	r30, Y+1	; 0x01
    400c:	fa 81       	ldd	r31, Y+2	; 0x02
    400e:	96 89       	ldd	r25, Z+22	; 0x16
    4010:	80 91 c0 06 	lds	r24, 0x06C0
    4014:	89 17       	cp	r24, r25
    4016:	28 f4       	brcc	.+10     	; 0x4022 <vTaskResume+0x6a>
    4018:	e9 81       	ldd	r30, Y+1	; 0x01
    401a:	fa 81       	ldd	r31, Y+2	; 0x02
    401c:	86 89       	ldd	r24, Z+22	; 0x16
    401e:	80 93 c0 06 	sts	0x06C0, r24
    4022:	e9 81       	ldd	r30, Y+1	; 0x01
    4024:	fa 81       	ldd	r31, Y+2	; 0x02
    4026:	86 89       	ldd	r24, Z+22	; 0x16
    4028:	28 2f       	mov	r18, r24
    402a:	30 e0       	ldi	r19, 0x00	; 0
    402c:	c9 01       	movw	r24, r18
    402e:	88 0f       	add	r24, r24
    4030:	99 1f       	adc	r25, r25
    4032:	88 0f       	add	r24, r24
    4034:	99 1f       	adc	r25, r25
    4036:	88 0f       	add	r24, r24
    4038:	99 1f       	adc	r25, r25
    403a:	82 0f       	add	r24, r18
    403c:	93 1f       	adc	r25, r19
    403e:	ac 01       	movw	r20, r24
    4040:	45 53       	subi	r20, 0x35	; 53
    4042:	59 4f       	sbci	r21, 0xF9	; 249
    4044:	89 81       	ldd	r24, Y+1	; 0x01
    4046:	9a 81       	ldd	r25, Y+2	; 0x02
    4048:	9c 01       	movw	r18, r24
    404a:	2e 5f       	subi	r18, 0xFE	; 254
    404c:	3f 4f       	sbci	r19, 0xFF	; 255
    404e:	ca 01       	movw	r24, r20
    4050:	b9 01       	movw	r22, r18
    4052:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4056:	e9 81       	ldd	r30, Y+1	; 0x01
    4058:	fa 81       	ldd	r31, Y+2	; 0x02
    405a:	96 89       	ldd	r25, Z+22	; 0x16
    405c:	e0 91 ba 06 	lds	r30, 0x06BA
    4060:	f0 91 bb 06 	lds	r31, 0x06BB
    4064:	86 89       	ldd	r24, Z+22	; 0x16
    4066:	98 17       	cp	r25, r24
    4068:	10 f0       	brcs	.+4      	; 0x406e <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    406a:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    406e:	0f 90       	pop	r0
    4070:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4072:	0f 90       	pop	r0
    4074:	0f 90       	pop	r0
    4076:	0f 90       	pop	r0
    4078:	0f 90       	pop	r0
    407a:	cf 91       	pop	r28
    407c:	df 91       	pop	r29
    407e:	08 95       	ret

00004080 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4080:	df 93       	push	r29
    4082:	cf 93       	push	r28
    4084:	00 d0       	rcall	.+0      	; 0x4086 <xTaskResumeFromISR+0x6>
    4086:	00 d0       	rcall	.+0      	; 0x4088 <xTaskResumeFromISR+0x8>
    4088:	00 d0       	rcall	.+0      	; 0x408a <xTaskResumeFromISR+0xa>
    408a:	cd b7       	in	r28, 0x3d	; 61
    408c:	de b7       	in	r29, 0x3e	; 62
    408e:	9e 83       	std	Y+6, r25	; 0x06
    4090:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4092:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4094:	8d 81       	ldd	r24, Y+5	; 0x05
    4096:	9e 81       	ldd	r25, Y+6	; 0x06
    4098:	9b 83       	std	Y+3, r25	; 0x03
    409a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    409c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    409e:	8a 81       	ldd	r24, Y+2	; 0x02
    40a0:	9b 81       	ldd	r25, Y+3	; 0x03
    40a2:	0e 94 ad 1f 	call	0x3f5a	; 0x3f5a <prvTaskIsTaskSuspended>
    40a6:	88 23       	and	r24, r24
    40a8:	09 f4       	brne	.+2      	; 0x40ac <xTaskResumeFromISR+0x2c>
    40aa:	46 c0       	rjmp	.+140    	; 0x4138 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40ac:	80 91 ca 06 	lds	r24, 0x06CA
    40b0:	88 23       	and	r24, r24
    40b2:	c1 f5       	brne	.+112    	; 0x4124 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    40b4:	ea 81       	ldd	r30, Y+2	; 0x02
    40b6:	fb 81       	ldd	r31, Y+3	; 0x03
    40b8:	96 89       	ldd	r25, Z+22	; 0x16
    40ba:	e0 91 ba 06 	lds	r30, 0x06BA
    40be:	f0 91 bb 06 	lds	r31, 0x06BB
    40c2:	86 89       	ldd	r24, Z+22	; 0x16
    40c4:	98 17       	cp	r25, r24
    40c6:	10 f0       	brcs	.+4      	; 0x40cc <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    40c8:	81 e0       	ldi	r24, 0x01	; 1
    40ca:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    40cc:	8a 81       	ldd	r24, Y+2	; 0x02
    40ce:	9b 81       	ldd	r25, Y+3	; 0x03
    40d0:	02 96       	adiw	r24, 0x02	; 2
    40d2:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    40d6:	ea 81       	ldd	r30, Y+2	; 0x02
    40d8:	fb 81       	ldd	r31, Y+3	; 0x03
    40da:	96 89       	ldd	r25, Z+22	; 0x16
    40dc:	80 91 c0 06 	lds	r24, 0x06C0
    40e0:	89 17       	cp	r24, r25
    40e2:	28 f4       	brcc	.+10     	; 0x40ee <xTaskResumeFromISR+0x6e>
    40e4:	ea 81       	ldd	r30, Y+2	; 0x02
    40e6:	fb 81       	ldd	r31, Y+3	; 0x03
    40e8:	86 89       	ldd	r24, Z+22	; 0x16
    40ea:	80 93 c0 06 	sts	0x06C0, r24
    40ee:	ea 81       	ldd	r30, Y+2	; 0x02
    40f0:	fb 81       	ldd	r31, Y+3	; 0x03
    40f2:	86 89       	ldd	r24, Z+22	; 0x16
    40f4:	28 2f       	mov	r18, r24
    40f6:	30 e0       	ldi	r19, 0x00	; 0
    40f8:	c9 01       	movw	r24, r18
    40fa:	88 0f       	add	r24, r24
    40fc:	99 1f       	adc	r25, r25
    40fe:	88 0f       	add	r24, r24
    4100:	99 1f       	adc	r25, r25
    4102:	88 0f       	add	r24, r24
    4104:	99 1f       	adc	r25, r25
    4106:	82 0f       	add	r24, r18
    4108:	93 1f       	adc	r25, r19
    410a:	ac 01       	movw	r20, r24
    410c:	45 53       	subi	r20, 0x35	; 53
    410e:	59 4f       	sbci	r21, 0xF9	; 249
    4110:	8a 81       	ldd	r24, Y+2	; 0x02
    4112:	9b 81       	ldd	r25, Y+3	; 0x03
    4114:	9c 01       	movw	r18, r24
    4116:	2e 5f       	subi	r18, 0xFE	; 254
    4118:	3f 4f       	sbci	r19, 0xFF	; 255
    411a:	ca 01       	movw	r24, r20
    411c:	b9 01       	movw	r22, r18
    411e:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
    4122:	0a c0       	rjmp	.+20     	; 0x4138 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4124:	8a 81       	ldd	r24, Y+2	; 0x02
    4126:	9b 81       	ldd	r25, Y+3	; 0x03
    4128:	9c 01       	movw	r18, r24
    412a:	24 5f       	subi	r18, 0xF4	; 244
    412c:	3f 4f       	sbci	r19, 0xFF	; 255
    412e:	8e e0       	ldi	r24, 0x0E	; 14
    4130:	97 e0       	ldi	r25, 0x07	; 7
    4132:	b9 01       	movw	r22, r18
    4134:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4138:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    413a:	26 96       	adiw	r28, 0x06	; 6
    413c:	0f b6       	in	r0, 0x3f	; 63
    413e:	f8 94       	cli
    4140:	de bf       	out	0x3e, r29	; 62
    4142:	0f be       	out	0x3f, r0	; 63
    4144:	cd bf       	out	0x3d, r28	; 61
    4146:	cf 91       	pop	r28
    4148:	df 91       	pop	r29
    414a:	08 95       	ret

0000414c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    414c:	ef 92       	push	r14
    414e:	ff 92       	push	r15
    4150:	0f 93       	push	r16
    4152:	df 93       	push	r29
    4154:	cf 93       	push	r28
    4156:	0f 92       	push	r0
    4158:	cd b7       	in	r28, 0x3d	; 61
    415a:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    415c:	8a ef       	ldi	r24, 0xFA	; 250
    415e:	94 e2       	ldi	r25, 0x24	; 36
    4160:	2c ec       	ldi	r18, 0xCC	; 204
    4162:	30 e0       	ldi	r19, 0x00	; 0
    4164:	e8 ec       	ldi	r30, 0xC8	; 200
    4166:	f6 e0       	ldi	r31, 0x06	; 6
    4168:	b9 01       	movw	r22, r18
    416a:	46 e9       	ldi	r20, 0x96	; 150
    416c:	50 e0       	ldi	r21, 0x00	; 0
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	00 e0       	ldi	r16, 0x00	; 0
    4174:	7f 01       	movw	r14, r30
    4176:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <xTaskCreate>
    417a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    417c:	89 81       	ldd	r24, Y+1	; 0x01
    417e:	81 30       	cpi	r24, 0x01	; 1
    4180:	81 f4       	brne	.+32     	; 0x41a2 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4182:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4184:	8f ef       	ldi	r24, 0xFF	; 255
    4186:	9f ef       	ldi	r25, 0xFF	; 255
    4188:	90 93 c7 06 	sts	0x06C7, r25
    418c:	80 93 c6 06 	sts	0x06C6, r24
		xSchedulerRunning = pdTRUE;
    4190:	81 e0       	ldi	r24, 0x01	; 1
    4192:	80 93 c1 06 	sts	0x06C1, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4196:	10 92 bf 06 	sts	0x06BF, r1
    419a:	10 92 be 06 	sts	0x06BE, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    419e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    41a2:	0f 90       	pop	r0
    41a4:	cf 91       	pop	r28
    41a6:	df 91       	pop	r29
    41a8:	0f 91       	pop	r16
    41aa:	ff 90       	pop	r15
    41ac:	ef 90       	pop	r14
    41ae:	08 95       	ret

000041b0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    41b0:	df 93       	push	r29
    41b2:	cf 93       	push	r28
    41b4:	cd b7       	in	r28, 0x3d	; 61
    41b6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    41b8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    41ba:	10 92 c1 06 	sts	0x06C1, r1
	vPortEndScheduler();
    41be:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <vPortEndScheduler>
}
    41c2:	cf 91       	pop	r28
    41c4:	df 91       	pop	r29
    41c6:	08 95       	ret

000041c8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    41c8:	df 93       	push	r29
    41ca:	cf 93       	push	r28
    41cc:	cd b7       	in	r28, 0x3d	; 61
    41ce:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    41d0:	80 91 ca 06 	lds	r24, 0x06CA
    41d4:	8f 5f       	subi	r24, 0xFF	; 255
    41d6:	80 93 ca 06 	sts	0x06CA, r24
}
    41da:	cf 91       	pop	r28
    41dc:	df 91       	pop	r29
    41de:	08 95       	ret

000041e0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    41e0:	df 93       	push	r29
    41e2:	cf 93       	push	r28
    41e4:	00 d0       	rcall	.+0      	; 0x41e6 <xTaskResumeAll+0x6>
    41e6:	00 d0       	rcall	.+0      	; 0x41e8 <xTaskResumeAll+0x8>
    41e8:	cd b7       	in	r28, 0x3d	; 61
    41ea:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    41ec:	1c 82       	std	Y+4, r1	; 0x04
    41ee:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    41f0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    41f2:	0f b6       	in	r0, 0x3f	; 63
    41f4:	f8 94       	cli
    41f6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    41f8:	80 91 ca 06 	lds	r24, 0x06CA
    41fc:	81 50       	subi	r24, 0x01	; 1
    41fe:	80 93 ca 06 	sts	0x06CA, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4202:	80 91 ca 06 	lds	r24, 0x06CA
    4206:	88 23       	and	r24, r24
    4208:	09 f0       	breq	.+2      	; 0x420c <xTaskResumeAll+0x2c>
    420a:	73 c0       	rjmp	.+230    	; 0x42f2 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    420c:	80 91 bd 06 	lds	r24, 0x06BD
    4210:	88 23       	and	r24, r24
    4212:	09 f4       	brne	.+2      	; 0x4216 <xTaskResumeAll+0x36>
    4214:	6e c0       	rjmp	.+220    	; 0x42f2 <xTaskResumeAll+0x112>
    4216:	45 c0       	rjmp	.+138    	; 0x42a2 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4218:	e0 91 13 07 	lds	r30, 0x0713
    421c:	f0 91 14 07 	lds	r31, 0x0714
    4220:	86 81       	ldd	r24, Z+6	; 0x06
    4222:	97 81       	ldd	r25, Z+7	; 0x07
    4224:	9c 83       	std	Y+4, r25	; 0x04
    4226:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4228:	8b 81       	ldd	r24, Y+3	; 0x03
    422a:	9c 81       	ldd	r25, Y+4	; 0x04
    422c:	0c 96       	adiw	r24, 0x0c	; 12
    422e:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4232:	8b 81       	ldd	r24, Y+3	; 0x03
    4234:	9c 81       	ldd	r25, Y+4	; 0x04
    4236:	02 96       	adiw	r24, 0x02	; 2
    4238:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    423c:	eb 81       	ldd	r30, Y+3	; 0x03
    423e:	fc 81       	ldd	r31, Y+4	; 0x04
    4240:	96 89       	ldd	r25, Z+22	; 0x16
    4242:	80 91 c0 06 	lds	r24, 0x06C0
    4246:	89 17       	cp	r24, r25
    4248:	28 f4       	brcc	.+10     	; 0x4254 <xTaskResumeAll+0x74>
    424a:	eb 81       	ldd	r30, Y+3	; 0x03
    424c:	fc 81       	ldd	r31, Y+4	; 0x04
    424e:	86 89       	ldd	r24, Z+22	; 0x16
    4250:	80 93 c0 06 	sts	0x06C0, r24
    4254:	eb 81       	ldd	r30, Y+3	; 0x03
    4256:	fc 81       	ldd	r31, Y+4	; 0x04
    4258:	86 89       	ldd	r24, Z+22	; 0x16
    425a:	28 2f       	mov	r18, r24
    425c:	30 e0       	ldi	r19, 0x00	; 0
    425e:	c9 01       	movw	r24, r18
    4260:	88 0f       	add	r24, r24
    4262:	99 1f       	adc	r25, r25
    4264:	88 0f       	add	r24, r24
    4266:	99 1f       	adc	r25, r25
    4268:	88 0f       	add	r24, r24
    426a:	99 1f       	adc	r25, r25
    426c:	82 0f       	add	r24, r18
    426e:	93 1f       	adc	r25, r19
    4270:	ac 01       	movw	r20, r24
    4272:	45 53       	subi	r20, 0x35	; 53
    4274:	59 4f       	sbci	r21, 0xF9	; 249
    4276:	8b 81       	ldd	r24, Y+3	; 0x03
    4278:	9c 81       	ldd	r25, Y+4	; 0x04
    427a:	9c 01       	movw	r18, r24
    427c:	2e 5f       	subi	r18, 0xFE	; 254
    427e:	3f 4f       	sbci	r19, 0xFF	; 255
    4280:	ca 01       	movw	r24, r20
    4282:	b9 01       	movw	r22, r18
    4284:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4288:	eb 81       	ldd	r30, Y+3	; 0x03
    428a:	fc 81       	ldd	r31, Y+4	; 0x04
    428c:	96 89       	ldd	r25, Z+22	; 0x16
    428e:	e0 91 ba 06 	lds	r30, 0x06BA
    4292:	f0 91 bb 06 	lds	r31, 0x06BB
    4296:	86 89       	ldd	r24, Z+22	; 0x16
    4298:	98 17       	cp	r25, r24
    429a:	18 f0       	brcs	.+6      	; 0x42a2 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    429c:	81 e0       	ldi	r24, 0x01	; 1
    429e:	80 93 c3 06 	sts	0x06C3, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    42a2:	80 91 0e 07 	lds	r24, 0x070E
    42a6:	88 23       	and	r24, r24
    42a8:	09 f0       	breq	.+2      	; 0x42ac <xTaskResumeAll+0xcc>
    42aa:	b6 cf       	rjmp	.-148    	; 0x4218 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    42ac:	8b 81       	ldd	r24, Y+3	; 0x03
    42ae:	9c 81       	ldd	r25, Y+4	; 0x04
    42b0:	00 97       	sbiw	r24, 0x00	; 0
    42b2:	11 f0       	breq	.+4      	; 0x42b8 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    42b4:	0e 94 8a 25 	call	0x4b14	; 0x4b14 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    42b8:	80 91 c2 06 	lds	r24, 0x06C2
    42bc:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    42be:	89 81       	ldd	r24, Y+1	; 0x01
    42c0:	88 23       	and	r24, r24
    42c2:	79 f0       	breq	.+30     	; 0x42e2 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    42c4:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <xTaskIncrementTick>
    42c8:	88 23       	and	r24, r24
    42ca:	19 f0       	breq	.+6      	; 0x42d2 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    42cc:	81 e0       	ldi	r24, 0x01	; 1
    42ce:	80 93 c3 06 	sts	0x06C3, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    42d2:	89 81       	ldd	r24, Y+1	; 0x01
    42d4:	81 50       	subi	r24, 0x01	; 1
    42d6:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    42d8:	89 81       	ldd	r24, Y+1	; 0x01
    42da:	88 23       	and	r24, r24
    42dc:	99 f7       	brne	.-26     	; 0x42c4 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    42de:	10 92 c2 06 	sts	0x06C2, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    42e2:	80 91 c3 06 	lds	r24, 0x06C3
    42e6:	88 23       	and	r24, r24
    42e8:	21 f0       	breq	.+8      	; 0x42f2 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    42ea:	81 e0       	ldi	r24, 0x01	; 1
    42ec:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    42ee:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    42f2:	0f 90       	pop	r0
    42f4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    42f6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	0f 90       	pop	r0
    42fe:	0f 90       	pop	r0
    4300:	cf 91       	pop	r28
    4302:	df 91       	pop	r29
    4304:	08 95       	ret

00004306 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4306:	df 93       	push	r29
    4308:	cf 93       	push	r28
    430a:	00 d0       	rcall	.+0      	; 0x430c <xTaskGetTickCount+0x6>
    430c:	cd b7       	in	r28, 0x3d	; 61
    430e:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4310:	0f b6       	in	r0, 0x3f	; 63
    4312:	f8 94       	cli
    4314:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4316:	80 91 be 06 	lds	r24, 0x06BE
    431a:	90 91 bf 06 	lds	r25, 0x06BF
    431e:	9a 83       	std	Y+2, r25	; 0x02
    4320:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4322:	0f 90       	pop	r0
    4324:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4326:	89 81       	ldd	r24, Y+1	; 0x01
    4328:	9a 81       	ldd	r25, Y+2	; 0x02
}
    432a:	0f 90       	pop	r0
    432c:	0f 90       	pop	r0
    432e:	cf 91       	pop	r28
    4330:	df 91       	pop	r29
    4332:	08 95       	ret

00004334 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4334:	df 93       	push	r29
    4336:	cf 93       	push	r28
    4338:	00 d0       	rcall	.+0      	; 0x433a <xTaskGetTickCountFromISR+0x6>
    433a:	0f 92       	push	r0
    433c:	cd b7       	in	r28, 0x3d	; 61
    433e:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4340:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4342:	80 91 be 06 	lds	r24, 0x06BE
    4346:	90 91 bf 06 	lds	r25, 0x06BF
    434a:	9b 83       	std	Y+3, r25	; 0x03
    434c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    434e:	8a 81       	ldd	r24, Y+2	; 0x02
    4350:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4352:	0f 90       	pop	r0
    4354:	0f 90       	pop	r0
    4356:	0f 90       	pop	r0
    4358:	cf 91       	pop	r28
    435a:	df 91       	pop	r29
    435c:	08 95       	ret

0000435e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    435e:	df 93       	push	r29
    4360:	cf 93       	push	r28
    4362:	cd b7       	in	r28, 0x3d	; 61
    4364:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4366:	80 91 bd 06 	lds	r24, 0x06BD
}
    436a:	cf 91       	pop	r28
    436c:	df 91       	pop	r29
    436e:	08 95       	ret

00004370 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4370:	df 93       	push	r29
    4372:	cf 93       	push	r28
    4374:	00 d0       	rcall	.+0      	; 0x4376 <pcTaskGetName+0x6>
    4376:	00 d0       	rcall	.+0      	; 0x4378 <pcTaskGetName+0x8>
    4378:	00 d0       	rcall	.+0      	; 0x437a <pcTaskGetName+0xa>
    437a:	cd b7       	in	r28, 0x3d	; 61
    437c:	de b7       	in	r29, 0x3e	; 62
    437e:	9c 83       	std	Y+4, r25	; 0x04
    4380:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4382:	8b 81       	ldd	r24, Y+3	; 0x03
    4384:	9c 81       	ldd	r25, Y+4	; 0x04
    4386:	00 97       	sbiw	r24, 0x00	; 0
    4388:	39 f4       	brne	.+14     	; 0x4398 <pcTaskGetName+0x28>
    438a:	80 91 ba 06 	lds	r24, 0x06BA
    438e:	90 91 bb 06 	lds	r25, 0x06BB
    4392:	9e 83       	std	Y+6, r25	; 0x06
    4394:	8d 83       	std	Y+5, r24	; 0x05
    4396:	04 c0       	rjmp	.+8      	; 0x43a0 <pcTaskGetName+0x30>
    4398:	8b 81       	ldd	r24, Y+3	; 0x03
    439a:	9c 81       	ldd	r25, Y+4	; 0x04
    439c:	9e 83       	std	Y+6, r25	; 0x06
    439e:	8d 83       	std	Y+5, r24	; 0x05
    43a0:	8d 81       	ldd	r24, Y+5	; 0x05
    43a2:	9e 81       	ldd	r25, Y+6	; 0x06
    43a4:	9a 83       	std	Y+2, r25	; 0x02
    43a6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    43a8:	89 81       	ldd	r24, Y+1	; 0x01
    43aa:	9a 81       	ldd	r25, Y+2	; 0x02
    43ac:	49 96       	adiw	r24, 0x19	; 25
}
    43ae:	26 96       	adiw	r28, 0x06	; 6
    43b0:	0f b6       	in	r0, 0x3f	; 63
    43b2:	f8 94       	cli
    43b4:	de bf       	out	0x3e, r29	; 62
    43b6:	0f be       	out	0x3f, r0	; 63
    43b8:	cd bf       	out	0x3d, r28	; 61
    43ba:	cf 91       	pop	r28
    43bc:	df 91       	pop	r29
    43be:	08 95       	ret

000043c0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    43c0:	df 93       	push	r29
    43c2:	cf 93       	push	r28
    43c4:	cd b7       	in	r28, 0x3d	; 61
    43c6:	de b7       	in	r29, 0x3e	; 62
    43c8:	29 97       	sbiw	r28, 0x09	; 9
    43ca:	0f b6       	in	r0, 0x3f	; 63
    43cc:	f8 94       	cli
    43ce:	de bf       	out	0x3e, r29	; 62
    43d0:	0f be       	out	0x3f, r0	; 63
    43d2:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    43d4:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    43d6:	80 91 ca 06 	lds	r24, 0x06CA
    43da:	88 23       	and	r24, r24
    43dc:	09 f0       	breq	.+2      	; 0x43e0 <xTaskIncrementTick+0x20>
    43de:	c0 c0       	rjmp	.+384    	; 0x4560 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    43e0:	80 91 be 06 	lds	r24, 0x06BE
    43e4:	90 91 bf 06 	lds	r25, 0x06BF
    43e8:	01 96       	adiw	r24, 0x01	; 1
    43ea:	9c 83       	std	Y+4, r25	; 0x04
    43ec:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    43ee:	8b 81       	ldd	r24, Y+3	; 0x03
    43f0:	9c 81       	ldd	r25, Y+4	; 0x04
    43f2:	90 93 bf 06 	sts	0x06BF, r25
    43f6:	80 93 be 06 	sts	0x06BE, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    43fa:	8b 81       	ldd	r24, Y+3	; 0x03
    43fc:	9c 81       	ldd	r25, Y+4	; 0x04
    43fe:	00 97       	sbiw	r24, 0x00	; 0
    4400:	d9 f4       	brne	.+54     	; 0x4438 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4402:	80 91 0a 07 	lds	r24, 0x070A
    4406:	90 91 0b 07 	lds	r25, 0x070B
    440a:	9a 83       	std	Y+2, r25	; 0x02
    440c:	89 83       	std	Y+1, r24	; 0x01
    440e:	80 91 0c 07 	lds	r24, 0x070C
    4412:	90 91 0d 07 	lds	r25, 0x070D
    4416:	90 93 0b 07 	sts	0x070B, r25
    441a:	80 93 0a 07 	sts	0x070A, r24
    441e:	89 81       	ldd	r24, Y+1	; 0x01
    4420:	9a 81       	ldd	r25, Y+2	; 0x02
    4422:	90 93 0d 07 	sts	0x070D, r25
    4426:	80 93 0c 07 	sts	0x070C, r24
    442a:	80 91 c4 06 	lds	r24, 0x06C4
    442e:	8f 5f       	subi	r24, 0xFF	; 255
    4430:	80 93 c4 06 	sts	0x06C4, r24
    4434:	0e 94 8a 25 	call	0x4b14	; 0x4b14 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4438:	20 91 c6 06 	lds	r18, 0x06C6
    443c:	30 91 c7 06 	lds	r19, 0x06C7
    4440:	8b 81       	ldd	r24, Y+3	; 0x03
    4442:	9c 81       	ldd	r25, Y+4	; 0x04
    4444:	82 17       	cp	r24, r18
    4446:	93 07       	cpc	r25, r19
    4448:	08 f4       	brcc	.+2      	; 0x444c <xTaskIncrementTick+0x8c>
    444a:	71 c0       	rjmp	.+226    	; 0x452e <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    444c:	e0 91 0a 07 	lds	r30, 0x070A
    4450:	f0 91 0b 07 	lds	r31, 0x070B
    4454:	80 81       	ld	r24, Z
    4456:	88 23       	and	r24, r24
    4458:	39 f4       	brne	.+14     	; 0x4468 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    445a:	8f ef       	ldi	r24, 0xFF	; 255
    445c:	9f ef       	ldi	r25, 0xFF	; 255
    445e:	90 93 c7 06 	sts	0x06C7, r25
    4462:	80 93 c6 06 	sts	0x06C6, r24
    4466:	63 c0       	rjmp	.+198    	; 0x452e <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4468:	e0 91 0a 07 	lds	r30, 0x070A
    446c:	f0 91 0b 07 	lds	r31, 0x070B
    4470:	05 80       	ldd	r0, Z+5	; 0x05
    4472:	f6 81       	ldd	r31, Z+6	; 0x06
    4474:	e0 2d       	mov	r30, r0
    4476:	86 81       	ldd	r24, Z+6	; 0x06
    4478:	97 81       	ldd	r25, Z+7	; 0x07
    447a:	99 87       	std	Y+9, r25	; 0x09
    447c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    447e:	e8 85       	ldd	r30, Y+8	; 0x08
    4480:	f9 85       	ldd	r31, Y+9	; 0x09
    4482:	82 81       	ldd	r24, Z+2	; 0x02
    4484:	93 81       	ldd	r25, Z+3	; 0x03
    4486:	9f 83       	std	Y+7, r25	; 0x07
    4488:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    448a:	2b 81       	ldd	r18, Y+3	; 0x03
    448c:	3c 81       	ldd	r19, Y+4	; 0x04
    448e:	8e 81       	ldd	r24, Y+6	; 0x06
    4490:	9f 81       	ldd	r25, Y+7	; 0x07
    4492:	28 17       	cp	r18, r24
    4494:	39 07       	cpc	r19, r25
    4496:	38 f4       	brcc	.+14     	; 0x44a6 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4498:	8e 81       	ldd	r24, Y+6	; 0x06
    449a:	9f 81       	ldd	r25, Y+7	; 0x07
    449c:	90 93 c7 06 	sts	0x06C7, r25
    44a0:	80 93 c6 06 	sts	0x06C6, r24
    44a4:	44 c0       	rjmp	.+136    	; 0x452e <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44a6:	88 85       	ldd	r24, Y+8	; 0x08
    44a8:	99 85       	ldd	r25, Y+9	; 0x09
    44aa:	02 96       	adiw	r24, 0x02	; 2
    44ac:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    44b0:	e8 85       	ldd	r30, Y+8	; 0x08
    44b2:	f9 85       	ldd	r31, Y+9	; 0x09
    44b4:	84 89       	ldd	r24, Z+20	; 0x14
    44b6:	95 89       	ldd	r25, Z+21	; 0x15
    44b8:	00 97       	sbiw	r24, 0x00	; 0
    44ba:	29 f0       	breq	.+10     	; 0x44c6 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    44bc:	88 85       	ldd	r24, Y+8	; 0x08
    44be:	99 85       	ldd	r25, Y+9	; 0x09
    44c0:	0c 96       	adiw	r24, 0x0c	; 12
    44c2:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    44c6:	e8 85       	ldd	r30, Y+8	; 0x08
    44c8:	f9 85       	ldd	r31, Y+9	; 0x09
    44ca:	96 89       	ldd	r25, Z+22	; 0x16
    44cc:	80 91 c0 06 	lds	r24, 0x06C0
    44d0:	89 17       	cp	r24, r25
    44d2:	28 f4       	brcc	.+10     	; 0x44de <xTaskIncrementTick+0x11e>
    44d4:	e8 85       	ldd	r30, Y+8	; 0x08
    44d6:	f9 85       	ldd	r31, Y+9	; 0x09
    44d8:	86 89       	ldd	r24, Z+22	; 0x16
    44da:	80 93 c0 06 	sts	0x06C0, r24
    44de:	e8 85       	ldd	r30, Y+8	; 0x08
    44e0:	f9 85       	ldd	r31, Y+9	; 0x09
    44e2:	86 89       	ldd	r24, Z+22	; 0x16
    44e4:	28 2f       	mov	r18, r24
    44e6:	30 e0       	ldi	r19, 0x00	; 0
    44e8:	c9 01       	movw	r24, r18
    44ea:	88 0f       	add	r24, r24
    44ec:	99 1f       	adc	r25, r25
    44ee:	88 0f       	add	r24, r24
    44f0:	99 1f       	adc	r25, r25
    44f2:	88 0f       	add	r24, r24
    44f4:	99 1f       	adc	r25, r25
    44f6:	82 0f       	add	r24, r18
    44f8:	93 1f       	adc	r25, r19
    44fa:	ac 01       	movw	r20, r24
    44fc:	45 53       	subi	r20, 0x35	; 53
    44fe:	59 4f       	sbci	r21, 0xF9	; 249
    4500:	88 85       	ldd	r24, Y+8	; 0x08
    4502:	99 85       	ldd	r25, Y+9	; 0x09
    4504:	9c 01       	movw	r18, r24
    4506:	2e 5f       	subi	r18, 0xFE	; 254
    4508:	3f 4f       	sbci	r19, 0xFF	; 255
    450a:	ca 01       	movw	r24, r20
    450c:	b9 01       	movw	r22, r18
    450e:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4512:	e8 85       	ldd	r30, Y+8	; 0x08
    4514:	f9 85       	ldd	r31, Y+9	; 0x09
    4516:	96 89       	ldd	r25, Z+22	; 0x16
    4518:	e0 91 ba 06 	lds	r30, 0x06BA
    451c:	f0 91 bb 06 	lds	r31, 0x06BB
    4520:	86 89       	ldd	r24, Z+22	; 0x16
    4522:	98 17       	cp	r25, r24
    4524:	08 f4       	brcc	.+2      	; 0x4528 <xTaskIncrementTick+0x168>
    4526:	92 cf       	rjmp	.-220    	; 0x444c <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4528:	81 e0       	ldi	r24, 0x01	; 1
    452a:	8d 83       	std	Y+5, r24	; 0x05
    452c:	8f cf       	rjmp	.-226    	; 0x444c <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    452e:	e0 91 ba 06 	lds	r30, 0x06BA
    4532:	f0 91 bb 06 	lds	r31, 0x06BB
    4536:	86 89       	ldd	r24, Z+22	; 0x16
    4538:	28 2f       	mov	r18, r24
    453a:	30 e0       	ldi	r19, 0x00	; 0
    453c:	c9 01       	movw	r24, r18
    453e:	88 0f       	add	r24, r24
    4540:	99 1f       	adc	r25, r25
    4542:	88 0f       	add	r24, r24
    4544:	99 1f       	adc	r25, r25
    4546:	88 0f       	add	r24, r24
    4548:	99 1f       	adc	r25, r25
    454a:	82 0f       	add	r24, r18
    454c:	93 1f       	adc	r25, r19
    454e:	fc 01       	movw	r30, r24
    4550:	e5 53       	subi	r30, 0x35	; 53
    4552:	f9 4f       	sbci	r31, 0xF9	; 249
    4554:	80 81       	ld	r24, Z
    4556:	82 30       	cpi	r24, 0x02	; 2
    4558:	40 f0       	brcs	.+16     	; 0x456a <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    455a:	81 e0       	ldi	r24, 0x01	; 1
    455c:	8d 83       	std	Y+5, r24	; 0x05
    455e:	05 c0       	rjmp	.+10     	; 0x456a <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4560:	80 91 c2 06 	lds	r24, 0x06C2
    4564:	8f 5f       	subi	r24, 0xFF	; 255
    4566:	80 93 c2 06 	sts	0x06C2, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    456a:	80 91 c3 06 	lds	r24, 0x06C3
    456e:	88 23       	and	r24, r24
    4570:	11 f0       	breq	.+4      	; 0x4576 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    4572:	81 e0       	ldi	r24, 0x01	; 1
    4574:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4576:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4578:	29 96       	adiw	r28, 0x09	; 9
    457a:	0f b6       	in	r0, 0x3f	; 63
    457c:	f8 94       	cli
    457e:	de bf       	out	0x3e, r29	; 62
    4580:	0f be       	out	0x3f, r0	; 63
    4582:	cd bf       	out	0x3d, r28	; 61
    4584:	cf 91       	pop	r28
    4586:	df 91       	pop	r29
    4588:	08 95       	ret

0000458a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    458a:	df 93       	push	r29
    458c:	cf 93       	push	r28
    458e:	00 d0       	rcall	.+0      	; 0x4590 <vTaskSwitchContext+0x6>
    4590:	0f 92       	push	r0
    4592:	cd b7       	in	r28, 0x3d	; 61
    4594:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4596:	80 91 ca 06 	lds	r24, 0x06CA
    459a:	88 23       	and	r24, r24
    459c:	21 f0       	breq	.+8      	; 0x45a6 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    459e:	81 e0       	ldi	r24, 0x01	; 1
    45a0:	80 93 c3 06 	sts	0x06C3, r24
    45a4:	59 c0       	rjmp	.+178    	; 0x4658 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    45a6:	10 92 c3 06 	sts	0x06C3, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    45aa:	80 91 c0 06 	lds	r24, 0x06C0
    45ae:	8b 83       	std	Y+3, r24	; 0x03
    45b0:	03 c0       	rjmp	.+6      	; 0x45b8 <vTaskSwitchContext+0x2e>
    45b2:	8b 81       	ldd	r24, Y+3	; 0x03
    45b4:	81 50       	subi	r24, 0x01	; 1
    45b6:	8b 83       	std	Y+3, r24	; 0x03
    45b8:	8b 81       	ldd	r24, Y+3	; 0x03
    45ba:	28 2f       	mov	r18, r24
    45bc:	30 e0       	ldi	r19, 0x00	; 0
    45be:	c9 01       	movw	r24, r18
    45c0:	88 0f       	add	r24, r24
    45c2:	99 1f       	adc	r25, r25
    45c4:	88 0f       	add	r24, r24
    45c6:	99 1f       	adc	r25, r25
    45c8:	88 0f       	add	r24, r24
    45ca:	99 1f       	adc	r25, r25
    45cc:	82 0f       	add	r24, r18
    45ce:	93 1f       	adc	r25, r19
    45d0:	fc 01       	movw	r30, r24
    45d2:	e5 53       	subi	r30, 0x35	; 53
    45d4:	f9 4f       	sbci	r31, 0xF9	; 249
    45d6:	80 81       	ld	r24, Z
    45d8:	88 23       	and	r24, r24
    45da:	59 f3       	breq	.-42     	; 0x45b2 <vTaskSwitchContext+0x28>
    45dc:	8b 81       	ldd	r24, Y+3	; 0x03
    45de:	28 2f       	mov	r18, r24
    45e0:	30 e0       	ldi	r19, 0x00	; 0
    45e2:	c9 01       	movw	r24, r18
    45e4:	88 0f       	add	r24, r24
    45e6:	99 1f       	adc	r25, r25
    45e8:	88 0f       	add	r24, r24
    45ea:	99 1f       	adc	r25, r25
    45ec:	88 0f       	add	r24, r24
    45ee:	99 1f       	adc	r25, r25
    45f0:	82 0f       	add	r24, r18
    45f2:	93 1f       	adc	r25, r19
    45f4:	85 53       	subi	r24, 0x35	; 53
    45f6:	99 4f       	sbci	r25, 0xF9	; 249
    45f8:	9a 83       	std	Y+2, r25	; 0x02
    45fa:	89 83       	std	Y+1, r24	; 0x01
    45fc:	e9 81       	ldd	r30, Y+1	; 0x01
    45fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4600:	01 80       	ldd	r0, Z+1	; 0x01
    4602:	f2 81       	ldd	r31, Z+2	; 0x02
    4604:	e0 2d       	mov	r30, r0
    4606:	82 81       	ldd	r24, Z+2	; 0x02
    4608:	93 81       	ldd	r25, Z+3	; 0x03
    460a:	e9 81       	ldd	r30, Y+1	; 0x01
    460c:	fa 81       	ldd	r31, Y+2	; 0x02
    460e:	92 83       	std	Z+2, r25	; 0x02
    4610:	81 83       	std	Z+1, r24	; 0x01
    4612:	e9 81       	ldd	r30, Y+1	; 0x01
    4614:	fa 81       	ldd	r31, Y+2	; 0x02
    4616:	21 81       	ldd	r18, Z+1	; 0x01
    4618:	32 81       	ldd	r19, Z+2	; 0x02
    461a:	89 81       	ldd	r24, Y+1	; 0x01
    461c:	9a 81       	ldd	r25, Y+2	; 0x02
    461e:	03 96       	adiw	r24, 0x03	; 3
    4620:	28 17       	cp	r18, r24
    4622:	39 07       	cpc	r19, r25
    4624:	59 f4       	brne	.+22     	; 0x463c <vTaskSwitchContext+0xb2>
    4626:	e9 81       	ldd	r30, Y+1	; 0x01
    4628:	fa 81       	ldd	r31, Y+2	; 0x02
    462a:	01 80       	ldd	r0, Z+1	; 0x01
    462c:	f2 81       	ldd	r31, Z+2	; 0x02
    462e:	e0 2d       	mov	r30, r0
    4630:	82 81       	ldd	r24, Z+2	; 0x02
    4632:	93 81       	ldd	r25, Z+3	; 0x03
    4634:	e9 81       	ldd	r30, Y+1	; 0x01
    4636:	fa 81       	ldd	r31, Y+2	; 0x02
    4638:	92 83       	std	Z+2, r25	; 0x02
    463a:	81 83       	std	Z+1, r24	; 0x01
    463c:	e9 81       	ldd	r30, Y+1	; 0x01
    463e:	fa 81       	ldd	r31, Y+2	; 0x02
    4640:	01 80       	ldd	r0, Z+1	; 0x01
    4642:	f2 81       	ldd	r31, Z+2	; 0x02
    4644:	e0 2d       	mov	r30, r0
    4646:	86 81       	ldd	r24, Z+6	; 0x06
    4648:	97 81       	ldd	r25, Z+7	; 0x07
    464a:	90 93 bb 06 	sts	0x06BB, r25
    464e:	80 93 ba 06 	sts	0x06BA, r24
    4652:	8b 81       	ldd	r24, Y+3	; 0x03
    4654:	80 93 c0 06 	sts	0x06C0, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4658:	0f 90       	pop	r0
    465a:	0f 90       	pop	r0
    465c:	0f 90       	pop	r0
    465e:	cf 91       	pop	r28
    4660:	df 91       	pop	r29
    4662:	08 95       	ret

00004664 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4664:	df 93       	push	r29
    4666:	cf 93       	push	r28
    4668:	00 d0       	rcall	.+0      	; 0x466a <vTaskPlaceOnEventList+0x6>
    466a:	00 d0       	rcall	.+0      	; 0x466c <vTaskPlaceOnEventList+0x8>
    466c:	cd b7       	in	r28, 0x3d	; 61
    466e:	de b7       	in	r29, 0x3e	; 62
    4670:	9a 83       	std	Y+2, r25	; 0x02
    4672:	89 83       	std	Y+1, r24	; 0x01
    4674:	7c 83       	std	Y+4, r23	; 0x04
    4676:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4678:	80 91 ba 06 	lds	r24, 0x06BA
    467c:	90 91 bb 06 	lds	r25, 0x06BB
    4680:	9c 01       	movw	r18, r24
    4682:	24 5f       	subi	r18, 0xF4	; 244
    4684:	3f 4f       	sbci	r19, 0xFF	; 255
    4686:	89 81       	ldd	r24, Y+1	; 0x01
    4688:	9a 81       	ldd	r25, Y+2	; 0x02
    468a:	b9 01       	movw	r22, r18
    468c:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4690:	8b 81       	ldd	r24, Y+3	; 0x03
    4692:	9c 81       	ldd	r25, Y+4	; 0x04
    4694:	61 e0       	ldi	r22, 0x01	; 1
    4696:	0e 94 96 29 	call	0x532c	; 0x532c <prvAddCurrentTaskToDelayedList>
}
    469a:	0f 90       	pop	r0
    469c:	0f 90       	pop	r0
    469e:	0f 90       	pop	r0
    46a0:	0f 90       	pop	r0
    46a2:	cf 91       	pop	r28
    46a4:	df 91       	pop	r29
    46a6:	08 95       	ret

000046a8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    46a8:	df 93       	push	r29
    46aa:	cf 93       	push	r28
    46ac:	00 d0       	rcall	.+0      	; 0x46ae <vTaskPlaceOnUnorderedEventList+0x6>
    46ae:	00 d0       	rcall	.+0      	; 0x46b0 <vTaskPlaceOnUnorderedEventList+0x8>
    46b0:	00 d0       	rcall	.+0      	; 0x46b2 <vTaskPlaceOnUnorderedEventList+0xa>
    46b2:	cd b7       	in	r28, 0x3d	; 61
    46b4:	de b7       	in	r29, 0x3e	; 62
    46b6:	9a 83       	std	Y+2, r25	; 0x02
    46b8:	89 83       	std	Y+1, r24	; 0x01
    46ba:	7c 83       	std	Y+4, r23	; 0x04
    46bc:	6b 83       	std	Y+3, r22	; 0x03
    46be:	5e 83       	std	Y+6, r21	; 0x06
    46c0:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    46c2:	e0 91 ba 06 	lds	r30, 0x06BA
    46c6:	f0 91 bb 06 	lds	r31, 0x06BB
    46ca:	8b 81       	ldd	r24, Y+3	; 0x03
    46cc:	9c 81       	ldd	r25, Y+4	; 0x04
    46ce:	90 68       	ori	r25, 0x80	; 128
    46d0:	95 87       	std	Z+13, r25	; 0x0d
    46d2:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    46d4:	80 91 ba 06 	lds	r24, 0x06BA
    46d8:	90 91 bb 06 	lds	r25, 0x06BB
    46dc:	9c 01       	movw	r18, r24
    46de:	24 5f       	subi	r18, 0xF4	; 244
    46e0:	3f 4f       	sbci	r19, 0xFF	; 255
    46e2:	89 81       	ldd	r24, Y+1	; 0x01
    46e4:	9a 81       	ldd	r25, Y+2	; 0x02
    46e6:	b9 01       	movw	r22, r18
    46e8:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    46ec:	8d 81       	ldd	r24, Y+5	; 0x05
    46ee:	9e 81       	ldd	r25, Y+6	; 0x06
    46f0:	61 e0       	ldi	r22, 0x01	; 1
    46f2:	0e 94 96 29 	call	0x532c	; 0x532c <prvAddCurrentTaskToDelayedList>
}
    46f6:	26 96       	adiw	r28, 0x06	; 6
    46f8:	0f b6       	in	r0, 0x3f	; 63
    46fa:	f8 94       	cli
    46fc:	de bf       	out	0x3e, r29	; 62
    46fe:	0f be       	out	0x3f, r0	; 63
    4700:	cd bf       	out	0x3d, r28	; 61
    4702:	cf 91       	pop	r28
    4704:	df 91       	pop	r29
    4706:	08 95       	ret

00004708 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4708:	df 93       	push	r29
    470a:	cf 93       	push	r28
    470c:	00 d0       	rcall	.+0      	; 0x470e <xTaskRemoveFromEventList+0x6>
    470e:	00 d0       	rcall	.+0      	; 0x4710 <xTaskRemoveFromEventList+0x8>
    4710:	0f 92       	push	r0
    4712:	cd b7       	in	r28, 0x3d	; 61
    4714:	de b7       	in	r29, 0x3e	; 62
    4716:	9d 83       	std	Y+5, r25	; 0x05
    4718:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    471a:	ec 81       	ldd	r30, Y+4	; 0x04
    471c:	fd 81       	ldd	r31, Y+5	; 0x05
    471e:	05 80       	ldd	r0, Z+5	; 0x05
    4720:	f6 81       	ldd	r31, Z+6	; 0x06
    4722:	e0 2d       	mov	r30, r0
    4724:	86 81       	ldd	r24, Z+6	; 0x06
    4726:	97 81       	ldd	r25, Z+7	; 0x07
    4728:	9b 83       	std	Y+3, r25	; 0x03
    472a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    472c:	8a 81       	ldd	r24, Y+2	; 0x02
    472e:	9b 81       	ldd	r25, Y+3	; 0x03
    4730:	0c 96       	adiw	r24, 0x0c	; 12
    4732:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4736:	80 91 ca 06 	lds	r24, 0x06CA
    473a:	88 23       	and	r24, r24
    473c:	61 f5       	brne	.+88     	; 0x4796 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    473e:	8a 81       	ldd	r24, Y+2	; 0x02
    4740:	9b 81       	ldd	r25, Y+3	; 0x03
    4742:	02 96       	adiw	r24, 0x02	; 2
    4744:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4748:	ea 81       	ldd	r30, Y+2	; 0x02
    474a:	fb 81       	ldd	r31, Y+3	; 0x03
    474c:	96 89       	ldd	r25, Z+22	; 0x16
    474e:	80 91 c0 06 	lds	r24, 0x06C0
    4752:	89 17       	cp	r24, r25
    4754:	28 f4       	brcc	.+10     	; 0x4760 <xTaskRemoveFromEventList+0x58>
    4756:	ea 81       	ldd	r30, Y+2	; 0x02
    4758:	fb 81       	ldd	r31, Y+3	; 0x03
    475a:	86 89       	ldd	r24, Z+22	; 0x16
    475c:	80 93 c0 06 	sts	0x06C0, r24
    4760:	ea 81       	ldd	r30, Y+2	; 0x02
    4762:	fb 81       	ldd	r31, Y+3	; 0x03
    4764:	86 89       	ldd	r24, Z+22	; 0x16
    4766:	28 2f       	mov	r18, r24
    4768:	30 e0       	ldi	r19, 0x00	; 0
    476a:	c9 01       	movw	r24, r18
    476c:	88 0f       	add	r24, r24
    476e:	99 1f       	adc	r25, r25
    4770:	88 0f       	add	r24, r24
    4772:	99 1f       	adc	r25, r25
    4774:	88 0f       	add	r24, r24
    4776:	99 1f       	adc	r25, r25
    4778:	82 0f       	add	r24, r18
    477a:	93 1f       	adc	r25, r19
    477c:	ac 01       	movw	r20, r24
    477e:	45 53       	subi	r20, 0x35	; 53
    4780:	59 4f       	sbci	r21, 0xF9	; 249
    4782:	8a 81       	ldd	r24, Y+2	; 0x02
    4784:	9b 81       	ldd	r25, Y+3	; 0x03
    4786:	9c 01       	movw	r18, r24
    4788:	2e 5f       	subi	r18, 0xFE	; 254
    478a:	3f 4f       	sbci	r19, 0xFF	; 255
    478c:	ca 01       	movw	r24, r20
    478e:	b9 01       	movw	r22, r18
    4790:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
    4794:	0a c0       	rjmp	.+20     	; 0x47aa <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4796:	8a 81       	ldd	r24, Y+2	; 0x02
    4798:	9b 81       	ldd	r25, Y+3	; 0x03
    479a:	9c 01       	movw	r18, r24
    479c:	24 5f       	subi	r18, 0xF4	; 244
    479e:	3f 4f       	sbci	r19, 0xFF	; 255
    47a0:	8e e0       	ldi	r24, 0x0E	; 14
    47a2:	97 e0       	ldi	r25, 0x07	; 7
    47a4:	b9 01       	movw	r22, r18
    47a6:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    47aa:	ea 81       	ldd	r30, Y+2	; 0x02
    47ac:	fb 81       	ldd	r31, Y+3	; 0x03
    47ae:	96 89       	ldd	r25, Z+22	; 0x16
    47b0:	e0 91 ba 06 	lds	r30, 0x06BA
    47b4:	f0 91 bb 06 	lds	r31, 0x06BB
    47b8:	86 89       	ldd	r24, Z+22	; 0x16
    47ba:	89 17       	cp	r24, r25
    47bc:	30 f4       	brcc	.+12     	; 0x47ca <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    47be:	81 e0       	ldi	r24, 0x01	; 1
    47c0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    47c2:	81 e0       	ldi	r24, 0x01	; 1
    47c4:	80 93 c3 06 	sts	0x06C3, r24
    47c8:	01 c0       	rjmp	.+2      	; 0x47cc <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    47ca:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    47cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    47ce:	0f 90       	pop	r0
    47d0:	0f 90       	pop	r0
    47d2:	0f 90       	pop	r0
    47d4:	0f 90       	pop	r0
    47d6:	0f 90       	pop	r0
    47d8:	cf 91       	pop	r28
    47da:	df 91       	pop	r29
    47dc:	08 95       	ret

000047de <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    47de:	df 93       	push	r29
    47e0:	cf 93       	push	r28
    47e2:	00 d0       	rcall	.+0      	; 0x47e4 <vTaskRemoveFromUnorderedEventList+0x6>
    47e4:	00 d0       	rcall	.+0      	; 0x47e6 <vTaskRemoveFromUnorderedEventList+0x8>
    47e6:	00 d0       	rcall	.+0      	; 0x47e8 <vTaskRemoveFromUnorderedEventList+0xa>
    47e8:	cd b7       	in	r28, 0x3d	; 61
    47ea:	de b7       	in	r29, 0x3e	; 62
    47ec:	9c 83       	std	Y+4, r25	; 0x04
    47ee:	8b 83       	std	Y+3, r24	; 0x03
    47f0:	7e 83       	std	Y+6, r23	; 0x06
    47f2:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    47f4:	8d 81       	ldd	r24, Y+5	; 0x05
    47f6:	9e 81       	ldd	r25, Y+6	; 0x06
    47f8:	90 68       	ori	r25, 0x80	; 128
    47fa:	eb 81       	ldd	r30, Y+3	; 0x03
    47fc:	fc 81       	ldd	r31, Y+4	; 0x04
    47fe:	91 83       	std	Z+1, r25	; 0x01
    4800:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4802:	eb 81       	ldd	r30, Y+3	; 0x03
    4804:	fc 81       	ldd	r31, Y+4	; 0x04
    4806:	86 81       	ldd	r24, Z+6	; 0x06
    4808:	97 81       	ldd	r25, Z+7	; 0x07
    480a:	9a 83       	std	Y+2, r25	; 0x02
    480c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    480e:	8b 81       	ldd	r24, Y+3	; 0x03
    4810:	9c 81       	ldd	r25, Y+4	; 0x04
    4812:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4816:	89 81       	ldd	r24, Y+1	; 0x01
    4818:	9a 81       	ldd	r25, Y+2	; 0x02
    481a:	02 96       	adiw	r24, 0x02	; 2
    481c:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4820:	e9 81       	ldd	r30, Y+1	; 0x01
    4822:	fa 81       	ldd	r31, Y+2	; 0x02
    4824:	96 89       	ldd	r25, Z+22	; 0x16
    4826:	80 91 c0 06 	lds	r24, 0x06C0
    482a:	89 17       	cp	r24, r25
    482c:	28 f4       	brcc	.+10     	; 0x4838 <vTaskRemoveFromUnorderedEventList+0x5a>
    482e:	e9 81       	ldd	r30, Y+1	; 0x01
    4830:	fa 81       	ldd	r31, Y+2	; 0x02
    4832:	86 89       	ldd	r24, Z+22	; 0x16
    4834:	80 93 c0 06 	sts	0x06C0, r24
    4838:	e9 81       	ldd	r30, Y+1	; 0x01
    483a:	fa 81       	ldd	r31, Y+2	; 0x02
    483c:	86 89       	ldd	r24, Z+22	; 0x16
    483e:	28 2f       	mov	r18, r24
    4840:	30 e0       	ldi	r19, 0x00	; 0
    4842:	c9 01       	movw	r24, r18
    4844:	88 0f       	add	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	88 0f       	add	r24, r24
    484e:	99 1f       	adc	r25, r25
    4850:	82 0f       	add	r24, r18
    4852:	93 1f       	adc	r25, r19
    4854:	ac 01       	movw	r20, r24
    4856:	45 53       	subi	r20, 0x35	; 53
    4858:	59 4f       	sbci	r21, 0xF9	; 249
    485a:	89 81       	ldd	r24, Y+1	; 0x01
    485c:	9a 81       	ldd	r25, Y+2	; 0x02
    485e:	9c 01       	movw	r18, r24
    4860:	2e 5f       	subi	r18, 0xFE	; 254
    4862:	3f 4f       	sbci	r19, 0xFF	; 255
    4864:	ca 01       	movw	r24, r20
    4866:	b9 01       	movw	r22, r18
    4868:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    486c:	e9 81       	ldd	r30, Y+1	; 0x01
    486e:	fa 81       	ldd	r31, Y+2	; 0x02
    4870:	96 89       	ldd	r25, Z+22	; 0x16
    4872:	e0 91 ba 06 	lds	r30, 0x06BA
    4876:	f0 91 bb 06 	lds	r31, 0x06BB
    487a:	86 89       	ldd	r24, Z+22	; 0x16
    487c:	89 17       	cp	r24, r25
    487e:	18 f4       	brcc	.+6      	; 0x4886 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4880:	81 e0       	ldi	r24, 0x01	; 1
    4882:	80 93 c3 06 	sts	0x06C3, r24
	}
}
    4886:	26 96       	adiw	r28, 0x06	; 6
    4888:	0f b6       	in	r0, 0x3f	; 63
    488a:	f8 94       	cli
    488c:	de bf       	out	0x3e, r29	; 62
    488e:	0f be       	out	0x3f, r0	; 63
    4890:	cd bf       	out	0x3d, r28	; 61
    4892:	cf 91       	pop	r28
    4894:	df 91       	pop	r29
    4896:	08 95       	ret

00004898 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4898:	df 93       	push	r29
    489a:	cf 93       	push	r28
    489c:	00 d0       	rcall	.+0      	; 0x489e <vTaskSetTimeOutState+0x6>
    489e:	cd b7       	in	r28, 0x3d	; 61
    48a0:	de b7       	in	r29, 0x3e	; 62
    48a2:	9a 83       	std	Y+2, r25	; 0x02
    48a4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    48a6:	0f b6       	in	r0, 0x3f	; 63
    48a8:	f8 94       	cli
    48aa:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    48ac:	80 91 c4 06 	lds	r24, 0x06C4
    48b0:	e9 81       	ldd	r30, Y+1	; 0x01
    48b2:	fa 81       	ldd	r31, Y+2	; 0x02
    48b4:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    48b6:	80 91 be 06 	lds	r24, 0x06BE
    48ba:	90 91 bf 06 	lds	r25, 0x06BF
    48be:	e9 81       	ldd	r30, Y+1	; 0x01
    48c0:	fa 81       	ldd	r31, Y+2	; 0x02
    48c2:	92 83       	std	Z+2, r25	; 0x02
    48c4:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    48c6:	0f 90       	pop	r0
    48c8:	0f be       	out	0x3f, r0	; 63
}
    48ca:	0f 90       	pop	r0
    48cc:	0f 90       	pop	r0
    48ce:	cf 91       	pop	r28
    48d0:	df 91       	pop	r29
    48d2:	08 95       	ret

000048d4 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    48d4:	df 93       	push	r29
    48d6:	cf 93       	push	r28
    48d8:	00 d0       	rcall	.+0      	; 0x48da <vTaskInternalSetTimeOutState+0x6>
    48da:	cd b7       	in	r28, 0x3d	; 61
    48dc:	de b7       	in	r29, 0x3e	; 62
    48de:	9a 83       	std	Y+2, r25	; 0x02
    48e0:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    48e2:	80 91 c4 06 	lds	r24, 0x06C4
    48e6:	e9 81       	ldd	r30, Y+1	; 0x01
    48e8:	fa 81       	ldd	r31, Y+2	; 0x02
    48ea:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    48ec:	80 91 be 06 	lds	r24, 0x06BE
    48f0:	90 91 bf 06 	lds	r25, 0x06BF
    48f4:	e9 81       	ldd	r30, Y+1	; 0x01
    48f6:	fa 81       	ldd	r31, Y+2	; 0x02
    48f8:	92 83       	std	Z+2, r25	; 0x02
    48fa:	81 83       	std	Z+1, r24	; 0x01
}
    48fc:	0f 90       	pop	r0
    48fe:	0f 90       	pop	r0
    4900:	cf 91       	pop	r28
    4902:	df 91       	pop	r29
    4904:	08 95       	ret

00004906 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4906:	df 93       	push	r29
    4908:	cf 93       	push	r28
    490a:	cd b7       	in	r28, 0x3d	; 61
    490c:	de b7       	in	r29, 0x3e	; 62
    490e:	29 97       	sbiw	r28, 0x09	; 9
    4910:	0f b6       	in	r0, 0x3f	; 63
    4912:	f8 94       	cli
    4914:	de bf       	out	0x3e, r29	; 62
    4916:	0f be       	out	0x3f, r0	; 63
    4918:	cd bf       	out	0x3d, r28	; 61
    491a:	9f 83       	std	Y+7, r25	; 0x07
    491c:	8e 83       	std	Y+6, r24	; 0x06
    491e:	79 87       	std	Y+9, r23	; 0x09
    4920:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4922:	0f b6       	in	r0, 0x3f	; 63
    4924:	f8 94       	cli
    4926:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4928:	80 91 be 06 	lds	r24, 0x06BE
    492c:	90 91 bf 06 	lds	r25, 0x06BF
    4930:	9c 83       	std	Y+4, r25	; 0x04
    4932:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4934:	ee 81       	ldd	r30, Y+6	; 0x06
    4936:	ff 81       	ldd	r31, Y+7	; 0x07
    4938:	21 81       	ldd	r18, Z+1	; 0x01
    493a:	32 81       	ldd	r19, Z+2	; 0x02
    493c:	8b 81       	ldd	r24, Y+3	; 0x03
    493e:	9c 81       	ldd	r25, Y+4	; 0x04
    4940:	82 1b       	sub	r24, r18
    4942:	93 0b       	sbc	r25, r19
    4944:	9a 83       	std	Y+2, r25	; 0x02
    4946:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4948:	e8 85       	ldd	r30, Y+8	; 0x08
    494a:	f9 85       	ldd	r31, Y+9	; 0x09
    494c:	80 81       	ld	r24, Z
    494e:	91 81       	ldd	r25, Z+1	; 0x01
    4950:	2f ef       	ldi	r18, 0xFF	; 255
    4952:	8f 3f       	cpi	r24, 0xFF	; 255
    4954:	92 07       	cpc	r25, r18
    4956:	11 f4       	brne	.+4      	; 0x495c <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4958:	1d 82       	std	Y+5, r1	; 0x05
    495a:	36 c0       	rjmp	.+108    	; 0x49c8 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    495c:	ee 81       	ldd	r30, Y+6	; 0x06
    495e:	ff 81       	ldd	r31, Y+7	; 0x07
    4960:	90 81       	ld	r25, Z
    4962:	80 91 c4 06 	lds	r24, 0x06C4
    4966:	98 17       	cp	r25, r24
    4968:	61 f0       	breq	.+24     	; 0x4982 <xTaskCheckForTimeOut+0x7c>
    496a:	ee 81       	ldd	r30, Y+6	; 0x06
    496c:	ff 81       	ldd	r31, Y+7	; 0x07
    496e:	21 81       	ldd	r18, Z+1	; 0x01
    4970:	32 81       	ldd	r19, Z+2	; 0x02
    4972:	8b 81       	ldd	r24, Y+3	; 0x03
    4974:	9c 81       	ldd	r25, Y+4	; 0x04
    4976:	82 17       	cp	r24, r18
    4978:	93 07       	cpc	r25, r19
    497a:	18 f0       	brcs	.+6      	; 0x4982 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    497c:	81 e0       	ldi	r24, 0x01	; 1
    497e:	8d 83       	std	Y+5, r24	; 0x05
    4980:	23 c0       	rjmp	.+70     	; 0x49c8 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4982:	e8 85       	ldd	r30, Y+8	; 0x08
    4984:	f9 85       	ldd	r31, Y+9	; 0x09
    4986:	20 81       	ld	r18, Z
    4988:	31 81       	ldd	r19, Z+1	; 0x01
    498a:	89 81       	ldd	r24, Y+1	; 0x01
    498c:	9a 81       	ldd	r25, Y+2	; 0x02
    498e:	82 17       	cp	r24, r18
    4990:	93 07       	cpc	r25, r19
    4992:	a0 f4       	brcc	.+40     	; 0x49bc <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4994:	e8 85       	ldd	r30, Y+8	; 0x08
    4996:	f9 85       	ldd	r31, Y+9	; 0x09
    4998:	20 81       	ld	r18, Z
    499a:	31 81       	ldd	r19, Z+1	; 0x01
    499c:	89 81       	ldd	r24, Y+1	; 0x01
    499e:	9a 81       	ldd	r25, Y+2	; 0x02
    49a0:	a9 01       	movw	r20, r18
    49a2:	48 1b       	sub	r20, r24
    49a4:	59 0b       	sbc	r21, r25
    49a6:	ca 01       	movw	r24, r20
    49a8:	e8 85       	ldd	r30, Y+8	; 0x08
    49aa:	f9 85       	ldd	r31, Y+9	; 0x09
    49ac:	91 83       	std	Z+1, r25	; 0x01
    49ae:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    49b0:	8e 81       	ldd	r24, Y+6	; 0x06
    49b2:	9f 81       	ldd	r25, Y+7	; 0x07
    49b4:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    49b8:	1d 82       	std	Y+5, r1	; 0x05
    49ba:	06 c0       	rjmp	.+12     	; 0x49c8 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    49bc:	e8 85       	ldd	r30, Y+8	; 0x08
    49be:	f9 85       	ldd	r31, Y+9	; 0x09
    49c0:	11 82       	std	Z+1, r1	; 0x01
    49c2:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    49c4:	81 e0       	ldi	r24, 0x01	; 1
    49c6:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    49c8:	0f 90       	pop	r0
    49ca:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    49cc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    49ce:	29 96       	adiw	r28, 0x09	; 9
    49d0:	0f b6       	in	r0, 0x3f	; 63
    49d2:	f8 94       	cli
    49d4:	de bf       	out	0x3e, r29	; 62
    49d6:	0f be       	out	0x3f, r0	; 63
    49d8:	cd bf       	out	0x3d, r28	; 61
    49da:	cf 91       	pop	r28
    49dc:	df 91       	pop	r29
    49de:	08 95       	ret

000049e0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    49e0:	df 93       	push	r29
    49e2:	cf 93       	push	r28
    49e4:	cd b7       	in	r28, 0x3d	; 61
    49e6:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    49e8:	81 e0       	ldi	r24, 0x01	; 1
    49ea:	80 93 c3 06 	sts	0x06C3, r24
}
    49ee:	cf 91       	pop	r28
    49f0:	df 91       	pop	r29
    49f2:	08 95       	ret

000049f4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    49f4:	df 93       	push	r29
    49f6:	cf 93       	push	r28
    49f8:	00 d0       	rcall	.+0      	; 0x49fa <prvIdleTask+0x6>
    49fa:	cd b7       	in	r28, 0x3d	; 61
    49fc:	de b7       	in	r29, 0x3e	; 62
    49fe:	9a 83       	std	Y+2, r25	; 0x02
    4a00:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4a02:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <prvCheckTasksWaitingTermination>
    4a06:	fd cf       	rjmp	.-6      	; 0x4a02 <prvIdleTask+0xe>

00004a08 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4a08:	df 93       	push	r29
    4a0a:	cf 93       	push	r28
    4a0c:	0f 92       	push	r0
    4a0e:	cd b7       	in	r28, 0x3d	; 61
    4a10:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a12:	19 82       	std	Y+1, r1	; 0x01
    4a14:	13 c0       	rjmp	.+38     	; 0x4a3c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4a16:	89 81       	ldd	r24, Y+1	; 0x01
    4a18:	28 2f       	mov	r18, r24
    4a1a:	30 e0       	ldi	r19, 0x00	; 0
    4a1c:	c9 01       	movw	r24, r18
    4a1e:	88 0f       	add	r24, r24
    4a20:	99 1f       	adc	r25, r25
    4a22:	88 0f       	add	r24, r24
    4a24:	99 1f       	adc	r25, r25
    4a26:	88 0f       	add	r24, r24
    4a28:	99 1f       	adc	r25, r25
    4a2a:	82 0f       	add	r24, r18
    4a2c:	93 1f       	adc	r25, r19
    4a2e:	85 53       	subi	r24, 0x35	; 53
    4a30:	99 4f       	sbci	r25, 0xF9	; 249
    4a32:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a36:	89 81       	ldd	r24, Y+1	; 0x01
    4a38:	8f 5f       	subi	r24, 0xFF	; 255
    4a3a:	89 83       	std	Y+1, r24	; 0x01
    4a3c:	89 81       	ldd	r24, Y+1	; 0x01
    4a3e:	85 30       	cpi	r24, 0x05	; 5
    4a40:	50 f3       	brcs	.-44     	; 0x4a16 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4a42:	88 ef       	ldi	r24, 0xF8	; 248
    4a44:	96 e0       	ldi	r25, 0x06	; 6
    4a46:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4a4a:	81 e0       	ldi	r24, 0x01	; 1
    4a4c:	97 e0       	ldi	r25, 0x07	; 7
    4a4e:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4a52:	8e e0       	ldi	r24, 0x0E	; 14
    4a54:	97 e0       	ldi	r25, 0x07	; 7
    4a56:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4a5a:	87 e1       	ldi	r24, 0x17	; 23
    4a5c:	97 e0       	ldi	r25, 0x07	; 7
    4a5e:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4a62:	80 e2       	ldi	r24, 0x20	; 32
    4a64:	97 e0       	ldi	r25, 0x07	; 7
    4a66:	0e 94 20 0a 	call	0x1440	; 0x1440 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4a6a:	88 ef       	ldi	r24, 0xF8	; 248
    4a6c:	96 e0       	ldi	r25, 0x06	; 6
    4a6e:	90 93 0b 07 	sts	0x070B, r25
    4a72:	80 93 0a 07 	sts	0x070A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4a76:	81 e0       	ldi	r24, 0x01	; 1
    4a78:	97 e0       	ldi	r25, 0x07	; 7
    4a7a:	90 93 0d 07 	sts	0x070D, r25
    4a7e:	80 93 0c 07 	sts	0x070C, r24
}
    4a82:	0f 90       	pop	r0
    4a84:	cf 91       	pop	r28
    4a86:	df 91       	pop	r29
    4a88:	08 95       	ret

00004a8a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4a8a:	df 93       	push	r29
    4a8c:	cf 93       	push	r28
    4a8e:	00 d0       	rcall	.+0      	; 0x4a90 <prvCheckTasksWaitingTermination+0x6>
    4a90:	cd b7       	in	r28, 0x3d	; 61
    4a92:	de b7       	in	r29, 0x3e	; 62
    4a94:	20 c0       	rjmp	.+64     	; 0x4ad6 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4a96:	0f b6       	in	r0, 0x3f	; 63
    4a98:	f8 94       	cli
    4a9a:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a9c:	e0 91 1c 07 	lds	r30, 0x071C
    4aa0:	f0 91 1d 07 	lds	r31, 0x071D
    4aa4:	86 81       	ldd	r24, Z+6	; 0x06
    4aa6:	97 81       	ldd	r25, Z+7	; 0x07
    4aa8:	9a 83       	std	Y+2, r25	; 0x02
    4aaa:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4aac:	89 81       	ldd	r24, Y+1	; 0x01
    4aae:	9a 81       	ldd	r25, Y+2	; 0x02
    4ab0:	02 96       	adiw	r24, 0x02	; 2
    4ab2:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4ab6:	80 91 bd 06 	lds	r24, 0x06BD
    4aba:	81 50       	subi	r24, 0x01	; 1
    4abc:	80 93 bd 06 	sts	0x06BD, r24
				--uxDeletedTasksWaitingCleanUp;
    4ac0:	80 91 bc 06 	lds	r24, 0x06BC
    4ac4:	81 50       	subi	r24, 0x01	; 1
    4ac6:	80 93 bc 06 	sts	0x06BC, r24
			}
			taskEXIT_CRITICAL();
    4aca:	0f 90       	pop	r0
    4acc:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4ace:	89 81       	ldd	r24, Y+1	; 0x01
    4ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ad2:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4ad6:	80 91 bc 06 	lds	r24, 0x06BC
    4ada:	88 23       	and	r24, r24
    4adc:	e1 f6       	brne	.-72     	; 0x4a96 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4ade:	0f 90       	pop	r0
    4ae0:	0f 90       	pop	r0
    4ae2:	cf 91       	pop	r28
    4ae4:	df 91       	pop	r29
    4ae6:	08 95       	ret

00004ae8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4ae8:	df 93       	push	r29
    4aea:	cf 93       	push	r28
    4aec:	00 d0       	rcall	.+0      	; 0x4aee <prvDeleteTCB+0x6>
    4aee:	cd b7       	in	r28, 0x3d	; 61
    4af0:	de b7       	in	r29, 0x3e	; 62
    4af2:	9a 83       	std	Y+2, r25	; 0x02
    4af4:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4af6:	e9 81       	ldd	r30, Y+1	; 0x01
    4af8:	fa 81       	ldd	r31, Y+2	; 0x02
    4afa:	87 89       	ldd	r24, Z+23	; 0x17
    4afc:	90 8d       	ldd	r25, Z+24	; 0x18
    4afe:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vPortFree>
			vPortFree( pxTCB );
    4b02:	89 81       	ldd	r24, Y+1	; 0x01
    4b04:	9a 81       	ldd	r25, Y+2	; 0x02
    4b06:	0e 94 71 08 	call	0x10e2	; 0x10e2 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4b0a:	0f 90       	pop	r0
    4b0c:	0f 90       	pop	r0
    4b0e:	cf 91       	pop	r28
    4b10:	df 91       	pop	r29
    4b12:	08 95       	ret

00004b14 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4b14:	df 93       	push	r29
    4b16:	cf 93       	push	r28
    4b18:	00 d0       	rcall	.+0      	; 0x4b1a <prvResetNextTaskUnblockTime+0x6>
    4b1a:	cd b7       	in	r28, 0x3d	; 61
    4b1c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4b1e:	e0 91 0a 07 	lds	r30, 0x070A
    4b22:	f0 91 0b 07 	lds	r31, 0x070B
    4b26:	80 81       	ld	r24, Z
    4b28:	88 23       	and	r24, r24
    4b2a:	39 f4       	brne	.+14     	; 0x4b3a <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4b2c:	8f ef       	ldi	r24, 0xFF	; 255
    4b2e:	9f ef       	ldi	r25, 0xFF	; 255
    4b30:	90 93 c7 06 	sts	0x06C7, r25
    4b34:	80 93 c6 06 	sts	0x06C6, r24
    4b38:	13 c0       	rjmp	.+38     	; 0x4b60 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b3a:	e0 91 0a 07 	lds	r30, 0x070A
    4b3e:	f0 91 0b 07 	lds	r31, 0x070B
    4b42:	05 80       	ldd	r0, Z+5	; 0x05
    4b44:	f6 81       	ldd	r31, Z+6	; 0x06
    4b46:	e0 2d       	mov	r30, r0
    4b48:	86 81       	ldd	r24, Z+6	; 0x06
    4b4a:	97 81       	ldd	r25, Z+7	; 0x07
    4b4c:	9a 83       	std	Y+2, r25	; 0x02
    4b4e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4b50:	e9 81       	ldd	r30, Y+1	; 0x01
    4b52:	fa 81       	ldd	r31, Y+2	; 0x02
    4b54:	82 81       	ldd	r24, Z+2	; 0x02
    4b56:	93 81       	ldd	r25, Z+3	; 0x03
    4b58:	90 93 c7 06 	sts	0x06C7, r25
    4b5c:	80 93 c6 06 	sts	0x06C6, r24
	}
}
    4b60:	0f 90       	pop	r0
    4b62:	0f 90       	pop	r0
    4b64:	cf 91       	pop	r28
    4b66:	df 91       	pop	r29
    4b68:	08 95       	ret

00004b6a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4b6a:	df 93       	push	r29
    4b6c:	cf 93       	push	r28
    4b6e:	00 d0       	rcall	.+0      	; 0x4b70 <xTaskGetCurrentTaskHandle+0x6>
    4b70:	cd b7       	in	r28, 0x3d	; 61
    4b72:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4b74:	80 91 ba 06 	lds	r24, 0x06BA
    4b78:	90 91 bb 06 	lds	r25, 0x06BB
    4b7c:	9a 83       	std	Y+2, r25	; 0x02
    4b7e:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4b80:	89 81       	ldd	r24, Y+1	; 0x01
    4b82:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4b84:	0f 90       	pop	r0
    4b86:	0f 90       	pop	r0
    4b88:	cf 91       	pop	r28
    4b8a:	df 91       	pop	r29
    4b8c:	08 95       	ret

00004b8e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4b8e:	df 93       	push	r29
    4b90:	cf 93       	push	r28
    4b92:	00 d0       	rcall	.+0      	; 0x4b94 <uxTaskResetEventItemValue+0x6>
    4b94:	cd b7       	in	r28, 0x3d	; 61
    4b96:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4b98:	e0 91 ba 06 	lds	r30, 0x06BA
    4b9c:	f0 91 bb 06 	lds	r31, 0x06BB
    4ba0:	84 85       	ldd	r24, Z+12	; 0x0c
    4ba2:	95 85       	ldd	r25, Z+13	; 0x0d
    4ba4:	9a 83       	std	Y+2, r25	; 0x02
    4ba6:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ba8:	a0 91 ba 06 	lds	r26, 0x06BA
    4bac:	b0 91 bb 06 	lds	r27, 0x06BB
    4bb0:	e0 91 ba 06 	lds	r30, 0x06BA
    4bb4:	f0 91 bb 06 	lds	r31, 0x06BB
    4bb8:	86 89       	ldd	r24, Z+22	; 0x16
    4bba:	28 2f       	mov	r18, r24
    4bbc:	30 e0       	ldi	r19, 0x00	; 0
    4bbe:	85 e0       	ldi	r24, 0x05	; 5
    4bc0:	90 e0       	ldi	r25, 0x00	; 0
    4bc2:	82 1b       	sub	r24, r18
    4bc4:	93 0b       	sbc	r25, r19
    4bc6:	1d 96       	adiw	r26, 0x0d	; 13
    4bc8:	9c 93       	st	X, r25
    4bca:	8e 93       	st	-X, r24
    4bcc:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4bce:	89 81       	ldd	r24, Y+1	; 0x01
    4bd0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4bd2:	0f 90       	pop	r0
    4bd4:	0f 90       	pop	r0
    4bd6:	cf 91       	pop	r28
    4bd8:	df 91       	pop	r29
    4bda:	08 95       	ret

00004bdc <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4bdc:	df 93       	push	r29
    4bde:	cf 93       	push	r28
    4be0:	cd b7       	in	r28, 0x3d	; 61
    4be2:	de b7       	in	r29, 0x3e	; 62
    4be4:	27 97       	sbiw	r28, 0x07	; 7
    4be6:	0f b6       	in	r0, 0x3f	; 63
    4be8:	f8 94       	cli
    4bea:	de bf       	out	0x3e, r29	; 62
    4bec:	0f be       	out	0x3f, r0	; 63
    4bee:	cd bf       	out	0x3d, r28	; 61
    4bf0:	8d 83       	std	Y+5, r24	; 0x05
    4bf2:	7f 83       	std	Y+7, r23	; 0x07
    4bf4:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4bf6:	0f b6       	in	r0, 0x3f	; 63
    4bf8:	f8 94       	cli
    4bfa:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4bfc:	e0 91 ba 06 	lds	r30, 0x06BA
    4c00:	f0 91 bb 06 	lds	r31, 0x06BB
    4c04:	85 a5       	ldd	r24, Z+45	; 0x2d
    4c06:	96 a5       	ldd	r25, Z+46	; 0x2e
    4c08:	a7 a5       	ldd	r26, Z+47	; 0x2f
    4c0a:	b0 a9       	ldd	r27, Z+48	; 0x30
    4c0c:	00 97       	sbiw	r24, 0x00	; 0
    4c0e:	a1 05       	cpc	r26, r1
    4c10:	b1 05       	cpc	r27, r1
    4c12:	89 f4       	brne	.+34     	; 0x4c36 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c14:	e0 91 ba 06 	lds	r30, 0x06BA
    4c18:	f0 91 bb 06 	lds	r31, 0x06BB
    4c1c:	81 e0       	ldi	r24, 0x01	; 1
    4c1e:	81 ab       	std	Z+49, r24	; 0x31

				if( xTicksToWait > ( TickType_t ) 0 )
    4c20:	8e 81       	ldd	r24, Y+6	; 0x06
    4c22:	9f 81       	ldd	r25, Y+7	; 0x07
    4c24:	00 97       	sbiw	r24, 0x00	; 0
    4c26:	39 f0       	breq	.+14     	; 0x4c36 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4c28:	8e 81       	ldd	r24, Y+6	; 0x06
    4c2a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c2c:	61 e0       	ldi	r22, 0x01	; 1
    4c2e:	0e 94 96 29 	call	0x532c	; 0x532c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4c32:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4c36:	0f 90       	pop	r0
    4c38:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4c3a:	0f b6       	in	r0, 0x3f	; 63
    4c3c:	f8 94       	cli
    4c3e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4c40:	e0 91 ba 06 	lds	r30, 0x06BA
    4c44:	f0 91 bb 06 	lds	r31, 0x06BB
    4c48:	85 a5       	ldd	r24, Z+45	; 0x2d
    4c4a:	96 a5       	ldd	r25, Z+46	; 0x2e
    4c4c:	a7 a5       	ldd	r26, Z+47	; 0x2f
    4c4e:	b0 a9       	ldd	r27, Z+48	; 0x30
    4c50:	89 83       	std	Y+1, r24	; 0x01
    4c52:	9a 83       	std	Y+2, r25	; 0x02
    4c54:	ab 83       	std	Y+3, r26	; 0x03
    4c56:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    4c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c5c:	ab 81       	ldd	r26, Y+3	; 0x03
    4c5e:	bc 81       	ldd	r27, Y+4	; 0x04
    4c60:	00 97       	sbiw	r24, 0x00	; 0
    4c62:	a1 05       	cpc	r26, r1
    4c64:	b1 05       	cpc	r27, r1
    4c66:	d9 f0       	breq	.+54     	; 0x4c9e <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4c68:	8d 81       	ldd	r24, Y+5	; 0x05
    4c6a:	88 23       	and	r24, r24
    4c6c:	49 f0       	breq	.+18     	; 0x4c80 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4c6e:	e0 91 ba 06 	lds	r30, 0x06BA
    4c72:	f0 91 bb 06 	lds	r31, 0x06BB
    4c76:	15 a6       	std	Z+45, r1	; 0x2d
    4c78:	16 a6       	std	Z+46, r1	; 0x2e
    4c7a:	17 a6       	std	Z+47, r1	; 0x2f
    4c7c:	10 aa       	std	Z+48, r1	; 0x30
    4c7e:	0f c0       	rjmp	.+30     	; 0x4c9e <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4c80:	e0 91 ba 06 	lds	r30, 0x06BA
    4c84:	f0 91 bb 06 	lds	r31, 0x06BB
    4c88:	89 81       	ldd	r24, Y+1	; 0x01
    4c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c8c:	ab 81       	ldd	r26, Y+3	; 0x03
    4c8e:	bc 81       	ldd	r27, Y+4	; 0x04
    4c90:	01 97       	sbiw	r24, 0x01	; 1
    4c92:	a1 09       	sbc	r26, r1
    4c94:	b1 09       	sbc	r27, r1
    4c96:	85 a7       	std	Z+45, r24	; 0x2d
    4c98:	96 a7       	std	Z+46, r25	; 0x2e
    4c9a:	a7 a7       	std	Z+47, r26	; 0x2f
    4c9c:	b0 ab       	std	Z+48, r27	; 0x30
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4c9e:	e0 91 ba 06 	lds	r30, 0x06BA
    4ca2:	f0 91 bb 06 	lds	r31, 0x06BB
    4ca6:	11 aa       	std	Z+49, r1	; 0x31
		}
		taskEXIT_CRITICAL();
    4ca8:	0f 90       	pop	r0
    4caa:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4cac:	89 81       	ldd	r24, Y+1	; 0x01
    4cae:	9a 81       	ldd	r25, Y+2	; 0x02
    4cb0:	ab 81       	ldd	r26, Y+3	; 0x03
    4cb2:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4cb4:	bc 01       	movw	r22, r24
    4cb6:	cd 01       	movw	r24, r26
    4cb8:	27 96       	adiw	r28, 0x07	; 7
    4cba:	0f b6       	in	r0, 0x3f	; 63
    4cbc:	f8 94       	cli
    4cbe:	de bf       	out	0x3e, r29	; 62
    4cc0:	0f be       	out	0x3f, r0	; 63
    4cc2:	cd bf       	out	0x3d, r28	; 61
    4cc4:	cf 91       	pop	r28
    4cc6:	df 91       	pop	r29
    4cc8:	08 95       	ret

00004cca <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4cca:	ef 92       	push	r14
    4ccc:	ff 92       	push	r15
    4cce:	0f 93       	push	r16
    4cd0:	1f 93       	push	r17
    4cd2:	df 93       	push	r29
    4cd4:	cf 93       	push	r28
    4cd6:	cd b7       	in	r28, 0x3d	; 61
    4cd8:	de b7       	in	r29, 0x3e	; 62
    4cda:	2d 97       	sbiw	r28, 0x0d	; 13
    4cdc:	0f b6       	in	r0, 0x3f	; 63
    4cde:	f8 94       	cli
    4ce0:	de bf       	out	0x3e, r29	; 62
    4ce2:	0f be       	out	0x3f, r0	; 63
    4ce4:	cd bf       	out	0x3d, r28	; 61
    4ce6:	6a 83       	std	Y+2, r22	; 0x02
    4ce8:	7b 83       	std	Y+3, r23	; 0x03
    4cea:	8c 83       	std	Y+4, r24	; 0x04
    4cec:	9d 83       	std	Y+5, r25	; 0x05
    4cee:	2e 83       	std	Y+6, r18	; 0x06
    4cf0:	3f 83       	std	Y+7, r19	; 0x07
    4cf2:	48 87       	std	Y+8, r20	; 0x08
    4cf4:	59 87       	std	Y+9, r21	; 0x09
    4cf6:	1b 87       	std	Y+11, r17	; 0x0b
    4cf8:	0a 87       	std	Y+10, r16	; 0x0a
    4cfa:	fd 86       	std	Y+13, r15	; 0x0d
    4cfc:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4cfe:	0f b6       	in	r0, 0x3f	; 63
    4d00:	f8 94       	cli
    4d02:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4d04:	e0 91 ba 06 	lds	r30, 0x06BA
    4d08:	f0 91 bb 06 	lds	r31, 0x06BB
    4d0c:	81 a9       	ldd	r24, Z+49	; 0x31
    4d0e:	82 30       	cpi	r24, 0x02	; 2
    4d10:	49 f1       	breq	.+82     	; 0x4d64 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4d12:	e0 91 ba 06 	lds	r30, 0x06BA
    4d16:	f0 91 bb 06 	lds	r31, 0x06BB
    4d1a:	25 a5       	ldd	r18, Z+45	; 0x2d
    4d1c:	36 a5       	ldd	r19, Z+46	; 0x2e
    4d1e:	47 a5       	ldd	r20, Z+47	; 0x2f
    4d20:	50 a9       	ldd	r21, Z+48	; 0x30
    4d22:	8a 81       	ldd	r24, Y+2	; 0x02
    4d24:	9b 81       	ldd	r25, Y+3	; 0x03
    4d26:	ac 81       	ldd	r26, Y+4	; 0x04
    4d28:	bd 81       	ldd	r27, Y+5	; 0x05
    4d2a:	80 95       	com	r24
    4d2c:	90 95       	com	r25
    4d2e:	a0 95       	com	r26
    4d30:	b0 95       	com	r27
    4d32:	82 23       	and	r24, r18
    4d34:	93 23       	and	r25, r19
    4d36:	a4 23       	and	r26, r20
    4d38:	b5 23       	and	r27, r21
    4d3a:	85 a7       	std	Z+45, r24	; 0x2d
    4d3c:	96 a7       	std	Z+46, r25	; 0x2e
    4d3e:	a7 a7       	std	Z+47, r26	; 0x2f
    4d40:	b0 ab       	std	Z+48, r27	; 0x30

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4d42:	e0 91 ba 06 	lds	r30, 0x06BA
    4d46:	f0 91 bb 06 	lds	r31, 0x06BB
    4d4a:	81 e0       	ldi	r24, 0x01	; 1
    4d4c:	81 ab       	std	Z+49, r24	; 0x31

				if( xTicksToWait > ( TickType_t ) 0 )
    4d4e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d50:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d52:	00 97       	sbiw	r24, 0x00	; 0
    4d54:	39 f0       	breq	.+14     	; 0x4d64 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4d56:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d58:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d5a:	61 e0       	ldi	r22, 0x01	; 1
    4d5c:	0e 94 96 29 	call	0x532c	; 0x532c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4d60:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4d64:	0f 90       	pop	r0
    4d66:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4d68:	0f b6       	in	r0, 0x3f	; 63
    4d6a:	f8 94       	cli
    4d6c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4d6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d70:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d72:	00 97       	sbiw	r24, 0x00	; 0
    4d74:	71 f0       	breq	.+28     	; 0x4d92 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4d76:	e0 91 ba 06 	lds	r30, 0x06BA
    4d7a:	f0 91 bb 06 	lds	r31, 0x06BB
    4d7e:	85 a5       	ldd	r24, Z+45	; 0x2d
    4d80:	96 a5       	ldd	r25, Z+46	; 0x2e
    4d82:	a7 a5       	ldd	r26, Z+47	; 0x2f
    4d84:	b0 a9       	ldd	r27, Z+48	; 0x30
    4d86:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d88:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d8a:	80 83       	st	Z, r24
    4d8c:	91 83       	std	Z+1, r25	; 0x01
    4d8e:	a2 83       	std	Z+2, r26	; 0x02
    4d90:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4d92:	e0 91 ba 06 	lds	r30, 0x06BA
    4d96:	f0 91 bb 06 	lds	r31, 0x06BB
    4d9a:	81 a9       	ldd	r24, Z+49	; 0x31
    4d9c:	82 30       	cpi	r24, 0x02	; 2
    4d9e:	11 f0       	breq	.+4      	; 0x4da4 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4da0:	19 82       	std	Y+1, r1	; 0x01
    4da2:	1a c0       	rjmp	.+52     	; 0x4dd8 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4da4:	e0 91 ba 06 	lds	r30, 0x06BA
    4da8:	f0 91 bb 06 	lds	r31, 0x06BB
    4dac:	25 a5       	ldd	r18, Z+45	; 0x2d
    4dae:	36 a5       	ldd	r19, Z+46	; 0x2e
    4db0:	47 a5       	ldd	r20, Z+47	; 0x2f
    4db2:	50 a9       	ldd	r21, Z+48	; 0x30
    4db4:	8e 81       	ldd	r24, Y+6	; 0x06
    4db6:	9f 81       	ldd	r25, Y+7	; 0x07
    4db8:	a8 85       	ldd	r26, Y+8	; 0x08
    4dba:	b9 85       	ldd	r27, Y+9	; 0x09
    4dbc:	80 95       	com	r24
    4dbe:	90 95       	com	r25
    4dc0:	a0 95       	com	r26
    4dc2:	b0 95       	com	r27
    4dc4:	82 23       	and	r24, r18
    4dc6:	93 23       	and	r25, r19
    4dc8:	a4 23       	and	r26, r20
    4dca:	b5 23       	and	r27, r21
    4dcc:	85 a7       	std	Z+45, r24	; 0x2d
    4dce:	96 a7       	std	Z+46, r25	; 0x2e
    4dd0:	a7 a7       	std	Z+47, r26	; 0x2f
    4dd2:	b0 ab       	std	Z+48, r27	; 0x30
				xReturn = pdTRUE;
    4dd4:	81 e0       	ldi	r24, 0x01	; 1
    4dd6:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4dd8:	e0 91 ba 06 	lds	r30, 0x06BA
    4ddc:	f0 91 bb 06 	lds	r31, 0x06BB
    4de0:	11 aa       	std	Z+49, r1	; 0x31
		}
		taskEXIT_CRITICAL();
    4de2:	0f 90       	pop	r0
    4de4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4de6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4de8:	2d 96       	adiw	r28, 0x0d	; 13
    4dea:	0f b6       	in	r0, 0x3f	; 63
    4dec:	f8 94       	cli
    4dee:	de bf       	out	0x3e, r29	; 62
    4df0:	0f be       	out	0x3f, r0	; 63
    4df2:	cd bf       	out	0x3d, r28	; 61
    4df4:	cf 91       	pop	r28
    4df6:	df 91       	pop	r29
    4df8:	1f 91       	pop	r17
    4dfa:	0f 91       	pop	r16
    4dfc:	ff 90       	pop	r15
    4dfe:	ef 90       	pop	r14
    4e00:	08 95       	ret

00004e02 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4e02:	0f 93       	push	r16
    4e04:	1f 93       	push	r17
    4e06:	df 93       	push	r29
    4e08:	cf 93       	push	r28
    4e0a:	cd b7       	in	r28, 0x3d	; 61
    4e0c:	de b7       	in	r29, 0x3e	; 62
    4e0e:	2f 97       	sbiw	r28, 0x0f	; 15
    4e10:	0f b6       	in	r0, 0x3f	; 63
    4e12:	f8 94       	cli
    4e14:	de bf       	out	0x3e, r29	; 62
    4e16:	0f be       	out	0x3f, r0	; 63
    4e18:	cd bf       	out	0x3d, r28	; 61
    4e1a:	9e 83       	std	Y+6, r25	; 0x06
    4e1c:	8d 83       	std	Y+5, r24	; 0x05
    4e1e:	4f 83       	std	Y+7, r20	; 0x07
    4e20:	58 87       	std	Y+8, r21	; 0x08
    4e22:	69 87       	std	Y+9, r22	; 0x09
    4e24:	7a 87       	std	Y+10, r23	; 0x0a
    4e26:	2b 87       	std	Y+11, r18	; 0x0b
    4e28:	1d 87       	std	Y+13, r17	; 0x0d
    4e2a:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4e2c:	81 e0       	ldi	r24, 0x01	; 1
    4e2e:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4e30:	8d 81       	ldd	r24, Y+5	; 0x05
    4e32:	9e 81       	ldd	r25, Y+6	; 0x06
    4e34:	9c 83       	std	Y+4, r25	; 0x04
    4e36:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4e38:	0f b6       	in	r0, 0x3f	; 63
    4e3a:	f8 94       	cli
    4e3c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4e3e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4e40:	9d 85       	ldd	r25, Y+13	; 0x0d
    4e42:	00 97       	sbiw	r24, 0x00	; 0
    4e44:	61 f0       	breq	.+24     	; 0x4e5e <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4e46:	eb 81       	ldd	r30, Y+3	; 0x03
    4e48:	fc 81       	ldd	r31, Y+4	; 0x04
    4e4a:	85 a5       	ldd	r24, Z+45	; 0x2d
    4e4c:	96 a5       	ldd	r25, Z+46	; 0x2e
    4e4e:	a7 a5       	ldd	r26, Z+47	; 0x2f
    4e50:	b0 a9       	ldd	r27, Z+48	; 0x30
    4e52:	ec 85       	ldd	r30, Y+12	; 0x0c
    4e54:	fd 85       	ldd	r31, Y+13	; 0x0d
    4e56:	80 83       	st	Z, r24
    4e58:	91 83       	std	Z+1, r25	; 0x01
    4e5a:	a2 83       	std	Z+2, r26	; 0x02
    4e5c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4e5e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e60:	fc 81       	ldd	r31, Y+4	; 0x04
    4e62:	81 a9       	ldd	r24, Z+49	; 0x31
    4e64:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4e66:	eb 81       	ldd	r30, Y+3	; 0x03
    4e68:	fc 81       	ldd	r31, Y+4	; 0x04
    4e6a:	82 e0       	ldi	r24, 0x02	; 2
    4e6c:	81 ab       	std	Z+49, r24	; 0x31

			switch( eAction )
    4e6e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4e70:	28 2f       	mov	r18, r24
    4e72:	30 e0       	ldi	r19, 0x00	; 0
    4e74:	3f 87       	std	Y+15, r19	; 0x0f
    4e76:	2e 87       	std	Y+14, r18	; 0x0e
    4e78:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e7a:	9f 85       	ldd	r25, Y+15	; 0x0f
    4e7c:	82 30       	cpi	r24, 0x02	; 2
    4e7e:	91 05       	cpc	r25, r1
    4e80:	59 f1       	breq	.+86     	; 0x4ed8 <xTaskGenericNotify+0xd6>
    4e82:	2e 85       	ldd	r18, Y+14	; 0x0e
    4e84:	3f 85       	ldd	r19, Y+15	; 0x0f
    4e86:	23 30       	cpi	r18, 0x03	; 3
    4e88:	31 05       	cpc	r19, r1
    4e8a:	34 f4       	brge	.+12     	; 0x4e98 <xTaskGenericNotify+0x96>
    4e8c:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e8e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4e90:	81 30       	cpi	r24, 0x01	; 1
    4e92:	91 05       	cpc	r25, r1
    4e94:	61 f0       	breq	.+24     	; 0x4eae <xTaskGenericNotify+0xac>
    4e96:	4a c0       	rjmp	.+148    	; 0x4f2c <xTaskGenericNotify+0x12a>
    4e98:	2e 85       	ldd	r18, Y+14	; 0x0e
    4e9a:	3f 85       	ldd	r19, Y+15	; 0x0f
    4e9c:	23 30       	cpi	r18, 0x03	; 3
    4e9e:	31 05       	cpc	r19, r1
    4ea0:	59 f1       	breq	.+86     	; 0x4ef8 <xTaskGenericNotify+0xf6>
    4ea2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ea4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ea6:	84 30       	cpi	r24, 0x04	; 4
    4ea8:	91 05       	cpc	r25, r1
    4eaa:	89 f1       	breq	.+98     	; 0x4f0e <xTaskGenericNotify+0x10c>
    4eac:	3f c0       	rjmp	.+126    	; 0x4f2c <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4eae:	eb 81       	ldd	r30, Y+3	; 0x03
    4eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    4eb2:	25 a5       	ldd	r18, Z+45	; 0x2d
    4eb4:	36 a5       	ldd	r19, Z+46	; 0x2e
    4eb6:	47 a5       	ldd	r20, Z+47	; 0x2f
    4eb8:	50 a9       	ldd	r21, Z+48	; 0x30
    4eba:	8f 81       	ldd	r24, Y+7	; 0x07
    4ebc:	98 85       	ldd	r25, Y+8	; 0x08
    4ebe:	a9 85       	ldd	r26, Y+9	; 0x09
    4ec0:	ba 85       	ldd	r27, Y+10	; 0x0a
    4ec2:	82 2b       	or	r24, r18
    4ec4:	93 2b       	or	r25, r19
    4ec6:	a4 2b       	or	r26, r20
    4ec8:	b5 2b       	or	r27, r21
    4eca:	eb 81       	ldd	r30, Y+3	; 0x03
    4ecc:	fc 81       	ldd	r31, Y+4	; 0x04
    4ece:	85 a7       	std	Z+45, r24	; 0x2d
    4ed0:	96 a7       	std	Z+46, r25	; 0x2e
    4ed2:	a7 a7       	std	Z+47, r26	; 0x2f
    4ed4:	b0 ab       	std	Z+48, r27	; 0x30
    4ed6:	2a c0       	rjmp	.+84     	; 0x4f2c <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4ed8:	eb 81       	ldd	r30, Y+3	; 0x03
    4eda:	fc 81       	ldd	r31, Y+4	; 0x04
    4edc:	85 a5       	ldd	r24, Z+45	; 0x2d
    4ede:	96 a5       	ldd	r25, Z+46	; 0x2e
    4ee0:	a7 a5       	ldd	r26, Z+47	; 0x2f
    4ee2:	b0 a9       	ldd	r27, Z+48	; 0x30
    4ee4:	01 96       	adiw	r24, 0x01	; 1
    4ee6:	a1 1d       	adc	r26, r1
    4ee8:	b1 1d       	adc	r27, r1
    4eea:	eb 81       	ldd	r30, Y+3	; 0x03
    4eec:	fc 81       	ldd	r31, Y+4	; 0x04
    4eee:	85 a7       	std	Z+45, r24	; 0x2d
    4ef0:	96 a7       	std	Z+46, r25	; 0x2e
    4ef2:	a7 a7       	std	Z+47, r26	; 0x2f
    4ef4:	b0 ab       	std	Z+48, r27	; 0x30
    4ef6:	1a c0       	rjmp	.+52     	; 0x4f2c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4ef8:	eb 81       	ldd	r30, Y+3	; 0x03
    4efa:	fc 81       	ldd	r31, Y+4	; 0x04
    4efc:	8f 81       	ldd	r24, Y+7	; 0x07
    4efe:	98 85       	ldd	r25, Y+8	; 0x08
    4f00:	a9 85       	ldd	r26, Y+9	; 0x09
    4f02:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f04:	85 a7       	std	Z+45, r24	; 0x2d
    4f06:	96 a7       	std	Z+46, r25	; 0x2e
    4f08:	a7 a7       	std	Z+47, r26	; 0x2f
    4f0a:	b0 ab       	std	Z+48, r27	; 0x30
    4f0c:	0f c0       	rjmp	.+30     	; 0x4f2c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4f0e:	89 81       	ldd	r24, Y+1	; 0x01
    4f10:	82 30       	cpi	r24, 0x02	; 2
    4f12:	59 f0       	breq	.+22     	; 0x4f2a <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4f14:	eb 81       	ldd	r30, Y+3	; 0x03
    4f16:	fc 81       	ldd	r31, Y+4	; 0x04
    4f18:	8f 81       	ldd	r24, Y+7	; 0x07
    4f1a:	98 85       	ldd	r25, Y+8	; 0x08
    4f1c:	a9 85       	ldd	r26, Y+9	; 0x09
    4f1e:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f20:	85 a7       	std	Z+45, r24	; 0x2d
    4f22:	96 a7       	std	Z+46, r25	; 0x2e
    4f24:	a7 a7       	std	Z+47, r26	; 0x2f
    4f26:	b0 ab       	std	Z+48, r27	; 0x30
    4f28:	01 c0       	rjmp	.+2      	; 0x4f2c <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4f2a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f2c:	89 81       	ldd	r24, Y+1	; 0x01
    4f2e:	81 30       	cpi	r24, 0x01	; 1
    4f30:	b9 f5       	brne	.+110    	; 0x4fa0 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f32:	8b 81       	ldd	r24, Y+3	; 0x03
    4f34:	9c 81       	ldd	r25, Y+4	; 0x04
    4f36:	02 96       	adiw	r24, 0x02	; 2
    4f38:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    4f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    4f40:	96 89       	ldd	r25, Z+22	; 0x16
    4f42:	80 91 c0 06 	lds	r24, 0x06C0
    4f46:	89 17       	cp	r24, r25
    4f48:	28 f4       	brcc	.+10     	; 0x4f54 <xTaskGenericNotify+0x152>
    4f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    4f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    4f4e:	86 89       	ldd	r24, Z+22	; 0x16
    4f50:	80 93 c0 06 	sts	0x06C0, r24
    4f54:	eb 81       	ldd	r30, Y+3	; 0x03
    4f56:	fc 81       	ldd	r31, Y+4	; 0x04
    4f58:	86 89       	ldd	r24, Z+22	; 0x16
    4f5a:	28 2f       	mov	r18, r24
    4f5c:	30 e0       	ldi	r19, 0x00	; 0
    4f5e:	c9 01       	movw	r24, r18
    4f60:	88 0f       	add	r24, r24
    4f62:	99 1f       	adc	r25, r25
    4f64:	88 0f       	add	r24, r24
    4f66:	99 1f       	adc	r25, r25
    4f68:	88 0f       	add	r24, r24
    4f6a:	99 1f       	adc	r25, r25
    4f6c:	82 0f       	add	r24, r18
    4f6e:	93 1f       	adc	r25, r19
    4f70:	ac 01       	movw	r20, r24
    4f72:	45 53       	subi	r20, 0x35	; 53
    4f74:	59 4f       	sbci	r21, 0xF9	; 249
    4f76:	8b 81       	ldd	r24, Y+3	; 0x03
    4f78:	9c 81       	ldd	r25, Y+4	; 0x04
    4f7a:	9c 01       	movw	r18, r24
    4f7c:	2e 5f       	subi	r18, 0xFE	; 254
    4f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    4f80:	ca 01       	movw	r24, r20
    4f82:	b9 01       	movw	r22, r18
    4f84:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f88:	eb 81       	ldd	r30, Y+3	; 0x03
    4f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4f8c:	96 89       	ldd	r25, Z+22	; 0x16
    4f8e:	e0 91 ba 06 	lds	r30, 0x06BA
    4f92:	f0 91 bb 06 	lds	r31, 0x06BB
    4f96:	86 89       	ldd	r24, Z+22	; 0x16
    4f98:	89 17       	cp	r24, r25
    4f9a:	10 f4       	brcc	.+4      	; 0x4fa0 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4f9c:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4fa0:	0f 90       	pop	r0
    4fa2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4fa4:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4fa6:	2f 96       	adiw	r28, 0x0f	; 15
    4fa8:	0f b6       	in	r0, 0x3f	; 63
    4faa:	f8 94       	cli
    4fac:	de bf       	out	0x3e, r29	; 62
    4fae:	0f be       	out	0x3f, r0	; 63
    4fb0:	cd bf       	out	0x3d, r28	; 61
    4fb2:	cf 91       	pop	r28
    4fb4:	df 91       	pop	r29
    4fb6:	1f 91       	pop	r17
    4fb8:	0f 91       	pop	r16
    4fba:	08 95       	ret

00004fbc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4fbc:	ef 92       	push	r14
    4fbe:	ff 92       	push	r15
    4fc0:	0f 93       	push	r16
    4fc2:	1f 93       	push	r17
    4fc4:	df 93       	push	r29
    4fc6:	cf 93       	push	r28
    4fc8:	cd b7       	in	r28, 0x3d	; 61
    4fca:	de b7       	in	r29, 0x3e	; 62
    4fcc:	62 97       	sbiw	r28, 0x12	; 18
    4fce:	0f b6       	in	r0, 0x3f	; 63
    4fd0:	f8 94       	cli
    4fd2:	de bf       	out	0x3e, r29	; 62
    4fd4:	0f be       	out	0x3f, r0	; 63
    4fd6:	cd bf       	out	0x3d, r28	; 61
    4fd8:	9f 83       	std	Y+7, r25	; 0x07
    4fda:	8e 83       	std	Y+6, r24	; 0x06
    4fdc:	48 87       	std	Y+8, r20	; 0x08
    4fde:	59 87       	std	Y+9, r21	; 0x09
    4fe0:	6a 87       	std	Y+10, r22	; 0x0a
    4fe2:	7b 87       	std	Y+11, r23	; 0x0b
    4fe4:	2c 87       	std	Y+12, r18	; 0x0c
    4fe6:	1e 87       	std	Y+14, r17	; 0x0e
    4fe8:	0d 87       	std	Y+13, r16	; 0x0d
    4fea:	f8 8a       	std	Y+16, r15	; 0x10
    4fec:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4fee:	81 e0       	ldi	r24, 0x01	; 1
    4ff0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4ff2:	8e 81       	ldd	r24, Y+6	; 0x06
    4ff4:	9f 81       	ldd	r25, Y+7	; 0x07
    4ff6:	9d 83       	std	Y+5, r25	; 0x05
    4ff8:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4ffa:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    4ffc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ffe:	9e 85       	ldd	r25, Y+14	; 0x0e
    5000:	00 97       	sbiw	r24, 0x00	; 0
    5002:	61 f0       	breq	.+24     	; 0x501c <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5004:	ec 81       	ldd	r30, Y+4	; 0x04
    5006:	fd 81       	ldd	r31, Y+5	; 0x05
    5008:	85 a5       	ldd	r24, Z+45	; 0x2d
    500a:	96 a5       	ldd	r25, Z+46	; 0x2e
    500c:	a7 a5       	ldd	r26, Z+47	; 0x2f
    500e:	b0 a9       	ldd	r27, Z+48	; 0x30
    5010:	ed 85       	ldd	r30, Y+13	; 0x0d
    5012:	fe 85       	ldd	r31, Y+14	; 0x0e
    5014:	80 83       	st	Z, r24
    5016:	91 83       	std	Z+1, r25	; 0x01
    5018:	a2 83       	std	Z+2, r26	; 0x02
    501a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    501c:	ec 81       	ldd	r30, Y+4	; 0x04
    501e:	fd 81       	ldd	r31, Y+5	; 0x05
    5020:	81 a9       	ldd	r24, Z+49	; 0x31
    5022:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5024:	ec 81       	ldd	r30, Y+4	; 0x04
    5026:	fd 81       	ldd	r31, Y+5	; 0x05
    5028:	82 e0       	ldi	r24, 0x02	; 2
    502a:	81 ab       	std	Z+49, r24	; 0x31

			switch( eAction )
    502c:	8c 85       	ldd	r24, Y+12	; 0x0c
    502e:	28 2f       	mov	r18, r24
    5030:	30 e0       	ldi	r19, 0x00	; 0
    5032:	3a 8b       	std	Y+18, r19	; 0x12
    5034:	29 8b       	std	Y+17, r18	; 0x11
    5036:	89 89       	ldd	r24, Y+17	; 0x11
    5038:	9a 89       	ldd	r25, Y+18	; 0x12
    503a:	82 30       	cpi	r24, 0x02	; 2
    503c:	91 05       	cpc	r25, r1
    503e:	59 f1       	breq	.+86     	; 0x5096 <xTaskGenericNotifyFromISR+0xda>
    5040:	29 89       	ldd	r18, Y+17	; 0x11
    5042:	3a 89       	ldd	r19, Y+18	; 0x12
    5044:	23 30       	cpi	r18, 0x03	; 3
    5046:	31 05       	cpc	r19, r1
    5048:	34 f4       	brge	.+12     	; 0x5056 <xTaskGenericNotifyFromISR+0x9a>
    504a:	89 89       	ldd	r24, Y+17	; 0x11
    504c:	9a 89       	ldd	r25, Y+18	; 0x12
    504e:	81 30       	cpi	r24, 0x01	; 1
    5050:	91 05       	cpc	r25, r1
    5052:	61 f0       	breq	.+24     	; 0x506c <xTaskGenericNotifyFromISR+0xb0>
    5054:	4a c0       	rjmp	.+148    	; 0x50ea <xTaskGenericNotifyFromISR+0x12e>
    5056:	29 89       	ldd	r18, Y+17	; 0x11
    5058:	3a 89       	ldd	r19, Y+18	; 0x12
    505a:	23 30       	cpi	r18, 0x03	; 3
    505c:	31 05       	cpc	r19, r1
    505e:	59 f1       	breq	.+86     	; 0x50b6 <xTaskGenericNotifyFromISR+0xfa>
    5060:	89 89       	ldd	r24, Y+17	; 0x11
    5062:	9a 89       	ldd	r25, Y+18	; 0x12
    5064:	84 30       	cpi	r24, 0x04	; 4
    5066:	91 05       	cpc	r25, r1
    5068:	89 f1       	breq	.+98     	; 0x50cc <xTaskGenericNotifyFromISR+0x110>
    506a:	3f c0       	rjmp	.+126    	; 0x50ea <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    506c:	ec 81       	ldd	r30, Y+4	; 0x04
    506e:	fd 81       	ldd	r31, Y+5	; 0x05
    5070:	25 a5       	ldd	r18, Z+45	; 0x2d
    5072:	36 a5       	ldd	r19, Z+46	; 0x2e
    5074:	47 a5       	ldd	r20, Z+47	; 0x2f
    5076:	50 a9       	ldd	r21, Z+48	; 0x30
    5078:	88 85       	ldd	r24, Y+8	; 0x08
    507a:	99 85       	ldd	r25, Y+9	; 0x09
    507c:	aa 85       	ldd	r26, Y+10	; 0x0a
    507e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5080:	82 2b       	or	r24, r18
    5082:	93 2b       	or	r25, r19
    5084:	a4 2b       	or	r26, r20
    5086:	b5 2b       	or	r27, r21
    5088:	ec 81       	ldd	r30, Y+4	; 0x04
    508a:	fd 81       	ldd	r31, Y+5	; 0x05
    508c:	85 a7       	std	Z+45, r24	; 0x2d
    508e:	96 a7       	std	Z+46, r25	; 0x2e
    5090:	a7 a7       	std	Z+47, r26	; 0x2f
    5092:	b0 ab       	std	Z+48, r27	; 0x30
    5094:	2a c0       	rjmp	.+84     	; 0x50ea <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5096:	ec 81       	ldd	r30, Y+4	; 0x04
    5098:	fd 81       	ldd	r31, Y+5	; 0x05
    509a:	85 a5       	ldd	r24, Z+45	; 0x2d
    509c:	96 a5       	ldd	r25, Z+46	; 0x2e
    509e:	a7 a5       	ldd	r26, Z+47	; 0x2f
    50a0:	b0 a9       	ldd	r27, Z+48	; 0x30
    50a2:	01 96       	adiw	r24, 0x01	; 1
    50a4:	a1 1d       	adc	r26, r1
    50a6:	b1 1d       	adc	r27, r1
    50a8:	ec 81       	ldd	r30, Y+4	; 0x04
    50aa:	fd 81       	ldd	r31, Y+5	; 0x05
    50ac:	85 a7       	std	Z+45, r24	; 0x2d
    50ae:	96 a7       	std	Z+46, r25	; 0x2e
    50b0:	a7 a7       	std	Z+47, r26	; 0x2f
    50b2:	b0 ab       	std	Z+48, r27	; 0x30
    50b4:	1a c0       	rjmp	.+52     	; 0x50ea <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    50b6:	ec 81       	ldd	r30, Y+4	; 0x04
    50b8:	fd 81       	ldd	r31, Y+5	; 0x05
    50ba:	88 85       	ldd	r24, Y+8	; 0x08
    50bc:	99 85       	ldd	r25, Y+9	; 0x09
    50be:	aa 85       	ldd	r26, Y+10	; 0x0a
    50c0:	bb 85       	ldd	r27, Y+11	; 0x0b
    50c2:	85 a7       	std	Z+45, r24	; 0x2d
    50c4:	96 a7       	std	Z+46, r25	; 0x2e
    50c6:	a7 a7       	std	Z+47, r26	; 0x2f
    50c8:	b0 ab       	std	Z+48, r27	; 0x30
    50ca:	0f c0       	rjmp	.+30     	; 0x50ea <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    50cc:	8b 81       	ldd	r24, Y+3	; 0x03
    50ce:	82 30       	cpi	r24, 0x02	; 2
    50d0:	59 f0       	breq	.+22     	; 0x50e8 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    50d2:	ec 81       	ldd	r30, Y+4	; 0x04
    50d4:	fd 81       	ldd	r31, Y+5	; 0x05
    50d6:	88 85       	ldd	r24, Y+8	; 0x08
    50d8:	99 85       	ldd	r25, Y+9	; 0x09
    50da:	aa 85       	ldd	r26, Y+10	; 0x0a
    50dc:	bb 85       	ldd	r27, Y+11	; 0x0b
    50de:	85 a7       	std	Z+45, r24	; 0x2d
    50e0:	96 a7       	std	Z+46, r25	; 0x2e
    50e2:	a7 a7       	std	Z+47, r26	; 0x2f
    50e4:	b0 ab       	std	Z+48, r27	; 0x30
    50e6:	01 c0       	rjmp	.+2      	; 0x50ea <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    50e8:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    50ea:	8b 81       	ldd	r24, Y+3	; 0x03
    50ec:	81 30       	cpi	r24, 0x01	; 1
    50ee:	09 f0       	breq	.+2      	; 0x50f2 <xTaskGenericNotifyFromISR+0x136>
    50f0:	4f c0       	rjmp	.+158    	; 0x5190 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    50f2:	80 91 ca 06 	lds	r24, 0x06CA
    50f6:	88 23       	and	r24, r24
    50f8:	61 f5       	brne	.+88     	; 0x5152 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    50fa:	8c 81       	ldd	r24, Y+4	; 0x04
    50fc:	9d 81       	ldd	r25, Y+5	; 0x05
    50fe:	02 96       	adiw	r24, 0x02	; 2
    5100:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5104:	ec 81       	ldd	r30, Y+4	; 0x04
    5106:	fd 81       	ldd	r31, Y+5	; 0x05
    5108:	96 89       	ldd	r25, Z+22	; 0x16
    510a:	80 91 c0 06 	lds	r24, 0x06C0
    510e:	89 17       	cp	r24, r25
    5110:	28 f4       	brcc	.+10     	; 0x511c <xTaskGenericNotifyFromISR+0x160>
    5112:	ec 81       	ldd	r30, Y+4	; 0x04
    5114:	fd 81       	ldd	r31, Y+5	; 0x05
    5116:	86 89       	ldd	r24, Z+22	; 0x16
    5118:	80 93 c0 06 	sts	0x06C0, r24
    511c:	ec 81       	ldd	r30, Y+4	; 0x04
    511e:	fd 81       	ldd	r31, Y+5	; 0x05
    5120:	86 89       	ldd	r24, Z+22	; 0x16
    5122:	28 2f       	mov	r18, r24
    5124:	30 e0       	ldi	r19, 0x00	; 0
    5126:	c9 01       	movw	r24, r18
    5128:	88 0f       	add	r24, r24
    512a:	99 1f       	adc	r25, r25
    512c:	88 0f       	add	r24, r24
    512e:	99 1f       	adc	r25, r25
    5130:	88 0f       	add	r24, r24
    5132:	99 1f       	adc	r25, r25
    5134:	82 0f       	add	r24, r18
    5136:	93 1f       	adc	r25, r19
    5138:	ac 01       	movw	r20, r24
    513a:	45 53       	subi	r20, 0x35	; 53
    513c:	59 4f       	sbci	r21, 0xF9	; 249
    513e:	8c 81       	ldd	r24, Y+4	; 0x04
    5140:	9d 81       	ldd	r25, Y+5	; 0x05
    5142:	9c 01       	movw	r18, r24
    5144:	2e 5f       	subi	r18, 0xFE	; 254
    5146:	3f 4f       	sbci	r19, 0xFF	; 255
    5148:	ca 01       	movw	r24, r20
    514a:	b9 01       	movw	r22, r18
    514c:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
    5150:	0a c0       	rjmp	.+20     	; 0x5166 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5152:	8c 81       	ldd	r24, Y+4	; 0x04
    5154:	9d 81       	ldd	r25, Y+5	; 0x05
    5156:	9c 01       	movw	r18, r24
    5158:	24 5f       	subi	r18, 0xF4	; 244
    515a:	3f 4f       	sbci	r19, 0xFF	; 255
    515c:	8e e0       	ldi	r24, 0x0E	; 14
    515e:	97 e0       	ldi	r25, 0x07	; 7
    5160:	b9 01       	movw	r22, r18
    5162:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5166:	ec 81       	ldd	r30, Y+4	; 0x04
    5168:	fd 81       	ldd	r31, Y+5	; 0x05
    516a:	96 89       	ldd	r25, Z+22	; 0x16
    516c:	e0 91 ba 06 	lds	r30, 0x06BA
    5170:	f0 91 bb 06 	lds	r31, 0x06BB
    5174:	86 89       	ldd	r24, Z+22	; 0x16
    5176:	89 17       	cp	r24, r25
    5178:	58 f4       	brcc	.+22     	; 0x5190 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    517a:	8f 85       	ldd	r24, Y+15	; 0x0f
    517c:	98 89       	ldd	r25, Y+16	; 0x10
    517e:	00 97       	sbiw	r24, 0x00	; 0
    5180:	21 f0       	breq	.+8      	; 0x518a <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5182:	ef 85       	ldd	r30, Y+15	; 0x0f
    5184:	f8 89       	ldd	r31, Y+16	; 0x10
    5186:	81 e0       	ldi	r24, 0x01	; 1
    5188:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    518a:	81 e0       	ldi	r24, 0x01	; 1
    518c:	80 93 c3 06 	sts	0x06C3, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5190:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5192:	62 96       	adiw	r28, 0x12	; 18
    5194:	0f b6       	in	r0, 0x3f	; 63
    5196:	f8 94       	cli
    5198:	de bf       	out	0x3e, r29	; 62
    519a:	0f be       	out	0x3f, r0	; 63
    519c:	cd bf       	out	0x3d, r28	; 61
    519e:	cf 91       	pop	r28
    51a0:	df 91       	pop	r29
    51a2:	1f 91       	pop	r17
    51a4:	0f 91       	pop	r16
    51a6:	ff 90       	pop	r15
    51a8:	ef 90       	pop	r14
    51aa:	08 95       	ret

000051ac <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    51ac:	df 93       	push	r29
    51ae:	cf 93       	push	r28
    51b0:	cd b7       	in	r28, 0x3d	; 61
    51b2:	de b7       	in	r29, 0x3e	; 62
    51b4:	28 97       	sbiw	r28, 0x08	; 8
    51b6:	0f b6       	in	r0, 0x3f	; 63
    51b8:	f8 94       	cli
    51ba:	de bf       	out	0x3e, r29	; 62
    51bc:	0f be       	out	0x3f, r0	; 63
    51be:	cd bf       	out	0x3d, r28	; 61
    51c0:	9e 83       	std	Y+6, r25	; 0x06
    51c2:	8d 83       	std	Y+5, r24	; 0x05
    51c4:	78 87       	std	Y+8, r23	; 0x08
    51c6:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    51c8:	8d 81       	ldd	r24, Y+5	; 0x05
    51ca:	9e 81       	ldd	r25, Y+6	; 0x06
    51cc:	9c 83       	std	Y+4, r25	; 0x04
    51ce:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    51d0:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    51d2:	eb 81       	ldd	r30, Y+3	; 0x03
    51d4:	fc 81       	ldd	r31, Y+4	; 0x04
    51d6:	81 a9       	ldd	r24, Z+49	; 0x31
    51d8:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    51da:	eb 81       	ldd	r30, Y+3	; 0x03
    51dc:	fc 81       	ldd	r31, Y+4	; 0x04
    51de:	82 e0       	ldi	r24, 0x02	; 2
    51e0:	81 ab       	std	Z+49, r24	; 0x31

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    51e2:	eb 81       	ldd	r30, Y+3	; 0x03
    51e4:	fc 81       	ldd	r31, Y+4	; 0x04
    51e6:	85 a5       	ldd	r24, Z+45	; 0x2d
    51e8:	96 a5       	ldd	r25, Z+46	; 0x2e
    51ea:	a7 a5       	ldd	r26, Z+47	; 0x2f
    51ec:	b0 a9       	ldd	r27, Z+48	; 0x30
    51ee:	01 96       	adiw	r24, 0x01	; 1
    51f0:	a1 1d       	adc	r26, r1
    51f2:	b1 1d       	adc	r27, r1
    51f4:	eb 81       	ldd	r30, Y+3	; 0x03
    51f6:	fc 81       	ldd	r31, Y+4	; 0x04
    51f8:	85 a7       	std	Z+45, r24	; 0x2d
    51fa:	96 a7       	std	Z+46, r25	; 0x2e
    51fc:	a7 a7       	std	Z+47, r26	; 0x2f
    51fe:	b0 ab       	std	Z+48, r27	; 0x30

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5200:	8a 81       	ldd	r24, Y+2	; 0x02
    5202:	81 30       	cpi	r24, 0x01	; 1
    5204:	09 f0       	breq	.+2      	; 0x5208 <vTaskNotifyGiveFromISR+0x5c>
    5206:	4f c0       	rjmp	.+158    	; 0x52a6 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5208:	80 91 ca 06 	lds	r24, 0x06CA
    520c:	88 23       	and	r24, r24
    520e:	61 f5       	brne	.+88     	; 0x5268 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5210:	8b 81       	ldd	r24, Y+3	; 0x03
    5212:	9c 81       	ldd	r25, Y+4	; 0x04
    5214:	02 96       	adiw	r24, 0x02	; 2
    5216:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    521a:	eb 81       	ldd	r30, Y+3	; 0x03
    521c:	fc 81       	ldd	r31, Y+4	; 0x04
    521e:	96 89       	ldd	r25, Z+22	; 0x16
    5220:	80 91 c0 06 	lds	r24, 0x06C0
    5224:	89 17       	cp	r24, r25
    5226:	28 f4       	brcc	.+10     	; 0x5232 <vTaskNotifyGiveFromISR+0x86>
    5228:	eb 81       	ldd	r30, Y+3	; 0x03
    522a:	fc 81       	ldd	r31, Y+4	; 0x04
    522c:	86 89       	ldd	r24, Z+22	; 0x16
    522e:	80 93 c0 06 	sts	0x06C0, r24
    5232:	eb 81       	ldd	r30, Y+3	; 0x03
    5234:	fc 81       	ldd	r31, Y+4	; 0x04
    5236:	86 89       	ldd	r24, Z+22	; 0x16
    5238:	28 2f       	mov	r18, r24
    523a:	30 e0       	ldi	r19, 0x00	; 0
    523c:	c9 01       	movw	r24, r18
    523e:	88 0f       	add	r24, r24
    5240:	99 1f       	adc	r25, r25
    5242:	88 0f       	add	r24, r24
    5244:	99 1f       	adc	r25, r25
    5246:	88 0f       	add	r24, r24
    5248:	99 1f       	adc	r25, r25
    524a:	82 0f       	add	r24, r18
    524c:	93 1f       	adc	r25, r19
    524e:	ac 01       	movw	r20, r24
    5250:	45 53       	subi	r20, 0x35	; 53
    5252:	59 4f       	sbci	r21, 0xF9	; 249
    5254:	8b 81       	ldd	r24, Y+3	; 0x03
    5256:	9c 81       	ldd	r25, Y+4	; 0x04
    5258:	9c 01       	movw	r18, r24
    525a:	2e 5f       	subi	r18, 0xFE	; 254
    525c:	3f 4f       	sbci	r19, 0xFF	; 255
    525e:	ca 01       	movw	r24, r20
    5260:	b9 01       	movw	r22, r18
    5262:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
    5266:	0a c0       	rjmp	.+20     	; 0x527c <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5268:	8b 81       	ldd	r24, Y+3	; 0x03
    526a:	9c 81       	ldd	r25, Y+4	; 0x04
    526c:	9c 01       	movw	r18, r24
    526e:	24 5f       	subi	r18, 0xF4	; 244
    5270:	3f 4f       	sbci	r19, 0xFF	; 255
    5272:	8e e0       	ldi	r24, 0x0E	; 14
    5274:	97 e0       	ldi	r25, 0x07	; 7
    5276:	b9 01       	movw	r22, r18
    5278:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    527c:	eb 81       	ldd	r30, Y+3	; 0x03
    527e:	fc 81       	ldd	r31, Y+4	; 0x04
    5280:	96 89       	ldd	r25, Z+22	; 0x16
    5282:	e0 91 ba 06 	lds	r30, 0x06BA
    5286:	f0 91 bb 06 	lds	r31, 0x06BB
    528a:	86 89       	ldd	r24, Z+22	; 0x16
    528c:	89 17       	cp	r24, r25
    528e:	58 f4       	brcc	.+22     	; 0x52a6 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5290:	8f 81       	ldd	r24, Y+7	; 0x07
    5292:	98 85       	ldd	r25, Y+8	; 0x08
    5294:	00 97       	sbiw	r24, 0x00	; 0
    5296:	21 f0       	breq	.+8      	; 0x52a0 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5298:	ef 81       	ldd	r30, Y+7	; 0x07
    529a:	f8 85       	ldd	r31, Y+8	; 0x08
    529c:	81 e0       	ldi	r24, 0x01	; 1
    529e:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    52a0:	81 e0       	ldi	r24, 0x01	; 1
    52a2:	80 93 c3 06 	sts	0x06C3, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    52a6:	28 96       	adiw	r28, 0x08	; 8
    52a8:	0f b6       	in	r0, 0x3f	; 63
    52aa:	f8 94       	cli
    52ac:	de bf       	out	0x3e, r29	; 62
    52ae:	0f be       	out	0x3f, r0	; 63
    52b0:	cd bf       	out	0x3d, r28	; 61
    52b2:	cf 91       	pop	r28
    52b4:	df 91       	pop	r29
    52b6:	08 95       	ret

000052b8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    52b8:	df 93       	push	r29
    52ba:	cf 93       	push	r28
    52bc:	cd b7       	in	r28, 0x3d	; 61
    52be:	de b7       	in	r29, 0x3e	; 62
    52c0:	27 97       	sbiw	r28, 0x07	; 7
    52c2:	0f b6       	in	r0, 0x3f	; 63
    52c4:	f8 94       	cli
    52c6:	de bf       	out	0x3e, r29	; 62
    52c8:	0f be       	out	0x3f, r0	; 63
    52ca:	cd bf       	out	0x3d, r28	; 61
    52cc:	9d 83       	std	Y+5, r25	; 0x05
    52ce:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    52d0:	8c 81       	ldd	r24, Y+4	; 0x04
    52d2:	9d 81       	ldd	r25, Y+5	; 0x05
    52d4:	00 97       	sbiw	r24, 0x00	; 0
    52d6:	39 f4       	brne	.+14     	; 0x52e6 <xTaskNotifyStateClear+0x2e>
    52d8:	80 91 ba 06 	lds	r24, 0x06BA
    52dc:	90 91 bb 06 	lds	r25, 0x06BB
    52e0:	9f 83       	std	Y+7, r25	; 0x07
    52e2:	8e 83       	std	Y+6, r24	; 0x06
    52e4:	04 c0       	rjmp	.+8      	; 0x52ee <xTaskNotifyStateClear+0x36>
    52e6:	8c 81       	ldd	r24, Y+4	; 0x04
    52e8:	9d 81       	ldd	r25, Y+5	; 0x05
    52ea:	9f 83       	std	Y+7, r25	; 0x07
    52ec:	8e 83       	std	Y+6, r24	; 0x06
    52ee:	8e 81       	ldd	r24, Y+6	; 0x06
    52f0:	9f 81       	ldd	r25, Y+7	; 0x07
    52f2:	9b 83       	std	Y+3, r25	; 0x03
    52f4:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    52f6:	0f b6       	in	r0, 0x3f	; 63
    52f8:	f8 94       	cli
    52fa:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    52fc:	ea 81       	ldd	r30, Y+2	; 0x02
    52fe:	fb 81       	ldd	r31, Y+3	; 0x03
    5300:	81 a9       	ldd	r24, Z+49	; 0x31
    5302:	82 30       	cpi	r24, 0x02	; 2
    5304:	31 f4       	brne	.+12     	; 0x5312 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5306:	ea 81       	ldd	r30, Y+2	; 0x02
    5308:	fb 81       	ldd	r31, Y+3	; 0x03
    530a:	11 aa       	std	Z+49, r1	; 0x31
				xReturn = pdPASS;
    530c:	81 e0       	ldi	r24, 0x01	; 1
    530e:	89 83       	std	Y+1, r24	; 0x01
    5310:	01 c0       	rjmp	.+2      	; 0x5314 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5312:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5314:	0f 90       	pop	r0
    5316:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5318:	89 81       	ldd	r24, Y+1	; 0x01
	}
    531a:	27 96       	adiw	r28, 0x07	; 7
    531c:	0f b6       	in	r0, 0x3f	; 63
    531e:	f8 94       	cli
    5320:	de bf       	out	0x3e, r29	; 62
    5322:	0f be       	out	0x3f, r0	; 63
    5324:	cd bf       	out	0x3d, r28	; 61
    5326:	cf 91       	pop	r28
    5328:	df 91       	pop	r29
    532a:	08 95       	ret

0000532c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    532c:	df 93       	push	r29
    532e:	cf 93       	push	r28
    5330:	cd b7       	in	r28, 0x3d	; 61
    5332:	de b7       	in	r29, 0x3e	; 62
    5334:	27 97       	sbiw	r28, 0x07	; 7
    5336:	0f b6       	in	r0, 0x3f	; 63
    5338:	f8 94       	cli
    533a:	de bf       	out	0x3e, r29	; 62
    533c:	0f be       	out	0x3f, r0	; 63
    533e:	cd bf       	out	0x3d, r28	; 61
    5340:	9e 83       	std	Y+6, r25	; 0x06
    5342:	8d 83       	std	Y+5, r24	; 0x05
    5344:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5346:	80 91 be 06 	lds	r24, 0x06BE
    534a:	90 91 bf 06 	lds	r25, 0x06BF
    534e:	9a 83       	std	Y+2, r25	; 0x02
    5350:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5352:	80 91 ba 06 	lds	r24, 0x06BA
    5356:	90 91 bb 06 	lds	r25, 0x06BB
    535a:	02 96       	adiw	r24, 0x02	; 2
    535c:	0e 94 0a 0b 	call	0x1614	; 0x1614 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5360:	8d 81       	ldd	r24, Y+5	; 0x05
    5362:	9e 81       	ldd	r25, Y+6	; 0x06
    5364:	2f ef       	ldi	r18, 0xFF	; 255
    5366:	8f 3f       	cpi	r24, 0xFF	; 255
    5368:	92 07       	cpc	r25, r18
    536a:	81 f4       	brne	.+32     	; 0x538c <prvAddCurrentTaskToDelayedList+0x60>
    536c:	8f 81       	ldd	r24, Y+7	; 0x07
    536e:	88 23       	and	r24, r24
    5370:	69 f0       	breq	.+26     	; 0x538c <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5372:	80 91 ba 06 	lds	r24, 0x06BA
    5376:	90 91 bb 06 	lds	r25, 0x06BB
    537a:	9c 01       	movw	r18, r24
    537c:	2e 5f       	subi	r18, 0xFE	; 254
    537e:	3f 4f       	sbci	r19, 0xFF	; 255
    5380:	80 e2       	ldi	r24, 0x20	; 32
    5382:	97 e0       	ldi	r25, 0x07	; 7
    5384:	b9 01       	movw	r22, r18
    5386:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <vListInsertEnd>
    538a:	43 c0       	rjmp	.+134    	; 0x5412 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    538c:	29 81       	ldd	r18, Y+1	; 0x01
    538e:	3a 81       	ldd	r19, Y+2	; 0x02
    5390:	8d 81       	ldd	r24, Y+5	; 0x05
    5392:	9e 81       	ldd	r25, Y+6	; 0x06
    5394:	82 0f       	add	r24, r18
    5396:	93 1f       	adc	r25, r19
    5398:	9c 83       	std	Y+4, r25	; 0x04
    539a:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    539c:	e0 91 ba 06 	lds	r30, 0x06BA
    53a0:	f0 91 bb 06 	lds	r31, 0x06BB
    53a4:	8b 81       	ldd	r24, Y+3	; 0x03
    53a6:	9c 81       	ldd	r25, Y+4	; 0x04
    53a8:	93 83       	std	Z+3, r25	; 0x03
    53aa:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    53ac:	2b 81       	ldd	r18, Y+3	; 0x03
    53ae:	3c 81       	ldd	r19, Y+4	; 0x04
    53b0:	89 81       	ldd	r24, Y+1	; 0x01
    53b2:	9a 81       	ldd	r25, Y+2	; 0x02
    53b4:	28 17       	cp	r18, r24
    53b6:	39 07       	cpc	r19, r25
    53b8:	70 f4       	brcc	.+28     	; 0x53d6 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53ba:	80 91 0c 07 	lds	r24, 0x070C
    53be:	90 91 0d 07 	lds	r25, 0x070D
    53c2:	20 91 ba 06 	lds	r18, 0x06BA
    53c6:	30 91 bb 06 	lds	r19, 0x06BB
    53ca:	2e 5f       	subi	r18, 0xFE	; 254
    53cc:	3f 4f       	sbci	r19, 0xFF	; 255
    53ce:	b9 01       	movw	r22, r18
    53d0:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListInsert>
    53d4:	1e c0       	rjmp	.+60     	; 0x5412 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53d6:	40 91 0a 07 	lds	r20, 0x070A
    53da:	50 91 0b 07 	lds	r21, 0x070B
    53de:	80 91 ba 06 	lds	r24, 0x06BA
    53e2:	90 91 bb 06 	lds	r25, 0x06BB
    53e6:	9c 01       	movw	r18, r24
    53e8:	2e 5f       	subi	r18, 0xFE	; 254
    53ea:	3f 4f       	sbci	r19, 0xFF	; 255
    53ec:	ca 01       	movw	r24, r20
    53ee:	b9 01       	movw	r22, r18
    53f0:	0e 94 9e 0a 	call	0x153c	; 0x153c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    53f4:	20 91 c6 06 	lds	r18, 0x06C6
    53f8:	30 91 c7 06 	lds	r19, 0x06C7
    53fc:	8b 81       	ldd	r24, Y+3	; 0x03
    53fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5400:	82 17       	cp	r24, r18
    5402:	93 07       	cpc	r25, r19
    5404:	30 f4       	brcc	.+12     	; 0x5412 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5406:	8b 81       	ldd	r24, Y+3	; 0x03
    5408:	9c 81       	ldd	r25, Y+4	; 0x04
    540a:	90 93 c7 06 	sts	0x06C7, r25
    540e:	80 93 c6 06 	sts	0x06C6, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5412:	27 96       	adiw	r28, 0x07	; 7
    5414:	0f b6       	in	r0, 0x3f	; 63
    5416:	f8 94       	cli
    5418:	de bf       	out	0x3e, r29	; 62
    541a:	0f be       	out	0x3f, r0	; 63
    541c:	cd bf       	out	0x3d, r28	; 61
    541e:	cf 91       	pop	r28
    5420:	df 91       	pop	r29
    5422:	08 95       	ret

00005424 <memcpy>:
    5424:	fb 01       	movw	r30, r22
    5426:	dc 01       	movw	r26, r24
    5428:	02 c0       	rjmp	.+4      	; 0x542e <memcpy+0xa>
    542a:	01 90       	ld	r0, Z+
    542c:	0d 92       	st	X+, r0
    542e:	41 50       	subi	r20, 0x01	; 1
    5430:	50 40       	sbci	r21, 0x00	; 0
    5432:	d8 f7       	brcc	.-10     	; 0x542a <memcpy+0x6>
    5434:	08 95       	ret

00005436 <memset>:
    5436:	dc 01       	movw	r26, r24
    5438:	01 c0       	rjmp	.+2      	; 0x543c <memset+0x6>
    543a:	6d 93       	st	X+, r22
    543c:	41 50       	subi	r20, 0x01	; 1
    543e:	50 40       	sbci	r21, 0x00	; 0
    5440:	e0 f7       	brcc	.-8      	; 0x543a <memset+0x4>
    5442:	08 95       	ret

00005444 <_exit>:
    5444:	f8 94       	cli

00005446 <__stop_program>:
    5446:	ff cf       	rjmp	.-2      	; 0x5446 <__stop_program>
